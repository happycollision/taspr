{"id":"taspr-0du","title":"Land command (single PR)","description":"## Goal\nImplement `taspr land` to merge the bottom ready PR.\n\n## Implementation\n\n```typescript\n// src/cli/commands/land.ts\n\nexport const landCommand = new Command('land')\n  .description('Merge the bottom ready PR in the stack')\n  .option('--all', 'Merge all consecutive ready PRs')\n  .action(async (options) =\u003e {\n    // Parse stack and get PR info\n    const result = await parseStack();\n    if (!result.ok) {\n      console.error(formatValidationError(result));\n      process.exit(1);\n    }\n    \n    const config = await getBranchNameConfig();\n    const enrichedUnits = await enrichWithPRInfo(result.units, config);\n    \n    // Find bottom unmerged PR\n    const unmerged = enrichedUnits.filter(u =\u003e u.pr?.state === 'open');\n    if (unmerged.length === 0) {\n      console.log('No unmerged PRs in stack');\n      return;\n    }\n    \n    const bottom = unmerged[0];\n    \n    // Check if ready\n    const status = await getPRMergeStatus(bottom.pr!.number);\n    if (!status.mergeable) {\n      console.error(\\`âœ— PR #\\${bottom.pr!.number} is not ready:\\\\n\\`);\n      if (status.checksStatus === 'failing') {\n        console.error('  â€¢ CI checks failing');\n      }\n      if (status.reviewDecision !== 'approved') {\n        console.error('  â€¢ Needs approval');\n      }\n      process.exit(1);\n    }\n    \n    // Merge\n    console.log(\\`Merging PR #\\${bottom.pr!.number} (\\${bottom.title})...\\`);\n    const result = await mergePR(bottom.pr!.number);\n    console.log(\\`âœ“ Merged PR #\\${bottom.pr!.number} to main\\`);\n  });\n```\n\n## Output\n\n### Success\n```\n$ taspr land\n\nMerging PR #142 (Add user model)...\nâœ“ Merged PR #142 to main\n```\n\n### Not Ready\n```\n$ taspr land\n\nâœ— PR #142 is not ready:\n  â€¢ CI checks failing\n\nRun 'taspr view' to see status.\n```\n\n### No PRs\n```\n$ taspr land\n\nNo unmerged PRs in stack\n```\n\n## Testing\n- Land ready PR â†’ success\n- Land non-ready PR â†’ error with reason\n- Empty stack â†’ appropriate message\n\n## Files to Create\n- src/cli/commands/land.ts\n\n## Acceptance Criteria\n- [ ] Merges bottom open PR when ready\n- [ ] Clear error when PR not ready\n- [ ] Reports success with PR number\n- [ ] Handles empty stack","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T14:31:28.590491-05:00","updated_at":"2025-12-30T14:11:15.979654-05:00","closed_at":"2025-12-30T14:11:15.979654-05:00","close_reason":"Implemented land command that merges the bottom open PR in the stack using fast-forward merge. Includes branch cleanup after successful merge and proper error handling for non-fast-forwardable PRs.","dependencies":[{"issue_id":"taspr-0du","depends_on_id":"taspr-6le","type":"parent-child","created_at":"2025-12-25T14:31:32.341642-05:00","created_by":"daemon"},{"issue_id":"taspr-0du","depends_on_id":"taspr-bwi","type":"blocks","created_at":"2025-12-25T14:31:32.613862-05:00","created_by":"daemon"},{"issue_id":"taspr-0du","depends_on_id":"taspr-bwi","type":"depends-on","created_at":"2025-12-25T14:31:32.613862-05:00","created_by":"daemon"}]}
{"id":"taspr-0lj","title":"Project scaffolding and CLI setup","description":"## Goal\nSet up the Bun project structure, dependencies, and basic CLI scaffolding.\n\n## Tasks\n\n### 1. Initialize Bun project\n- Update package.json with proper metadata\n- Add dependencies: commander\n- Add devDependencies: @types/bun (already present)\n- Configure bun build for CLI compilation\n\n### 2. Create directory structure\n```\nsrc/\nâ”œâ”€â”€ cli/\nâ”‚   â”œâ”€â”€ index.ts          # Entry point\nâ”‚   â””â”€â”€ commands/         # Command implementations\nâ”œâ”€â”€ core/                 # Business logic\nâ”œâ”€â”€ git/                  # Git operations\nâ””â”€â”€ types.ts              # Shared types\ntests/\nâ”œâ”€â”€ helpers/              # Test utilities\nâ””â”€â”€ ...                   # Test files\n```\n\n### 3. Set up CLI with Commander\n- Create main entry point at src/cli/index.ts\n- Configure program name, version, description\n- Add placeholder commands: view, sync, land, group\n- Ensure `bun run src/cli/index.ts` works\n\n### 4. Configure TypeScript\n- Strict mode enabled (already in tsconfig.json)\n- Path aliases if needed\n- Ensure types work with Bun\n\n### 5. Set up test infrastructure\n- Configure bun:test\n- Create test helper for creating temporary git repositories\n- Add test scripts to package.json\n\n### 6. Add build script\n- `bun build --compile` for standalone binary\n- Cross-platform target support\n\n## Acceptance Criteria\n- [ ] Running `bun run src/cli/index.ts --help` shows help\n- [ ] Running `bun run src/cli/index.ts view` shows placeholder message\n- [ ] Running `bun test` executes a sample test\n- [ ] TypeScript compiles without errors\n\n## Files to Create/Modify\n- package.json (modify)\n- src/cli/index.ts (create)\n- src/cli/commands/view.ts (create - placeholder)\n- src/types.ts (create - empty or with basic interfaces)\n- tests/helpers/git-fixture.ts (create)\n- tests/sample.test.ts (create - simple test)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T14:22:10.925801-05:00","updated_at":"2025-12-25T23:42:42.674094-05:00","closed_at":"2025-12-25T23:42:42.674094-05:00","close_reason":"Closed","dependencies":[{"issue_id":"taspr-0lj","depends_on_id":"taspr-h87","type":"parent-child","created_at":"2025-12-25T14:22:18.35922-05:00","created_by":"daemon"}]}
{"id":"taspr-1en","title":"Fetch PR review status","description":"## Goal\nGet review approval status for PRs.\n\n## Implementation\n\n```typescript\n// src/github/pr.ts\n\ntype ReviewStatus = 'approved' | 'changes_requested' | 'pending';\n\nasync function getPRReviewStatus(prNumber: number): Promise\u003cReviewStatus\u003e {\n  const result = await $\\`gh pr view \\${prNumber} --json reviewDecision\\`;\n  const data = JSON.parse(result.stdout.toString());\n  \n  switch (data.reviewDecision) {\n    case 'APPROVED': return 'approved';\n    case 'CHANGES_REQUESTED': return 'changes_requested';\n    default: return 'pending';\n  }\n}\n```\n\n## Review Decision Values\n- `APPROVED` - Required reviewers approved\n- `CHANGES_REQUESTED` - Reviewer requested changes\n- `REVIEW_REQUIRED` - Waiting for reviews\n- `null` - No reviews required\n\n## Testing\n- PR with approved reviews\n- PR with changes requested\n- PR awaiting review\n- PR with no review requirements\n\n## Files to Modify\n- src/github/pr.ts\n\n## Acceptance Criteria\n- [ ] Returns correct review status\n- [ ] Handles PRs without review requirements\n- [ ] Handles multiple reviewers","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-25T14:32:34.466183-05:00","updated_at":"2025-12-31T12:41:18.296812-05:00","closed_at":"2025-12-31T12:41:18.296812-05:00","close_reason":"Already implemented: getPRReviewStatus function exists at src/github/pr.ts:224-243 with determineReviewDecision helper at lines 72-83. Unit tests cover all review decision mappings (pr.test.ts:104-128). Integration tests verify: 'none' for PRs without review requirements, 'review_required' when branch protection requires reviews. Tests for 'approved' and 'changes_requested' are skipped (GitHub prevents self-review) but the logic is tested via unit tests.","dependencies":[{"issue_id":"taspr-1en","depends_on_id":"taspr-v0c","type":"parent-child","created_at":"2025-12-25T14:32:38.0954-05:00","created_by":"daemon"}]}
{"id":"taspr-1es","title":"ID generation","description":"## Goal\nGenerate unique 8-character hex IDs for commits.\n\n## Implementation\n\n```typescript\n// src/core/id.ts\nimport { randomBytes } from 'crypto';\n\nexport function generateCommitId(): string {\n  return randomBytes(4).toString('hex');\n}\n```\n\n### Properties\n- 8 hex characters = 32 bits = 4 billion possibilities\n- Collision risk negligible for active stacks (typically \u003c 50 commits)\n- Once PRs merge, their IDs leave the active set\n\n### Usage Contexts\n1. `Taspr-Commit-Id` - Assigned to every commit\n2. `Taspr-Group-Start` / `Taspr-Group-End` - Marks group boundaries\n\nSame generation function, different semantic use.\n\n## Testing\n- Generate many IDs, verify format (8 hex chars)\n- Verify uniqueness over reasonable sample size\n\n## Files to Create\n- src/core/id.ts\n\n## Acceptance Criteria\n- [ ] Generates 8-character hex strings\n- [ ] Uses crypto for randomness\n- [ ] Has basic tests","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T14:24:45.726897-05:00","updated_at":"2025-12-26T21:03:50.523511-05:00","closed_at":"2025-12-26T21:03:50.523511-05:00","close_reason":"Implemented generateCommitId() in src/core/id.ts with tests","dependencies":[{"issue_id":"taspr-1es","depends_on_id":"taspr-7tr","type":"parent-child","created_at":"2025-12-25T14:24:49.603638-05:00","created_by":"daemon"}]}
{"id":"taspr-1ni","title":"Epic 4: Update PRs After Local Changes","description":"## Goal\nWhen commits change (amend, rebase), update the corresponding GitHub branches to keep PRs in sync.\n\n## Background\n\n### The Update Problem\nAfter commits are amended or rebased:\n- Commit hashes change\n- Local branch diverges from remote\n- PRs show stale code\n\ntaspr needs to detect these changes and force-push updated branches.\n\n### How Changes Are Detected\nCompare local commit hash to remote branch tip:\n```bash\ngit rev-parse taspr/user/a1b2c3d4  # Remote branch tip\ngit rev-parse HEAD~2               # Local commit for that PRUnit\n```\n\nIf they differ, the branch needs updating.\n\n## Workflow\n\n1. User amends a commit or rebases\n2. User runs `taspr sync`\n3. For each PRUnit:\n   - Compare local commit to remote branch\n   - If different, force-push the branch\n4. Report updated branches/PRs\n\n## Implementation Approach\n\n### Change Detection\n```typescript\nasync function getBranchCommit(branchName: string): Promise\u003cstring | null\u003e {\n  const result = await $\\`git rev-parse origin/${branchName}\\`.nothrow();\n  return result.exitCode === 0 ? result.stdout.toString().trim() : null;\n}\n\nasync function needsUpdate(unit: PRUnit, branchName: string): Promise\u003cboolean\u003e {\n  const remote = await getBranchCommit(branchName);\n  const local = unit.commits[unit.commits.length - 1];\n  return remote !== local;\n}\n```\n\n### Force Push\n```typescript\nasync function updateBranch(commitHash: string, branchName: string): Promise\u003cvoid\u003e {\n  await $\\`git push --force origin ${commitHash}:refs/heads/${branchName}\\`;\n}\n```\n\n## Deliverable\nRunning `taspr sync` force-pushes branches where commit hashes changed, keeping PRs in sync with local state.\n\n## Dependencies\n- Epic 3 must be complete (branches and PRs exist)\n\n## MVP Note\nAfter Epic 4, you have a working MVP:\n- Create commits with IDs\n- Push as stacked PRs\n- Update PRs when local commits change\n\n## Testable Outcome\nAmending a commit and running sync updates the PR on GitHub.","status":"closed","priority":1,"issue_type":"epic","created_at":"2025-12-25T14:29:07.59809-05:00","updated_at":"2025-12-30T00:25:32.087209-05:00","closed_at":"2025-12-30T00:25:32.087209-05:00","close_reason":"All child tasks completed: change detection, force push, view command, and git config options are all implemented.","dependencies":[{"issue_id":"taspr-1ni","depends_on_id":"taspr-osw","type":"blocks","created_at":"2025-12-25T14:29:12.092882-05:00","created_by":"daemon"},{"issue_id":"taspr-1ni","depends_on_id":"taspr-osw","type":"depends-on","created_at":"2025-12-25T14:29:12.092882-05:00","created_by":"daemon"}]}
{"id":"taspr-1zp","title":"Land --all flag","description":"## Goal\nImplement `taspr land --all` to merge all consecutive ready PRs.\n\n## Behavior\nMerge PRs from the bottom up, stopping at the first non-ready PR.\n\n```\nStack: [#142 ready] â†’ [#143 ready] â†’ [#144 not ready] â†’ [#145 ready]\n\ntaspr land --all merges #142 and #143, then stops at #144.\n```\n\n## Implementation\n\n```typescript\nasync function landAll() {\n  const units = await getEnrichedPRUnits();\n  \n  let merged = 0;\n  \n  for (const unit of units) {\n    if (unit.pr?.state !== 'open') continue;\n    \n    const status = await getPRMergeStatus(unit.pr.number);\n    \n    if (!status.mergeable) {\n      if (merged \u003e 0) {\n        console.log(\\`\\\\nStopping at PR #\\${unit.pr.number} (not ready)\\`);\n      }\n      break;\n    }\n    \n    console.log(\\`Merging PR #\\${unit.pr.number} (\\${unit.title})...\\`);\n    await mergePR(unit.pr.number);\n    console.log(\\`âœ“ Merged PR #\\${unit.pr.number} to main\\\\n\\`);\n    merged++;\n    \n    // Brief pause for GitHub to update\n    await sleep(1000);\n  }\n  \n  if (merged === 0) {\n    console.log('No ready PRs to merge');\n  } else {\n    console.log(\\`\\\\nâœ“ Merged \\${merged} PR(s)\\`);\n  }\n}\n```\n\n## Output\n```\n$ taspr land --all\n\nMerging PR #142 (Add user model)...\nâœ“ Merged PR #142 to main\n\nMerging PR #143 (Add authentication)...\nâœ“ Merged PR #143 to main\n\nStopping at PR #144 (not ready: CI failing)\n\nâœ“ Merged 2 PR(s)\n```\n\n## Testing\n- All ready â†’ merges all\n- Some ready â†’ merges until non-ready\n- None ready â†’ reports nothing to merge\n\n## Files to Modify\n- src/cli/commands/land.ts\n\n## Acceptance Criteria\n- [ ] Merges consecutive ready PRs\n- [ ] Stops at first non-ready PR\n- [ ] Reports total merged\n- [ ] Pauses between merges for GitHub sync","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T14:31:44.165633-05:00","updated_at":"2025-12-31T00:15:48.111291-05:00","closed_at":"2025-12-31T00:15:48.111291-05:00","close_reason":"Fully implemented - land command supports --all flag with consecutive PR merging, retargeting, and cleanup","dependencies":[{"issue_id":"taspr-1zp","depends_on_id":"taspr-6le","type":"parent-child","created_at":"2025-12-25T14:31:51.536244-05:00","created_by":"daemon"},{"issue_id":"taspr-1zp","depends_on_id":"taspr-0du","type":"blocks","created_at":"2025-12-25T14:31:51.81248-05:00","created_by":"daemon"},{"issue_id":"taspr-1zp","depends_on_id":"taspr-0du","type":"depends-on","created_at":"2025-12-25T14:31:51.81248-05:00","created_by":"daemon"}]}
{"id":"taspr-2m1","title":"Enhanced view formatting with status indicators","description":"## Goal\nUpdate view output to show blocking indicators for each PR.\n\n## Implementation\n\n```typescript\n// src/cli/output.ts\n\ninterface PRStatusInfo {\n  checks: 'pending' | 'passing' | 'failing';\n  review: 'approved' | 'changes_requested' | 'pending';\n  comments: { total: number; resolved: number };\n}\n\nfunction formatBlockingIndicators(status: PRStatusInfo): string {\n  const indicators: string[] = [];\n  \n  // Comment threads\n  if (status.comments.total \u003e 0 \u0026\u0026 status.comments.resolved \u003c status.comments.total) {\n    indicators.push(\\`ğŸ’¬ \\${status.comments.resolved}/\\${status.comments.total}\\`);\n  }\n  \n  // CI checks\n  if (status.checks === 'pending') {\n    indicators.push('â³ checks');\n  } else if (status.checks === 'failing') {\n    indicators.push('âœ— checks');\n  }\n  \n  // Review status\n  if (status.review === 'pending') {\n    indicators.push('ğŸ‘€ review');\n  } else if (status.review === 'changes_requested') {\n    indicators.push('âœ— review');\n  }\n  \n  return indicators.join('  ');\n}\n```\n\n## Output Format\n```\n  â— #143 Authentication feature            ğŸ’¬ 3/5  â³ checks\n```\n\nThe indicators are right-aligned after the title.\n\n## Testing\n- PR with multiple blocking indicators\n- PR with single indicator\n- PR with no blockers (shows nothing extra)\n\n## Files to Modify\n- src/cli/output.ts\n- src/cli/commands/view.ts\n\n## Acceptance Criteria\n- [ ] Shows comment thread status\n- [ ] Shows CI check status\n- [ ] Shows review status\n- [ ] Clean formatting with proper alignment","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-25T14:32:59.785483-05:00","updated_at":"2025-12-31T13:39:34.02718-05:00","closed_at":"2025-12-31T13:39:34.02718-05:00","close_reason":"Implemented status indicators in view command showing comment threads, CI checks, and review status for open PRs","dependencies":[{"issue_id":"taspr-2m1","depends_on_id":"taspr-v0c","type":"parent-child","created_at":"2025-12-25T14:33:04.509152-05:00","created_by":"daemon"},{"issue_id":"taspr-2m1","depends_on_id":"taspr-d6u","type":"blocks","created_at":"2025-12-25T14:33:04.785797-05:00","created_by":"daemon"},{"issue_id":"taspr-2m1","depends_on_id":"taspr-d6u","type":"depends-on","created_at":"2025-12-25T14:33:04.785797-05:00","created_by":"daemon"},{"issue_id":"taspr-2m1","depends_on_id":"taspr-1en","type":"blocks","created_at":"2025-12-25T14:33:05.057758-05:00","created_by":"daemon"},{"issue_id":"taspr-2m1","depends_on_id":"taspr-1en","type":"depends-on","created_at":"2025-12-25T14:33:05.057758-05:00","created_by":"daemon"},{"issue_id":"taspr-2m1","depends_on_id":"taspr-e6f","type":"blocks","created_at":"2025-12-25T14:33:05.327966-05:00","created_by":"daemon"},{"issue_id":"taspr-2m1","depends_on_id":"taspr-e6f","type":"depends-on","created_at":"2025-12-25T14:33:05.327966-05:00","created_by":"daemon"}]}
{"id":"taspr-33h","title":"Add test-logs/ to .gitignore","description":"Read the parent epic taspr-ww0 for full context.\n\n## Task\nAdd test-logs/ directory to .gitignore so generated story logs are not committed.\n\n## Files\n- .gitignore\n\n## Note\nThis is a simple one-liner but listed as a separate task for completeness. Can be done alongside any other task.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-05T00:33:33.499913-05:00","updated_at":"2026-01-05T00:33:33.499913-05:00","dependencies":[{"issue_id":"taspr-33h","depends_on_id":"taspr-ww0","type":"parent-child","created_at":"2026-01-05T00:33:43.981899-05:00","created_by":"dondenton"}]}
{"id":"taspr-37l","title":"Group create command","description":"## Goal\nImplement `taspr group create` to bundle commits into a single PR.\n\n## Implementation\n\n```typescript\n// src/cli/commands/group.ts\n\nexport const groupCommand = new Command('group')\n  .description('Manage commit groups');\n\ngroupCommand\n  .command('create')\n  .description('Create a new group from selected commits')\n  .action(async () =\u003e {\n    // Get current stack\n    const result = await parseStack();\n    if (!result.ok) {\n      console.error(formatValidationError(result));\n      process.exit(1);\n    }\n    \n    // Show commit selection\n    const selected = await selectCommits(result.units);\n    \n    // Validate selection\n    const validation = validateGroupSelection(selected, result.units);\n    if (!validation.ok) {\n      console.error(validation.error);\n      process.exit(1);\n    }\n    \n    // Get PR title\n    const title = await input({ message: 'PR title:' });\n    \n    // Warn about existing PRs\n    await warnAboutExistingPRs(selected);\n    \n    // Confirm\n    const proceed = await confirm({ message: 'Proceed?' });\n    if (!proceed) return;\n    \n    // Add group trailers\n    const groupId = generateId();\n    await addGroupTrailers(selected, groupId, title);\n    \n    console.log(\\`âœ“ Created group \\${groupId}\\`);\n    console.log(\\`  Title: \"\\${title}\"\\`);\n    console.log(\\`  Run \\`taspr sync --open\\` to create the PR.\\`);\n  });\n```\n\n### Adding Group Trailers\n```typescript\nasync function addGroupTrailers(\n  commits: CommitInfo[],\n  groupId: string,\n  title: string\n): Promise\u003cvoid\u003e {\n  const first = commits[0];\n  const last = commits[commits.length - 1];\n  \n  // Add Start and Title to first commit\n  await addTrailersToCommit(first.hash, {\n    'Taspr-Group-Start': groupId,\n    'Taspr-Group-Title': title,\n  });\n  \n  // Add End to last commit (if different from first)\n  if (last.hash !== first.hash) {\n    await addTrailersToCommit(last.hash, {\n      'Taspr-Group-End': groupId,\n    });\n  }\n}\n```\n\n## Warnings\nIf selected commits have existing PRs:\n```\nâš  Warning: Commit b2c3d4e5 has open PR #145. \n  Grouping it will close PR #145 when you sync.\n```\n\n## Testing\n- Create group from 2 commits\n- Create group from all commits\n- Validate contiguous requirement\n- Warn about existing PRs\n\n## Files to Create\n- src/cli/commands/group.ts\n- src/core/group.ts\n\n## Acceptance Criteria\n- [ ] Interactive commit selection\n- [ ] Validates contiguous selection\n- [ ] Adds correct trailers to correct commits\n- [ ] Warns about existing PRs\n- [ ] Confirms before making changes","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-25T14:34:15.681194-05:00","updated_at":"2026-01-01T22:45:35.437247-05:00","closed_at":"2026-01-01T22:45:35.437247-05:00","close_reason":"Replaced by unified group TUI - see taspr-7mu for revised plan","dependencies":[{"issue_id":"taspr-37l","depends_on_id":"taspr-7mu","type":"parent-child","created_at":"2025-12-25T14:34:19.387363-05:00","created_by":"daemon"},{"issue_id":"taspr-37l","depends_on_id":"taspr-q9i","type":"blocks","created_at":"2025-12-25T14:34:19.666321-05:00","created_by":"daemon"},{"issue_id":"taspr-37l","depends_on_id":"taspr-q9i","type":"depends-on","created_at":"2025-12-25T14:34:19.666321-05:00","created_by":"daemon"}]}
{"id":"taspr-3lr","title":"Force push updated branches","description":"## Goal\nForce-push branches that have changed after local commit amendments.\n\n## Implementation\n\n```typescript\n// src/github/branches.ts\n\nasync function forcePushBranch(commitHash: string, branchName: string): Promise\u003cvoid\u003e {\n  await $\\`git push --force origin ${commitHash}:refs/heads/${branchName}\\`;\n}\n\nasync function updateChangedBranches(\n  units: PRUnit[],\n  statuses: Map\u003cstring, SyncStatus\u003e,\n  config: BranchNameConfig\n): Promise\u003cstring[]\u003e {\n  const updated: string[] = [];\n  \n  for (const unit of units) {\n    const status = statuses.get(unit.id)!;\n    \n    if (status.needsUpdate) {\n      await forcePushBranch(status.localCommit, status.branchName);\n      updated.push(status.branchName);\n    }\n  }\n  \n  return updated;\n}\n```\n\n### Safety Considerations\n- Force push is destructiveâ€”overwrites remote branch\n- Fine for taspr branches (single owner)\n- GitHub retains old commits briefly via reflog\n\n### Reporting\n```\n$ taspr sync\n\nâœ“ Updated 2 branch(es):\n  â€¢ taspr/msims/a1b2c3d4 (b2c3d4e5 â†’ new-hash)\n  â€¢ taspr/msims/f7e8d9c0 (c3d4e5f6 â†’ new-hash)\n```\n\n## Integration with Sync Command\nThe sync command now:\n1. Injects missing IDs (Epic 2)\n2. For each unit:\n   - If no remote branch: push + create PR (Epic 3)\n   - If remote differs: force push (this task)\n   - If up to date: skip\n\n## Testing\n- Force push succeeds\n- Old commit is replaced\n- PR reflects new code\n\n## Files to Modify\n- src/github/branches.ts\n\n## Acceptance Criteria\n- [ ] Force pushes changed branches\n- [ ] Reports which branches were updated\n- [ ] Handles push failures gracefully","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T14:29:39.346235-05:00","updated_at":"2025-12-30T00:25:21.568515-05:00","closed_at":"2025-12-30T00:25:21.568515-05:00","close_reason":"Already implemented. Force push is integrated via pushBranch(commit, branch, force=true) when needsUpdate is detected. All tests pass.","dependencies":[{"issue_id":"taspr-3lr","depends_on_id":"taspr-1ni","type":"parent-child","created_at":"2025-12-25T14:29:42.942259-05:00","created_by":"daemon"},{"issue_id":"taspr-3lr","depends_on_id":"taspr-eik","type":"blocks","created_at":"2025-12-25T14:29:43.214548-05:00","created_by":"daemon"},{"issue_id":"taspr-3lr","depends_on_id":"taspr-eik","type":"depends-on","created_at":"2025-12-25T14:29:43.214548-05:00","created_by":"daemon"}]}
{"id":"taspr-41a","title":"View command with PR info","description":"## Goal\nEnhance `taspr view` to show PR numbers and basic status for each PRUnit.\n\n## Current State (from Epic 1)\nView shows local stack structure:\n```\n  â—‹ Add user model\n    â””â”€ a1b2c3d4\n```\n\n## Enhanced Output\nWith PR info from GitHub:\n```\n  â— #142 Add user model\n    â””â”€ a1b2c3d4\n    https://github.com/org/repo/pull/142\n```\n\n### Status Indicators\n- `âœ“` Merged\n- `â—` Open\n- `â—‹` No PR yet\n- `âœ—` Closed (not merged)\n\n## Implementation\n\n```typescript\n// src/cli/commands/view.ts\n\nasync function viewCommand() {\n  const result = await parseStack();\n  if (!result.ok) { /* handle error */ }\n  \n  // Get branch config for lookups\n  const config = await getBranchNameConfig();\n  \n  // Enrich units with PR info\n  const enrichedUnits = await Promise.all(\n    result.units.map(async unit =\u003e {\n      const branch = getBranchName(unit.id, config);\n      const pr = await findPRByBranch(branch);\n      return { ...unit, pr };\n    })\n  );\n  \n  // Format and display\n  console.log(formatStackView(enrichedUnits));\n}\n```\n\n### Updated Formatting\n```typescript\nfunction formatPRUnit(unit: EnrichedPRUnit): string {\n  const status = getPRStatusIcon(unit.pr);\n  const prNum = unit.pr ? \\`#\\${unit.pr.number} \\` : '';\n  const title = unit.title;\n  \n  let output = \\`  \\${status} \\${prNum}\\${title}\\\\n\\`;\n  \n  // Commits\n  for (const commit of unit.commits) {\n    output += \\`    â””â”€ \\${commit.slice(0, 8)}\\\\n\\`;\n  }\n  \n  // PR URL\n  if (unit.pr) {\n    output += \\`    \\${unit.pr.url}\\\\n\\`;\n  }\n  \n  return output;\n}\n\nfunction getPRStatusIcon(pr: PRInfo | null): string {\n  if (!pr) return 'â—‹';\n  switch (pr.state) {\n    case 'open': return 'â—';\n    case 'merged': return 'âœ“';\n    case 'closed': return 'âœ—';\n    default: return 'â—‹';\n  }\n}\n```\n\n## Caching for Performance\nPR lookups are slow. Consider caching:\n- Within a single view command\n- Optional: `.git/taspr/cache.json` with TTL\n\nFor now, just parallelize lookups within view.\n\n## Testing\n- View with no PRs â†’ all â—‹\n- View with open PRs â†’ shows â— and URLs\n- View with mixed states\n\n## Files to Modify\n- src/cli/commands/view.ts\n- src/cli/output.ts\n\n## Acceptance Criteria\n- [ ] Shows PR numbers when PRs exist\n- [ ] Shows correct status icons\n- [ ] Shows PR URLs\n- [ ] Handles units without PRs gracefully","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T14:29:59.545059-05:00","updated_at":"2025-12-28T23:45:48.773948-05:00","closed_at":"2025-12-28T23:45:48.773948-05:00","close_reason":"Implemented and tested. View command now shows PR numbers, status icons (â—‹/â—/âœ“/âœ—), and PR URLs when PRs exist.","dependencies":[{"issue_id":"taspr-41a","depends_on_id":"taspr-1ni","type":"parent-child","created_at":"2025-12-25T14:30:03.44579-05:00","created_by":"daemon"},{"issue_id":"taspr-41a","depends_on_id":"taspr-5i6","type":"blocks","created_at":"2025-12-25T14:30:03.718564-05:00","created_by":"daemon"},{"issue_id":"taspr-41a","depends_on_id":"taspr-5i6","type":"depends-on","created_at":"2025-12-25T14:30:03.718564-05:00","created_by":"daemon"}]}
{"id":"taspr-45o","title":"Optional: Machine user for PR review integration tests","description":"## Goal\nEnable integration tests for PR approval/changes_requested scenarios that are currently skipped due to GitHub's self-review restriction.\n\n## Context\nGitHub doesn't allow users to approve or request changes on their own PRs. The `getPRReviewStatus` function is already tested via:\n- Unit tests for `determineReviewDecision` (all cases covered)\n- Integration tests for `none` and `review_required` states\n\nThe skipped tests (`approved`, `changes_requested`) require a second GitHub account to submit reviews.\n\n## Why This Is Optional\n- Unit tests already cover the logic\n- GitHub's branch protection will catch misconfigured repos in production\n- This is \"belt and suspenders\" testing\n\n## Setup Steps (Manual - ~10 min)\n1. Create a new GitHub account (e.g., `taspr-test-reviewer`)\n2. Add it as a collaborator to `happycollision/taspr-check` with write access\n3. Generate a PAT (classic) with `repo` scope from that account\n4. Store as `GITHUB_REVIEWER_TOKEN` env var (local) or CI secret\n\n## Code Changes (After Setup)\n1. Update `tests/integration/pr-status.test.ts`:\n   - Add helper to get reviewer token from env\n   - Use `gh api repos/{owner}/{repo}/pulls/{pr}/reviews` with `GH_TOKEN` override\n   - Unskip `approved` and `changes_requested` tests\n   - Skip gracefully if `GITHUB_REVIEWER_TOKEN` not set\n\n## Files to Modify\n- tests/integration/pr-status.test.ts\n\n## Acceptance Criteria\n- [ ] Tests run when GITHUB_REVIEWER_TOKEN is set\n- [ ] Tests skip gracefully when token is not set\n- [ ] Approved and changes_requested states are verified","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-31T13:22:35.957968-05:00","updated_at":"2025-12-31T13:22:35.957968-05:00"}
{"id":"taspr-4b6","title":"Dirty state detection","description":"## Goal\nBlock sync operations when there are uncommitted changes.\n\n## Background\nRebasing with uncommitted changes can cause problems:\n- Changes get lost\n- Conflicts are harder to resolve\n- State becomes confusing\n\ntaspr should detect and block this upfront with a clear message.\n\n## Implementation\n\n```typescript\n// src/git/status.ts\n\ninterface WorkingTreeStatus {\n  isDirty: boolean;\n  hasUnstagedChanges: boolean;\n  hasStagedChanges: boolean;\n  hasUntrackedFiles: boolean;\n}\n\nasync function getWorkingTreeStatus(): Promise\u003cWorkingTreeStatus\u003e {\n  // Check for any changes\n  const status = await $`git status --porcelain`.text();\n  \n  const lines = status.trim().split('\\n').filter(Boolean);\n  \n  return {\n    isDirty: lines.length \u003e 0,\n    hasUnstagedChanges: lines.some(l =\u003e l[1] !== ' '),\n    hasStagedChanges: lines.some(l =\u003e l[0] !== ' ' \u0026\u0026 l[0] !== '?'),\n    hasUntrackedFiles: lines.some(l =\u003e l.startsWith('??')),\n  };\n}\n\nasync function requireCleanWorkingTree(): Promise\u003cvoid\u003e {\n  const status = await getWorkingTreeStatus();\n  \n  if (status.hasStagedChanges || status.hasUnstagedChanges) {\n    throw new DirtyWorkingTreeError(status);\n  }\n  \n  // Note: Untracked files are okayâ€”they don't affect rebase\n}\n```\n\n### Error Message\n```\nâœ— Error: Cannot sync with uncommitted changes\n\n  You have:\n    â€¢ 2 staged changes\n    â€¢ 3 unstaged changes\n\n  Please commit or stash your changes first:\n    git stash        # Temporarily save changes\n    taspr sync       # Run sync\n    git stash pop    # Restore changes\n```\n\n## Usage in Sync\n\n```typescript\nasync function sync(options: SyncOptions) {\n  // First check: working tree must be clean\n  await requireCleanWorkingTree();\n  \n  // Now safe to proceed with rebase operations\n  ...\n}\n```\n\n## Testing\n1. Clean working tree â†’ passes\n2. Staged changes â†’ blocks\n3. Unstaged changes â†’ blocks\n4. Only untracked files â†’ passes (untracked don't affect rebase)\n\n## Files to Create\n- src/git/status.ts\n\n## Acceptance Criteria\n- [ ] Detects staged changes\n- [ ] Detects unstaged changes\n- [ ] Allows untracked files\n- [ ] Provides clear error message\n- [ ] Suggests git stash as workaround","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T14:25:46.906529-05:00","updated_at":"2025-12-26T21:12:09.239717-05:00","closed_at":"2025-12-26T21:12:09.239717-05:00","close_reason":"Implemented getWorkingTreeStatus and requireCleanWorkingTree in src/git/status.ts","dependencies":[{"issue_id":"taspr-4b6","depends_on_id":"taspr-7tr","type":"parent-child","created_at":"2025-12-25T14:25:50.62641-05:00","created_by":"daemon"}]}
{"id":"taspr-4xr","title":"Post-rebase sync (update all branches)","description":"## Goal\nAfter rebasing, update all affected PR branches.\n\n## Background\nAfter a rebase:\n- All commit hashes in the stack have changed\n- All remote branches point to old hashes\n- All branches need force-pushing\n\n## Implementation\n\n```typescript\n// src/core/sync.ts\n\nasync function syncAfterRebase(units: PRUnit[]): Promise\u003cvoid\u003e {\n  const config = await getBranchNameConfig();\n  \n  console.log('Updating PR branches...');\n  \n  let updated = 0;\n  \n  for (const unit of units) {\n    const branch = getBranchName(unit.id, config);\n    const localCommit = unit.commits[unit.commits.length - 1];\n    \n    // Force push regardless of whether we think it changed\n    // After rebase, everything has changed\n    await forcePushBranch(localCommit, branch);\n    updated++;\n    \n    console.log(\\`  âœ“ \\${branch}\\`);\n  }\n  \n  console.log(\\`\\\\nâœ“ Updated \\${updated} PR branch(es)\\`);\n}\n```\n\n### Full Sync Flow\n```typescript\nasync function sync(options: { open?: boolean }) {\n  // 1. Check for dirty state\n  await requireCleanWorkingTree();\n  \n  // 2. Check for ongoing conflict\n  if (await getConflictInfo()) {\n    // Exit with instructions\n  }\n  \n  // 3. Inject missing IDs\n  await injectMissingIds();\n  \n  // 4. Parse stack\n  const result = await parseStack();\n  \n  // 5. Rebase if behind\n  if (await isStackBehindMain()) {\n    const rebaseResult = await rebaseOntoMain();\n    if (!rebaseResult.success) {\n      // Conflict - exit\n    }\n    \n    // Re-parse after rebase (hashes changed)\n    result = await parseStack();\n  }\n  \n  // 6. Update branches\n  await syncAfterRebase(result.units);\n  \n  // 7. Create PRs if --open\n  if (options.open) {\n    await createMissingPRs(result.units);\n  }\n}\n```\n\n## Testing\n- After rebase, all branches updated\n- PR commits match local stack\n- Force push succeeds\n\n## Files to Modify\n- src/core/sync.ts\n- src/cli/commands/sync.ts\n\n## Acceptance Criteria\n- [ ] Updates all branches after rebase\n- [ ] Force pushes to overwrite old commits\n- [ ] Reports each updated branch\n- [ ] Handles partial failures gracefully","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-25T14:37:18.394819-05:00","updated_at":"2025-12-31T14:20:28.635035-05:00","closed_at":"2025-12-31T14:20:28.635035-05:00","close_reason":"Closed","dependencies":[{"issue_id":"taspr-4xr","depends_on_id":"taspr-a64","type":"parent-child","created_at":"2025-12-25T14:37:23.410645-05:00","created_by":"daemon"},{"issue_id":"taspr-4xr","depends_on_id":"taspr-ybr","type":"blocks","created_at":"2025-12-25T14:37:23.676459-05:00","created_by":"daemon"},{"issue_id":"taspr-4xr","depends_on_id":"taspr-ybr","type":"depends-on","created_at":"2025-12-25T14:37:23.676459-05:00","created_by":"daemon"}]}
{"id":"taspr-53z","title":"Install and configure oxformat","description":"Install oxformat (Oxc's fast JavaScript/TypeScript formatter) and configure it for the project. This includes adding the package, creating configuration files, and setting up npm scripts.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-26T01:04:41.62418-05:00","updated_at":"2025-12-26T01:37:47.487903-05:00","closed_at":"2025-12-26T01:37:47.487903-05:00","close_reason":"Installed oxfmt v0.20.0 and configured with default settings. Added format script to package.json."}
{"id":"taspr-578","title":"Group inherits PR identity when commits with existing PRs are grouped","description":"When grouping commits where one or more already have open PRs, the group should inherit the PR identity.\n\n## Behavior\n\n1. **Single PR exists**: Ask user if they want to:\n   - Adopt the existing PR (group inherits that ID)\n   - Close the PR and create new one for the group\n2. **Multiple PRs exist**: User must pick which one to keep, others get closed\n3. The group takes on the chosen PR's ID to preserve branch/PR identity\n\n## ID Management\n\n- IDs are internal state management, not user-facing identifiers\n- When a commit joins a group with an existing PR, it adopts that group's ID\n- When a commit leaves a group that inherited its ID, it gets a NEW ID\n- This is intentional \"magic\" - users shouldn't need to think about IDs\n\n## Implementation Notes\n\n- Add interactive prompt when grouping detects existing PRs\n- Rewrite commit trailers during group operation\n- Handle edge case: commit removed from group needs new ID","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-03T00:20:12.200488-05:00","updated_at":"2026-01-04T15:32:33.07197-05:00","closed_at":"2026-01-04T15:32:33.07197-05:00","close_reason":"Closed","dependencies":[{"issue_id":"taspr-578","depends_on_id":"taspr-ar8","type":"blocks","created_at":"2026-01-03T00:20:19.47021-05:00","created_by":"dondenton"}]}
{"id":"taspr-57g","title":"View command (local only)","description":"## Goal\nImplement the `taspr view` command to display stack structure in the terminal.\n\n## Background\nThis is the first user-facing command. It shows the current stack state based purely on local git dataâ€”no GitHub integration yet.\n\n## Output Format\n\n```\n$ taspr view\n\nStack: feature/auth (4 commits, 3 PRs)\n\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  â—‹ Add user model\n    â””â”€ a1b2c3d4\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  â—‹ Authentication feature [f7e8d9c0]\n    â”œâ”€ b2c3d4e5 Add login endpoint\n    â”œâ”€ c3d4e5f6 Add password validation  \n    â””â”€ d4e5f6a7 Add 2FA support\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  â—‹ Add admin dashboard\n    â””â”€ e5f6a7b8\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  â†“ origin/main\n```\n\n### Elements\n- **Header**: Branch name, commit count, PR count (PRUnits)\n- **Separator**: Horizontal line between PRUnits\n- **Status indicator**: `â—‹` for local-only (no PR). Later: `âœ“` merged, `â—` open, etc.\n- **Title**: Commit subject (single) or Group-Title (group)\n- **Group indicator**: `[group-id]` after title for groups\n- **Commits**: Tree structure showing commit IDs and subjects\n- **Footer**: Shows origin/main as the base\n\n## Implementation\n\n### Command Registration\n```typescript\n// src/cli/commands/view.ts\nimport { Command } from 'commander';\nimport { parseStack } from '../../core/stack';\nimport { formatStackView } from '../output';\n\nexport const viewCommand = new Command('view')\n  .description('Display status of current stack')\n  .action(async () =\u003e {\n    const result = await parseStack();\n    \n    if (!result.ok) {\n      // Show validation error\n      console.error(formatValidationError(result));\n      process.exit(1);\n    }\n    \n    console.log(formatStackView(result.units));\n  });\n```\n\n### Output Formatting\n```typescript\n// src/cli/output.ts\nexport function formatStackView(units: PRUnit[]): string {\n  // Build formatted output string\n}\n\nexport function formatValidationError(error: StackParseError): string {\n  // Format error with actionable message\n}\n```\n\n## Validation Error Display\n\nWhen groups are malformed, show helpful errors:\n\n```\n$ taspr view\n\nâœ— Error: Unclosed group starting at commit b2c3d4e5\n\n  Group f7e8d9c0 (\"Auth feature\") has Taspr-Group-Start but no \n  matching Taspr-Group-End was found in subsequent commits.\n  \n  To fix, either:\n    1. Run `taspr group edit` to set the end boundary\n    2. Run `taspr group dissolve` to remove the incomplete group\n```\n\n## Edge Cases\n1. **Empty stack**: \"No commits ahead of origin/main\"\n2. **No origin/main**: Error with setup instructions\n3. **All commits in one group**: Show single PRUnit\n4. **Commits without IDs**: Show hash only, indicate sync needed\n\n## Testing Strategy\n1. Mock stack data and verify output formatting\n2. Test error formatting for various validation errors\n3. Integration test with real git repo\n\n## Files to Create/Modify\n- src/cli/commands/view.ts (create)\n- src/cli/output.ts (create) - Output formatting utilities\n- src/cli/index.ts (modify) - Register view command\n\n## Acceptance Criteria\n- [ ] Shows stack with all PRUnits\n- [ ] Correctly formats singles and groups\n- [ ] Shows validation errors clearly\n- [ ] Handles empty stack gracefully\n- [ ] Tree structure for group commits\n- [ ] Exit code 0 on success, 1 on validation error","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T14:23:56.483682-05:00","updated_at":"2025-12-26T01:28:05.134007-05:00","closed_at":"2025-12-26T01:28:05.134007-05:00","close_reason":"Implemented view command with formatStackView, formatValidationError, and getStackCommitsWithTrailers","dependencies":[{"issue_id":"taspr-57g","depends_on_id":"taspr-h87","type":"parent-child","created_at":"2025-12-25T14:24:00.129571-05:00","created_by":"daemon"},{"issue_id":"taspr-57g","depends_on_id":"taspr-b7d","type":"blocks","created_at":"2025-12-25T14:24:00.407869-05:00","created_by":"daemon"},{"issue_id":"taspr-57g","depends_on_id":"taspr-b7d","type":"depends-on","created_at":"2025-12-25T14:24:00.407869-05:00","created_by":"daemon"}]}
{"id":"taspr-5i6","title":"PR lookup by branch","description":"## Goal\nFind existing PRs for branches to avoid creating duplicates.\n\n## Implementation\n\n```typescript\n// src/github/pr.ts\n\ninterface PRInfo {\n  number: number;\n  url: string;\n  state: 'open' | 'closed' | 'merged';\n  title: string;\n}\n\nasync function findPRByBranch(branchName: string): Promise\u003cPRInfo | null\u003e {\n  const result = await $\\`gh pr list --head ${branchName} --json number,url,state,title\\`.nothrow();\n  \n  if (result.exitCode !== 0) {\n    return null;\n  }\n  \n  const prs = JSON.parse(result.stdout.toString());\n  \n  // Return first open PR (should only be one)\n  const openPR = prs.find((pr: PRInfo) =\u003e pr.state === 'open');\n  return openPR || null;\n}\n```\n\n### Usage in Sync\nBefore creating a PR, check if one exists:\n\n```typescript\nasync function ensurePRExists(unit: PRUnit, headBranch: string, baseBranch: string): Promise\u003cPRInfo\u003e {\n  // Check for existing PR\n  const existing = await findPRByBranch(headBranch);\n  if (existing) {\n    return existing;\n  }\n  \n  // Create new PR\n  return await createPR({\n    title: unit.title,\n    head: headBranch,\n    base: baseBranch,\n  });\n}\n```\n\n### Enriching PRUnits\nAfter sync, enrich PRUnits with PR info:\n\n```typescript\ninterface EnrichedPRUnit extends PRUnit {\n  prNumber?: number;\n  prUrl?: string;\n  prState?: 'open' | 'closed' | 'merged';\n}\n\nasync function enrichPRUnitsWithPRInfo(\n  units: PRUnit[], \n  branches: Map\u003cstring, string\u003e\n): Promise\u003cEnrichedPRUnit[]\u003e {\n  return Promise.all(units.map(async unit =\u003e {\n    const branch = branches.get(unit.id);\n    if (!branch) return unit;\n    \n    const pr = await findPRByBranch(branch);\n    return {\n      ...unit,\n      prNumber: pr?.number,\n      prUrl: pr?.url,\n      prState: pr?.state,\n    };\n  }));\n}\n```\n\n## Edge Cases\n1. **No PR for branch**: Return null\n2. **Closed PR for branch**: Return it (may want to reopen or create new)\n3. **Multiple PRs for branch**: Return first open one\n\n## Testing\n- Branch with open PR â†’ returns PR info\n- Branch with closed PR â†’ returns closed PR info\n- Branch with no PR â†’ returns null\n\n## Files to Modify\n- src/github/pr.ts\n\n## Acceptance Criteria\n- [ ] Finds open PRs by branch name\n- [ ] Returns null for branches without PRs\n- [ ] Returns PR info including state\n- [ ] Handles closed/merged PRs","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T14:27:54.485452-05:00","updated_at":"2025-12-26T23:29:21.524548-05:00","closed_at":"2025-12-26T23:29:21.524548-05:00","close_reason":"Implemented and tested","dependencies":[{"issue_id":"taspr-5i6","depends_on_id":"taspr-osw","type":"parent-child","created_at":"2025-12-25T14:27:58.424193-05:00","created_by":"daemon"},{"issue_id":"taspr-5i6","depends_on_id":"taspr-bvy","type":"blocks","created_at":"2025-12-25T14:27:58.701-05:00","created_by":"daemon"},{"issue_id":"taspr-5i6","depends_on_id":"taspr-bvy","type":"depends-on","created_at":"2025-12-25T14:27:58.701-05:00","created_by":"daemon"}]}
{"id":"taspr-5u7","title":"Conflict prediction for group TUI","description":"## Goal\nImplement precise conflict prediction for the group TUI, warning users when reordering commits would cause merge conflicts.\n\n## Context\nThis is part of Epic 7: Group Management. When users reorder commits in the TUI, we need to predict whether the reorder would cause a conflict BEFORE they commit to it. This uses a hybrid approach: fast file-level check first, then precise merge simulation if files overlap.\n\n## UX Design\nWhen moving a commit past another that would conflict:\n\n```\nÂ» A e5f6a7b8  Add login endpoint       â† MOVING\n  A c9d0e1f2  Fix login bug            âœ— CONFLICT (auth.ts:15-22)\n\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâœ— Moving past \"Fix login bug\" will conflict in auth.ts (lines 15-22)\n```\n\nStatus indicators:\n- âœ“ clean - no file overlap, safe to move\n- âš ï¸ warning - file overlap but merge would succeed (same file, different lines)\n- âœ— conflict - actual merge conflict detected\n\n## Implementation\n\n### Hybrid Approach\n```typescript\ninterface ConflictResult {\n  status: 'clean' | 'warning' | 'conflict';\n  files?: string[];           // Overlapping files\n  conflictLines?: string[];   // e.g., \"auth.ts:15-22\"\n}\n```\n\n### Step 1: Fast File Overlap Check\n```typescript\n// Get files modified by a commit\nasync function getCommitFiles(hash: string): Promise\u003cstring[]\u003e {\n  const result = await $`git diff-tree --no-commit-id --name-only -r ${hash}`.text();\n  return result.trim().split('\\n').filter(Boolean);\n}\n\n// Check if two commits modify overlapping files\nasync function checkFileOverlap(commitA: string, commitB: string): Promise\u003cstring[]\u003e {\n  const filesA = await getCommitFiles(commitA);\n  const filesB = await getCommitFiles(commitB);\n  const setA = new Set(filesA);\n  return filesB.filter(f =\u003e setA.has(f));\n}\n```\n\n### Step 2: Precise Merge Simulation (only if files overlap)\n```typescript\n// Use git merge-tree to simulate actual merge\nasync function simulateMerge(\n  base: string, \n  commitA: string, \n  commitB: string\n): Promise\u003cConflictResult\u003e {\n  // git merge-tree simulates merge without touching working tree\n  // Exit code 0 with CONFLICT in output = conflicts exist\n  const result = await $`git merge-tree ${base} ${commitA} ${commitB}`\n    .nothrow()\n    .text();\n  \n  if (result.includes('CONFLICT')) {\n    // Parse conflict details from output\n    const conflicts = parseConflictOutput(result);\n    return { \n      status: 'conflict', \n      files: conflicts.files,\n      conflictLines: conflicts.lines \n    };\n  }\n  \n  return { status: 'warning', files: overlappingFiles };\n}\n```\n\n### Caching\nCache file lists during TUI session to avoid repeated git calls:\n```typescript\nconst fileCache = new Map\u003cstring, string[]\u003e();\n\nasync function getCommitFilesCached(hash: string): Promise\u003cstring[]\u003e {\n  if (!fileCache.has(hash)) {\n    fileCache.set(hash, await getCommitFiles(hash));\n  }\n  return fileCache.get(hash)!;\n}\n```\n\n## Git Commands Used\n- `git diff-tree --no-commit-id --name-only -r \u003ccommit\u003e` - get files modified (fast)\n- `git merge-tree \u003cbase\u003e \u003ccommit1\u003e \u003ccommit2\u003e` - simulate merge (precise, non-destructive)\n\n## Files to Create\n- src/git/conflict-predict.ts\n\n## Testing\n- Unit tests for file overlap detection\n- Unit tests for merge simulation parsing\n- Integration tests with actual conflicting commits\n- Test caching behavior\n\n## Acceptance Criteria\n- [ ] `getCommitFiles()` returns list of files modified by commit\n- [ ] `checkFileOverlap()` detects overlapping files between commits\n- [ ] `simulateMerge()` uses git merge-tree to detect actual conflicts\n- [ ] Results are cached during TUI session\n- [ ] Conflict lines are extracted from merge-tree output\n- [ ] Performance is acceptable (\u003c 100ms for typical checks)","notes":"## Testing Workflow\nAfter completing implementation:\n1. Run `bun run build` to build the CLI\n2. Run `bun test --no-coverage` to verify all tests pass\n3. Tell the user to run `bun run scenario` and select one of these scenarios for manual testing:\n   - **conflictScenario** - Setup that will conflict on rebase (best for testing conflict prediction)\n   - **multiCommitStack** - 3 commits for testing file overlap detection\n\n## Scenario Usage\nThe `bun run scenario` command spawns a shell in a temp git repo with `taspr` in PATH. Use this to manually verify conflict prediction works correctly. After testing, type `exit` to clean up.\n\n## New Scenarios Needed\nConsider adding to `src/scenario/definitions.ts`:\n- **conflictingReorder** - A scenario where two commits modify the same file in ways that would conflict if reordered","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-01T22:47:55.226468-05:00","updated_at":"2026-01-02T10:24:30.585297-05:00","closed_at":"2026-01-02T10:24:30.585297-05:00","close_reason":"Closed","dependencies":[{"issue_id":"taspr-5u7","depends_on_id":"taspr-7mu","type":"parent-child","created_at":"2026-01-01T22:48:51.646554-05:00","created_by":"daemon"}]}
{"id":"taspr-5vz","title":"Evaluate PR inheritance behavior","description":"Test the new PR inheritance features:\n1. Group commits with existing PRs - verify adoption prompt works\n2. Dissolve group with open PR - verify inheritance prompt works\n3. Dissolve group without PR - verify donor keeps ID\n4. Non-interactive mode - verify --inherit and --no-inherit flags work\n5. Verify superseded PRs are closed correctly","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-04T15:32:06.363871-05:00","updated_at":"2026-01-04T15:32:06.363871-05:00"}
{"id":"taspr-6le","title":"Epic 5: Land PRs (Merge to Main)","description":"## Goal\nMerge the bottom PR to main, completing the PR lifecycle.\n\n## Background\n\n### Landing Strategy\nWhen a PR is ready (approved, CI passing), land it by merging to main. The merge strategy depends on repo settings:\n- Fast-forward (if possible)\n- Squash merge\n- Merge commit\n\ntaspr uses GitHub's merge API, which respects repo settings.\n\n### Stack Behavior After Landing\nWhen the bottom PR merges:\n1. GitHub automatically retargets child PRs to new base (main)\n2. No action needed from taspr for retargeting\n3. Next `taspr sync` will clean up merged PR from local tracking\n\n### What \"Ready\" Means\nA PR is ready to land when:\n- Approved by required reviewers\n- CI checks passing\n- No merge conflicts\n\n## Workflow\n\n1. User runs `taspr land`\n2. Find bottom unmerged PR\n3. Check if it's ready (API call)\n4. Merge via GitHub API\n5. Report success\n\n## Deliverable\nRunning `taspr land` merges the bottom PR. GitHub handles retargeting child PRs.\n\n## Dependencies\n- Epic 4 must be complete (PRs exist and are synced)\n\n## Commands\n\n### taspr land\nMerge the bottom ready PR:\n```\n$ taspr land\n\nMerging PR #142 (Add user model)...\nâœ“ Merged PR #142 to main\n```\n\n### taspr land --all\nMerge all consecutive ready PRs:\n```\n$ taspr land --all\n\nMerging PR #142 (Add user model)...\nâœ“ Merged PR #142 to main\n\nMerging PR #143 (Add auth)...\nâœ“ Merged PR #143 to main\n\nStopping at PR #144 (not ready: CI failing)\n```\n\n## Testable Outcome\nLanding a PR merges it to main. GitHub retargets child PRs automatically.","status":"closed","priority":1,"issue_type":"epic","created_at":"2025-12-25T14:30:38.632223-05:00","updated_at":"2025-12-31T10:55:35.747715-05:00","closed_at":"2025-12-31T10:55:35.747715-05:00","close_reason":"All child tasks completed: PR merge API, land command, land --all flag, and merged PR detection/cleanup are all implemented.","dependencies":[{"issue_id":"taspr-6le","depends_on_id":"taspr-1ni","type":"blocks","created_at":"2025-12-25T14:30:43.99553-05:00","created_by":"daemon"},{"issue_id":"taspr-6le","depends_on_id":"taspr-1ni","type":"depends-on","created_at":"2025-12-25T14:30:43.99553-05:00","created_by":"daemon"}]}
{"id":"taspr-6nw","title":"Git log parsing","description":"## Goal\nRead commits between HEAD and the merge-base with origin/main, extracting all relevant information.\n\n## Background\ntaspr needs to understand the stack of commits that will become PRs. The stack is:\n- All commits from HEAD back to (but not including) the merge-base with origin/main\n- Ordered from oldest to newest (bottom of stack = first to merge)\n\n## Implementation\n\n### Git Commands Needed\n```bash\n# Find merge-base\ngit merge-base HEAD origin/main\n\n# Get commits in stack (oldest first)\ngit log --reverse --format=\"%H%x00%s%x00%B\" \u003cmerge-base\u003e..HEAD\n```\n\n### Output Format\nUse null-byte separators for reliable parsing:\n- `%H` - commit hash\n- `%s` - subject line\n- `%B` - full body (includes subject)\n\n### Function Signature\n```typescript\ninterface CommitInfo {\n  hash: string;\n  subject: string;\n  body: string;\n}\n\nasync function getStackCommits(): Promise\u003cCommitInfo[]\u003e\n```\n\n### Edge Cases\n1. **No commits ahead of main**: Return empty array\n2. **No origin/main**: Error with helpful message\n3. **Detached HEAD**: Should still work\n4. **Merge commits in stack**: Include them (user's choice to have them)\n\n## Bun Shell Usage\n```typescript\nimport { $ } from \"bun\";\n\nconst mergeBase = await $`git merge-base HEAD origin/main`.text();\nconst log = await $`git log --reverse --format=\"%H%x00%s%x00%B%x00\" ${mergeBase.trim()}..HEAD`.text();\n```\n\n## Testing Strategy\nCreate a temporary git repository with known commits and verify parsing:\n1. Create temp dir\n2. git init\n3. Add commits with known subjects/bodies\n4. Call getStackCommits()\n5. Assert on results\n\n## Files to Create/Modify\n- src/git/commands.ts (create) - Git command wrapper with getStackCommits()\n\n## Acceptance Criteria\n- [ ] Returns commits in oldest-to-newest order\n- [ ] Correctly parses hash, subject, body\n- [ ] Handles empty stack (no commits ahead)\n- [ ] Handles repos without origin/main with clear error\n- [ ] Has tests with real git repos in temp directories","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T14:22:32.243959-05:00","updated_at":"2025-12-26T00:42:13.283588-05:00","closed_at":"2025-12-26T00:42:13.283588-05:00","close_reason":"Closed","dependencies":[{"issue_id":"taspr-6nw","depends_on_id":"taspr-h87","type":"parent-child","created_at":"2025-12-25T14:22:35.916747-05:00","created_by":"daemon"},{"issue_id":"taspr-6nw","depends_on_id":"taspr-0lj","type":"blocks","created_at":"2025-12-25T14:22:36.196173-05:00","created_by":"daemon"},{"issue_id":"taspr-6nw","depends_on_id":"taspr-0lj","type":"depends-on","created_at":"2025-12-25T14:22:36.196173-05:00","created_by":"daemon"}]}
{"id":"taspr-6up","title":"Move group PR titles from commit trailers to git ref storage","description":"## Summary\n\nDecouple PR titles from commit trailers by storing group titles in `refs/taspr/\u003cuser\u003e/group-titles` (a JSON blob) instead of the `Taspr-Group-Title` trailer. The `Taspr-Group` trailer remains for identifying which commits belong together.\n\n## Key Benefits\n- PR titles can be changed independently of commits\n- Syncable across machines via `taspr sync` (auto push/fetch of user's ref)\n- Per-user namespace avoids conflicts between collaborators\n- Once a PR is opened on GitHub, local changes won't overwrite it\n\n## Implementation Plan\n\n### 1. Create new module: `src/git/group-titles.ts`\n\nNew file for reading/writing group titles to `refs/taspr/\u003cuser\u003e/group-titles`.\n\nKey functions:\n- `getGroupTitlesRef()` - Returns refs/taspr/\u003cgithub-username\u003e/group-titles\n- `readGroupTitles()` / `writeGroupTitles()` - Read/write JSON blob\n- `getGroupTitle()` / `setGroupTitle()` / `deleteGroupTitle()` - Per-group operations\n- `pushGroupTitles()` / `fetchGroupTitles()` - Sync with remote\n\nUser identification via `gh api user --jq .login`.\n\nStorage mechanism:\n```bash\n# Write\necho '{\"group-abc\": \"PR Title\"}' | git hash-object -w --stdin\ngit update-ref refs/taspr/\u003cuser\u003e/group-titles \u003csha\u003e\n\n# Read\ngit cat-file blob refs/taspr/\u003cuser\u003e/group-titles\n\n# Sync\ngit push origin refs/taspr/\u003cuser\u003e/group-titles\ngit fetch origin refs/taspr/\u003cuser\u003e/group-titles:refs/taspr/\u003cuser\u003e/group-titles\n```\n\n### 2. Update `src/types.ts`\nRemove `inconsistent-group-title` error variant from StackParseResult.\n\n### 3. Update `src/git/trailers.ts`\nRemove `Taspr-Group-Title` from CommitTrailers interface.\n\n### 4. Update `src/core/stack.ts`\n- `detectPRUnits()`: Add titles parameter\n- `parseStack()`: Remove title inconsistency validation\n\n### 5. Update `src/git/group-rebase.ts`\n- `applyGroupSpec()`: Stop writing title trailer, use setGroupTitle()\n- `dissolveGroup()`: Add deleteGroupTitle() call\n- `updateGroupTitle()`: Simplify to just setGroupTitle()\n- Purge orphaned titles when groups are merged\n\n### 6. Update `src/tui/group-editor.ts`\nLoad/save titles from ref storage instead of trailers.\n\n### 7. Update `src/cli/commands/sync.ts`\n- fetchGroupTitles() at start\n- pushGroupTitles() at end\n- Pass titles to parseStack()\n\n### 8. Update `src/cli/commands/group.ts`\nRemove inconsistent-title error handling and repairInconsistentTitles().\n\n### 9. Update tests\nRemove inconsistent-title test cases, add group-titles.test.ts.\n\n## Files to Modify\n- src/git/group-titles.ts (NEW)\n- src/types.ts\n- src/git/trailers.ts\n- src/core/stack.ts\n- src/git/group-rebase.ts\n- src/tui/group-editor.ts\n- src/cli/commands/sync.ts\n- src/cli/commands/group.ts\n\n## Edge Cases\n- Missing ref: return empty object\n- Corrupted JSON: log warning, return empty object\n- Title not found: fall back to first commit's subject\n- Sync conflicts: user resolves manually\n- Orphaned titles: purge when groups merged/dissolved","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-04T00:16:47.230504-05:00","updated_at":"2026-01-04T14:04:08.856076-05:00","closed_at":"2026-01-04T14:04:08.856076-05:00","close_reason":"Closed"}
{"id":"taspr-71a","title":"Sync command with PR creation (--open flag)","description":"## Goal\nExtend the sync command to create PRs with the --open flag.\n\n## Current State (from Epic 2)\n`taspr sync` currently:\n- Checks for dirty working tree\n- Adds Taspr-Commit-Id to commits without them\n\n## New Behavior\n`taspr sync --open` also:\n- Pushes branches for all PRUnits\n- Creates PRs for units that don't have them\n- Reports created/existing PRs\n\n## Implementation\n\n```typescript\n// src/cli/commands/sync.ts\n\nexport const syncCommand = new Command('sync')\n  .description('Sync stack state with GitHub')\n  .option('--open', 'Create PRs for units without them')\n  .action(async (options) =\u003e {\n    await requireCleanWorkingTree();\n    \n    // Parse and validate stack\n    const result = await parseStack();\n    if (!result.ok) {\n      console.error(formatValidationError(result));\n      process.exit(1);\n    }\n    \n    // Inject missing IDs\n    const idResult = await injectMissingIds();\n    if (idResult.modifiedCommits.length \u003e 0) {\n      console.log(\\`âœ“ Added IDs to \\${idResult.modifiedCommits.length} commit(s)\\`);\n      // Re-parse after rebase\n      result = await parseStack();\n    }\n    \n    if (!options.open) {\n      console.log('âœ“ Stack synced (use --open to create PRs)');\n      return;\n    }\n    \n    // Push branches and create PRs\n    const config = await getBranchNameConfig();\n    const defaultBranch = await getDefaultBranch();\n    \n    let baseBranch = defaultBranch;\n    const created: PRInfo[] = [];\n    const existing: PRInfo[] = [];\n    \n    for (const unit of result.units) {\n      const headBranch = getBranchName(unit.id, config);\n      \n      // Push branch\n      await pushBranch(unit.commits[unit.commits.length - 1], headBranch);\n      \n      // Check for existing PR\n      const existingPR = await findPRByBranch(headBranch);\n      \n      if (existingPR) {\n        existing.push(existingPR);\n      } else {\n        const pr = await createPR({\n          title: unit.title,\n          head: headBranch,\n          base: baseBranch,\n        });\n        created.push(pr);\n      }\n      \n      baseBranch = headBranch;\n    }\n    \n    // Report results\n    if (created.length \u003e 0) {\n      console.log(\\`\\\\nâœ“ Created \\${created.length} PR(s):\\`);\n      for (const pr of created) {\n        console.log(\\`  #\\${pr.number} \\${pr.url}\\`);\n      }\n    }\n    \n    if (existing.length \u003e 0) {\n      console.log(\\`\\\\nâœ“ \\${existing.length} PR(s) already exist\\`);\n    }\n  });\n```\n\n## Output\n\n### First sync with --open\n```\n$ taspr sync --open\n\nâœ“ Added IDs to 3 commit(s)\nâœ“ Pushed 3 branch(es)\n\nâœ“ Created 3 PR(s):\n  #142 https://github.com/org/repo/pull/142\n  #143 https://github.com/org/repo/pull/143\n  #144 https://github.com/org/repo/pull/144\n```\n\n### Subsequent sync with --open (PRs exist)\n```\n$ taspr sync --open\n\nâœ“ All commits have IDs\nâœ“ Pushed 3 branch(es)\nâœ“ 3 PR(s) already exist\n```\n\n### Sync without --open\n```\n$ taspr sync\n\nâœ“ All commits have IDs\nâœ“ Stack synced (use --open to create PRs)\n```\n\n## Testing\n1. Sync --open creates PRs\n2. Sync --open with existing PRs doesn't duplicate\n3. Sync without --open doesn't touch GitHub\n4. Integration test with real GitHub (or mocked)\n\n## Files to Modify\n- src/cli/commands/sync.ts\n\n## Acceptance Criteria\n- [ ] --open flag creates PRs for units without them\n- [ ] Doesn't create duplicate PRs\n- [ ] Reports created vs existing PRs\n- [ ] Without --open, no GitHub interaction\n- [ ] PRs form correct stack structure","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T14:28:34.89184-05:00","updated_at":"2025-12-26T23:29:21.531433-05:00","closed_at":"2025-12-26T23:29:21.531433-05:00","close_reason":"Implemented and tested","dependencies":[{"issue_id":"taspr-71a","depends_on_id":"taspr-osw","type":"parent-child","created_at":"2025-12-25T14:28:38.862039-05:00","created_by":"daemon"},{"issue_id":"taspr-71a","depends_on_id":"taspr-de7","type":"blocks","created_at":"2025-12-25T14:28:39.14537-05:00","created_by":"daemon"},{"issue_id":"taspr-71a","depends_on_id":"taspr-de7","type":"depends-on","created_at":"2025-12-25T14:28:39.14537-05:00","created_by":"daemon"},{"issue_id":"taspr-71a","depends_on_id":"taspr-5i6","type":"blocks","created_at":"2025-12-25T14:28:39.430517-05:00","created_by":"daemon"},{"issue_id":"taspr-71a","depends_on_id":"taspr-5i6","type":"depends-on","created_at":"2025-12-25T14:28:39.430517-05:00","created_by":"daemon"}]}
{"id":"taspr-77v","title":"gh CLI dependency checks","description":"## Goal\nDetect when `gh` CLI is missing or not authenticated, and provide clear guidance to users.\n\n## Why gh CLI\ntaspr delegates all GitHub API operations to the `gh` CLI rather than implementing OAuth or token management. This:\n- Leverages existing user authentication\n- Avoids storing tokens\n- Uses well-tested GitHub API wrapper\n- Simplifies taspr\\'s scope\n\n## Checks Required\n\n### 1. gh Installation Check\n```typescript\nasync function checkGhInstalled(): Promise\u003cboolean\u003e {\n  try {\n    const result = await $`gh --version`.quiet();\n    return result.exitCode === 0;\n  } catch {\n    return false;\n  }\n}\n```\n\n**Error when missing:**\n```\nError: GitHub CLI (gh) is required but not installed\n\ntaspr uses the GitHub CLI for all GitHub operations.\n\nTo install:\n  macOS:   brew install gh\n  Linux:   https://github.com/cli/cli/blob/trunk/docs/install_linux.md\n  Windows: winget install GitHub.cli\n\nAfter installing, authenticate with: gh auth login\n```\n\n### 2. gh Authentication Check\n```typescript\nasync function checkGhAuthenticated(): Promise\u003cboolean\u003e {\n  try {\n    const result = await $`gh auth status`.quiet();\n    return result.exitCode === 0;\n  } catch {\n    return false;\n  }\n}\n```\n\n**Error when not authenticated:**\n```\nError: Not authenticated with GitHub\n\ntaspr requires GitHub authentication via the gh CLI.\n\nTo authenticate:\n  gh auth login\n\nThen follow the prompts to complete authentication.\n```\n\n### 3. Repository Access Check\n```typescript\nasync function checkRepoAccess(): Promise\u003cboolean\u003e {\n  try {\n    // Try to get repo info - will fail if no access\n    const result = await $`gh repo view --json name`.quiet();\n    return result.exitCode === 0;\n  } catch {\n    return false;\n  }\n}\n```\n\n**Error when no access:**\n```\nError: Cannot access this repository via GitHub\n\nThis could mean:\n  - The repository doesn\\'t have a GitHub remote\n  - You don\\'t have access to this repository\n  - The repository doesn\\'t exist on GitHub\n\nCheck your git remote: git remote -v\n```\n\n## When to Check\n\n### On Every Command That Needs GitHub\n- `taspr sync` (when creating/updating PRs)\n- `taspr land`\n- `taspr view` (when fetching PR status)\n\n### Check Order\n1. gh installed?\n2. gh authenticated?\n3. Repository accessible?\n\nStop at first failure with appropriate message.\n\n## Implementation\n\n### Lazy Checking\n```typescript\n// src/github/api.ts\nlet ghChecked = false;\n\nexport async function ensureGhReady(): Promise\u003cvoid\u003e {\n  if (ghChecked) return;\n  \n  if (!await checkGhInstalled()) {\n    throw new TasprError(\n      'GitHub CLI (gh) is required but not installed',\n      'Install from https://cli.github.com then run: gh auth login'\n    );\n  }\n  \n  if (!await checkGhAuthenticated()) {\n    throw new TasprError(\n      'Not authenticated with GitHub',\n      'Run: gh auth login'\n    );\n  }\n  \n  ghChecked = true;\n}\n```\n\n### Call Before GitHub Operations\n```typescript\n// In any command using GitHub\nawait ensureGhReady();\nconst pr = await createPR(...);\n```\n\n## Testing\n- Test with gh not in PATH\n- Test with gh installed but not authenticated (`gh auth logout`)\n- Test with authenticated but no repo access\n- Verify error messages are helpful\n\n## Acceptance Criteria\n- [ ] Checks run before any GitHub API call\n- [ ] Clear error when gh not installed\n- [ ] Clear error when gh not authenticated\n- [ ] Clear error when repo not accessible\n- [ ] Checks are cached (don\\'t repeat every call)\n- [ ] Installation instructions cover macOS, Linux, Windows","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-25T14:49:31.737179-05:00","updated_at":"2025-12-25T14:49:31.737179-05:00","dependencies":[{"issue_id":"taspr-77v","depends_on_id":"taspr-8iv","type":"parent-child","created_at":"2025-12-25T15:01:36.787108-05:00","created_by":"daemon"}]}
{"id":"taspr-7h3","title":"Rebase orchestration for ID injection","description":"## Goal\nImplement the rebase logic to add Taspr-Commit-Id trailers to multiple commits in a stack.\n\n## Background\nWhen commits don't have IDs, we need to add them via rebase. This is non-trivial because:\n- Multiple commits may need IDs\n- We want to preserve existing IDs\n- We need to handle the rebase cleanly\n\n## Approach: GIT_SEQUENCE_EDITOR + exec\n\n### Option 1: Rebase with --exec\n```bash\ngit rebase -i --exec './add-id-if-missing.sh' \u003cmerge-base\u003e\n```\n\nThe script checks each commit and adds ID only if missing:\n```bash\n#!/bin/bash\nif ! git log -1 --format=%B | grep -q \"^Taspr-Commit-Id:\"; then\n  # Add ID\n  NEW_MSG=$(git log -1 --format=%B | git interpret-trailers --trailer \"Taspr-Commit-Id: $(openssl rand -hex 4)\")\n  git commit --amend --no-edit -m \"$NEW_MSG\"\nfi\n```\n\n### Option 2: Programmatic Rebase\nMore control but more complex:\n1. Generate todo list manually\n2. For each commit needing ID, mark as \"edit\"\n3. Use GIT_SEQUENCE_EDITOR to inject todo\n4. Handle each \"edit\" stop to add trailer\n\n### Recommended: Option 1\nSimpler and handles edge cases well. The --exec runs after each pick.\n\n## Implementation\n\n```typescript\n// src/core/sync.ts\n\nasync function injectMissingIds(): Promise\u003c{ modifiedCommits: string[] }\u003e {\n  const commits = await getStackCommits();\n  \n  // Find commits without IDs\n  const needsId = commits.filter(c =\u003e !c.trailers['Taspr-Commit-Id']);\n  \n  if (needsId.length === 0) {\n    return { modifiedCommits: [] };\n  }\n  \n  // Create temp script for --exec\n  const script = createIdInjectionScript();\n  await writeFile(scriptPath, script);\n  await chmod(scriptPath, '755');\n  \n  // Run rebase\n  const mergeBase = await getMergeBase();\n  await $`git rebase -i --exec ${scriptPath} ${mergeBase}`;\n  \n  // Clean up\n  await unlink(scriptPath);\n  \n  return { modifiedCommits: needsId.map(c =\u003e c.hash) };\n}\n```\n\n## Challenges\n\n### Non-interactive rebase\nWe want this to run without user intervention. Using `--exec` with a script achieves thisâ€”no editor opens.\n\n### Preserving existing IDs\nThe script only adds ID if missing, so existing IDs are preserved.\n\n### Rebase conflicts\nIf there's a conflict, the rebase stops. This is handled by a separate task in Epic 8.\n\n## Testing\n1. Stack with no IDs â†’ all get IDs\n2. Stack with some IDs â†’ only missing ones get IDs\n3. Stack with all IDs â†’ no rebase happens (no-op)\n4. Verify IDs survive subsequent rebases\n\n## Files to Create/Modify\n- src/core/sync.ts (create)\n- src/git/rebase.ts (create) - Rebase utilities\n\n## Acceptance Criteria\n- [ ] Adds IDs to commits missing them\n- [ ] Preserves existing IDs\n- [ ] No-op if all commits have IDs\n- [ ] Works without user interaction\n- [ ] Has integration tests with real git repos","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T14:25:29.162547-05:00","updated_at":"2025-12-26T21:25:42.040572-05:00","closed_at":"2025-12-26T21:25:42.040572-05:00","close_reason":"Implemented injectMissingIds in src/git/rebase.ts with 9 integration tests","dependencies":[{"issue_id":"taspr-7h3","depends_on_id":"taspr-7tr","type":"parent-child","created_at":"2025-12-25T14:25:33.539927-05:00","created_by":"daemon"},{"issue_id":"taspr-7h3","depends_on_id":"taspr-fwm","type":"blocks","created_at":"2025-12-25T14:25:33.82023-05:00","created_by":"daemon"},{"issue_id":"taspr-7h3","depends_on_id":"taspr-fwm","type":"depends-on","created_at":"2025-12-25T14:25:33.82023-05:00","created_by":"daemon"}]}
{"id":"taspr-7mu","title":"Epic 7: Group Management","description":"## Goal\nInteractive creation and management of commit groups (multi-commit PRs) via a unified TUI.\n\n## Background\n\n### Groups\nBy default, each commit becomes its own PR. Groups let you bundle multiple commits into a single PR.\n\nGroups are defined by trailers:\n- `Taspr-Group-Start: \u003cgroup-id\u003e` on first commit\n- `Taspr-Group-Title: \u003ctitle\u003e` on first commit (PR title)\n- `Taspr-Group-End: \u003cgroup-id\u003e` on last commit\n\n### Use Cases\n- Related changes that should be reviewed together\n- Work-in-progress commits that will be squashed\n- Logical feature that spans multiple commits\n\n## Revised Plan (January 2026)\n\nThe original plan for separate `group create/edit/dissolve` commands has been replaced with a **unified interactive TUI**.\n\n### taspr group\nLaunches a full-screen terminal UI that allows:\n- **Reordering commits** via move mode (Space to enter, Up/Down to swap)\n- **Assigning groups** via Left/Right arrows (cycles through A, B, C, ... Z, ungrouped)\n- **Conflict prediction** warns when moves would cause merge conflicts\n- **Single-commit groups** are allowed\n\nControls:\n- Up/Down: navigate (normal) / swap position (move mode)\n- Space: toggle move mode\n- Left/Right: cycle group assignment\n- Enter: confirm â†’ name groups â†’ rebase\n- Esc: cancel\n\n### taspr group dissolve\nSimple command to remove a group's trailers and break it back into individual commits.\n\n## Deliverables\n1. **Unified group TUI** (taspr-mpr) - main interactive interface\n2. **Conflict prediction** (taspr-5u7) - hybrid file-overlap + git merge-tree\n3. **Group rebase logic** (taspr-d55) - reordering and trailer injection\n4. **Group dissolve** (taspr-m80) - remove group trailers\n5. **Sync validation** (taspr-gp1) - block sync on invalid groups\n\n## Dependencies\n- Epic 2 must be complete (commits have IDs)\n\n## Validation\nGroups must not overlap and must be closed (Start has matching End).\n\n## Priority\nP2 - Enhancement after basic workflow is complete.","notes":"## Scenario-Based Testing Workflow\n\nAll tasks in this epic should follow this testing workflow:\n\n### After Implementation\n1. Run `bun run build` to build the CLI\n2. Run `bun test --no-coverage` to verify all tests pass\n3. Tell the user which scenario to run for manual testing\n\n### Available Scenarios\nRun `bun run scenario --help` or `bun run scenario` for interactive selection:\n- **emptyStack** - Just main branch, no feature work\n- **singleCommit** - One commit on feature branch (no ID)\n- **multiCommitStack** - 3 commits stacked on feature branch\n- **divergedMain** - Feature branch + upstream changes (needs rebase)\n- **withTasprIds** - 2 commits with Taspr-Commit-Id trailers\n- **mixedTrailerStack** - Some commits have IDs, some don't\n- **conflictScenario** - Setup that will conflict on rebase\n- **multipleBranches** - Two independent feature branches\n\n### New Scenarios Needed for Group Management\nAdd these to `src/scenario/definitions.ts` as tasks are implemented:\n- **withGroups** - Stack with existing group trailers (Group-Start/End/Title)\n- **unclosedGroup** - Stack with Group-Start but no Group-End\n- **overlappingGroups** - Stack with overlapping group trailers\n\n### Scenario Definition Location\n`src/scenario/definitions.ts` - add new scenarios following the existing pattern","status":"closed","priority":2,"issue_type":"epic","created_at":"2025-12-25T14:33:41.928419-05:00","updated_at":"2026-01-02T23:40:45.865844-05:00","closed_at":"2026-01-02T23:40:45.865844-05:00","close_reason":"Closed","dependencies":[{"issue_id":"taspr-7mu","depends_on_id":"taspr-7tr","type":"blocks","created_at":"2025-12-25T14:33:46.040656-05:00","created_by":"daemon"},{"issue_id":"taspr-7mu","depends_on_id":"taspr-7tr","type":"depends-on","created_at":"2025-12-25T14:33:46.040656-05:00","created_by":"daemon"}]}
{"id":"taspr-7mu.1","title":"Rework taspr view to handle groups","description":"## Goal\nUpdate `taspr view` to properly display groups in the stack visualization.\n\n## Current Behavior\nThe `taspr view` command shows individual commits but doesn't visually distinguish grouped commits or show group boundaries.\n\n## Desired Behavior\n- Show group boundaries clearly in the stack view\n- Display group title/name for grouped commits\n- Indicate which commits belong to which group\n- Show group status (e.g., if group has a PR)\n- Consider collapsible group view for large groups\n\n## Acceptance Criteria\n- [ ] Groups are visually distinguishable from individual commits\n- [ ] Group title is displayed\n- [ ] Group boundaries are clear (start/end)\n- [ ] Works with both single-commit and multi-commit groups\n- [ ] Maintains readability for mixed stacks (groups + singles)","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-02T10:58:54.158241-05:00","updated_at":"2026-01-02T21:16:20.499157-05:00","closed_at":"2026-01-02T21:16:20.499157-05:00","close_reason":"Closed","dependencies":[{"issue_id":"taspr-7mu.1","depends_on_id":"taspr-7mu","type":"parent-child","created_at":"2026-01-02T10:58:54.158903-05:00","created_by":"dondenton"}]}
{"id":"taspr-7tr","title":"Epic 2: Initialize Commits for Tracking","description":"## Goal\nAdd `Taspr-Commit-Id` trailers to commits that don't have them, enabling stable tracking across rebases.\n\n## Background\n\n### The Tracking Problem\nGit commit hashes change whenever a commit is rebased, amended, or cherry-picked. taspr needs a stable identifier that survives these operations.\n\n### The Solution: Commit ID Trailers\nEvery commit gets a `Taspr-Commit-Id` trailerâ€”an 8-character hex string that becomes part of the commit message:\n\n```\nfeat: add user authentication\n\nImplements login flow.\n\nTaspr-Commit-Id: a1b2c3d4\n```\n\nThis ID:\n- Survives rebases (message is preserved)\n- Links commits to branches and PRs\n- Enables tracking across history rewrites\n\n### ID Format\n- 8 hexadecimal characters (32 bits)\n- Generated via crypto.randomBytes(4).toString('hex')\n- Example: `a1b2c3d4`, `f7e8d9c0`\n\nWith 8 hex chars, collision probability is negligible for a typical stack (\u003c 50 commits). Once PRs merge, their commits leave the active tracking set.\n\n## Workflow\n\n1. User has commits without IDs\n2. Run `taspr sync`\n3. taspr identifies commits missing `Taspr-Commit-Id`\n4. taspr performs a rebase to add trailers to those commits\n5. Existing IDs are preserved; only missing ones are added\n\n## Implementation Approach\n\n### Interactive Rebase with exec\n```bash\ngit rebase -i --exec 'git commit --amend --no-edit -m \"$(git log -1 --format=%B | git interpret-trailers --trailer \"Taspr-Commit-Id: $(openssl rand -hex 4)\")\"' \u003cmerge-base\u003e\n```\n\nOr, more cleanly with a custom script that:\n1. Checks if commit already has Taspr-Commit-Id\n2. Only adds if missing\n3. Preserves all existing trailers\n\n### Sequence\n1. Check for dirty working tree (block if dirty)\n2. Find commits without Taspr-Commit-Id\n3. If none, no-op\n4. Rebase from merge-base, adding IDs to commits that need them\n5. Report which commits got IDs\n\n## Deliverable\nRunning `taspr sync` adds stable IDs to all commits in the stack via rebase, making them trackable.\n\n## Dependencies\n- Epic 1 must be complete (stack reading, trailer parsing)\n\n## Files to Create/Modify\n- src/core/sync.ts (create) - Sync orchestration\n- src/git/trailers.ts (modify) - Add trailer writing\n- src/cli/commands/sync.ts (create) - Sync command\n\n## Testable Outcome\n- New commits get IDs\n- Existing IDs are preserved through rebase\n- Dirty working tree blocks sync with clear message","status":"closed","priority":1,"issue_type":"epic","created_at":"2025-12-25T14:24:34.266966-05:00","updated_at":"2025-12-26T21:39:56.779724-05:00","closed_at":"2025-12-26T21:39:56.779724-05:00","close_reason":"All 5 child tasks complete. taspr sync now adds Taspr-Commit-Id trailers to commits.","dependencies":[{"issue_id":"taspr-7tr","depends_on_id":"taspr-h87","type":"blocks","created_at":"2025-12-25T14:24:37.974238-05:00","created_by":"daemon"},{"issue_id":"taspr-7tr","depends_on_id":"taspr-h87","type":"depends-on","created_at":"2025-12-25T14:24:37.974238-05:00","created_by":"daemon"}]}
{"id":"taspr-7vt","title":"Error messages - clear, actionable errors throughout","description":"## Goal\nEnsure all error conditions produce clear, actionable error messages that help users understand what went wrong and how to fix it.\n\n## Error Categories to Handle\n\n### Git Errors\n- **Not a git repository**: 'Not in a git repository. Run this command from within a git project.'\n- **No commits**: 'No commits found between HEAD and origin/main. Create some commits first.'\n- **Dirty working tree**: 'You have uncommitted changes. Commit or stash them before running sync.'\n- **Detached HEAD**: 'You are in detached HEAD state. Check out a branch first.'\n- **Rebase in progress**: 'A rebase is in progress. Complete or abort it before continuing.'\n\n### GitHub Errors\n- **gh not installed**: 'The GitHub CLI (gh) is required but not installed. Install it from https://cli.github.com'\n- **gh not authenticated**: 'Not authenticated with GitHub. Run: gh auth login'\n- **No push access**: 'You don\\'t have push access to this repository.'\n- **PR creation failed**: Include the GitHub error message, suggest checking permissions\n- **Rate limited**: 'GitHub API rate limit exceeded. Try again in X minutes.'\n- **Network errors**: 'Could not connect to GitHub. Check your internet connection.'\n\n### Stack/Group Errors\n- **Overlapping groups**: 'Groups cannot overlap. Commits X and Y belong to multiple groups.'\n- **Unclosed group**: 'Group \"X\" started at commit Y but was never closed.'\n- **Invalid group range**: 'Group end marker found before start marker.'\n- **Empty stack**: 'No commits in current stack. Create commits on this branch first.'\n\n### Command Errors\n- **Invalid arguments**: Use Commander\\'s built-in validation with helpful messages\n- **Missing required options**: Commander handles this, but customize messages\n- **Invalid PR number**: 'PR #X not found. Check the PR number and try again.'\n\n## Implementation Guidelines\n\n### Error Message Format\n```\nError: \u003cbrief description\u003e\n\n\u003cdetailed explanation if needed\u003e\n\n\u003csuggested fix or next step\u003e\n```\n\n### Example Good Error\n```\nError: Cannot sync - uncommitted changes detected\n\nYou have 3 modified files that would be lost during rebase.\n\nTo fix:\n  git stash        # Save changes temporarily\n  taspr sync       # Run sync\n  git stash pop    # Restore changes\n```\n\n### Code Pattern\n```typescript\n// src/errors.ts\nexport class TasprError extends Error {\n  constructor(\n    message: string,\n    public readonly suggestion?: string,\n    public readonly details?: string\n  ) {\n    super(message);\n    this.name = 'TasprError';\n  }\n}\n\nexport function formatError(error: TasprError): string {\n  let output = `Error: ${error.message}`;\n  if (error.details) output += `\\n\\n${error.details}`;\n  if (error.suggestion) output += `\\n\\nTo fix:\\n  ${error.suggestion}`;\n  return output;\n}\n```\n\n### Audit All Commands\n- Review each command for error paths\n- Ensure consistent error formatting\n- Test error messages are helpful\n\n## Acceptance Criteria\n- [ ] All errors use consistent format\n- [ ] Errors include actionable suggestions where possible\n- [ ] No raw exception messages leak to users\n- [ ] Network/API errors are user-friendly\n- [ ] Exit codes are meaningful (0=success, 1=user error, 2=system error)","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-25T14:49:11.790611-05:00","updated_at":"2025-12-25T14:49:11.790611-05:00","dependencies":[{"issue_id":"taspr-7vt","depends_on_id":"taspr-8iv","type":"parent-child","created_at":"2025-12-25T15:01:36.509681-05:00","created_by":"daemon"}]}
{"id":"taspr-7x3","title":"Audit all taspr workflows for edge cases","description":"## Goal\n\nSystematically review all taspr workflows and identify edge cases that could cause errors or unexpected behavior. Use Opus 4.5 to think through scenarios methodically.\n\n## Workflow Areas to Audit\n\n### 1. Stack Operations\n- Creating commits on feature branch\n- Rebasing stack onto updated main\n- Cherry-picking commits\n- Amending commits in middle of stack\n- Reordering commits\n\n### 2. Group Operations\n- Creating groups (taspr group)\n- Splitting groups\n- Nested groups (if possible)\n- Groups spanning entire stack\n- Single-commit groups\n\n### 3. Sync Operations\n- First sync (no IDs yet)\n- Subsequent syncs (updating existing PRs)\n- Sync after rebase\n- Sync after amending grouped commits\n- Sync with dirty working tree\n- Sync during merge conflict\n\n### 4. Temp Commits (WIP, fixup!, etc.)\n- Single temp commit\n- Temp commit in stack\n- Multiple temp commits\n- Grouped temp commits\n- Squashing after grouping (see taspr-b3e)\n\n### 5. PR Lifecycle\n- PR created â†’ changes pushed\n- PR merged â†’ cleanup\n- PR closed without merge\n- Stale PRs (branch deleted manually)\n- PR retargeting after base merged\n\n### 6. ID Management\n- ID injection during sync\n- ID preservation during rebase\n- ID conflicts (same ID on different commits)\n- Missing IDs after external rebase\n\n### 7. Branch Naming\n- Username changes\n- Prefix changes mid-stack\n- Branch name collisions\n\n### Questions to Answer\n\n- What stack/group states are valid vs invalid?\n- Where does taspr need guardrails or auto-repair?\n- What error messages should users see for invalid states?\n- Should any operations be blocked preemptively?\n\n## Related Issues\n\n- taspr-b3e: Fix group integrity when fixup! commits are squashed\n\n## Output\n\nDocument findings as new beads issues for specific fixes needed.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-03T14:18:08.620633-05:00","updated_at":"2026-01-03T14:18:47.696728-05:00","dependencies":[{"issue_id":"taspr-7x3","depends_on_id":"taspr-b3e","type":"relates-to","created_at":"2026-01-03T14:18:19.833166-05:00","created_by":"dondenton"}]}
{"id":"taspr-868","title":"Stack structure detection (PRUnit parsing)","description":"## Goal\nBuild a PRUnit[] array from commits, identifying which commits are singles and which belong to groups.\n\n## Background\nAfter parsing commits and their trailers, we need to understand the stack structure:\n- Commits without group trailers become individual PRUnits (type: 'single')\n- Commits between Taspr-Group-Start and Taspr-Group-End become one PRUnit (type: 'group')\n\n## Data Structures\n\n```typescript\ninterface PRUnit {\n  type: 'single' | 'group';\n  id: string;           // Taspr-Commit-Id (single) or group-id (group)\n  title: string;        // Commit subject (single) or Taspr-Group-Title (group)\n  commitIds: string[];  // All Taspr-Commit-Id values in this unit\n  commits: string[];    // Current git hashes\n}\n\ninterface CommitInfo {\n  hash: string;\n  subject: string;\n  body: string;\n  trailers: CommitTrailers;\n}\n```\n\n## Algorithm\n\n```typescript\nfunction detectPRUnits(commits: CommitInfo[]): PRUnit[] {\n  const units: PRUnit[] = [];\n  let currentGroup: Partial\u003cPRUnit\u003e | null = null;\n  \n  for (const commit of commits) {\n    const commitId = commit.trailers['Taspr-Commit-Id'];\n    const startId = commit.trailers['Taspr-Group-Start'];\n    const endId = commit.trailers['Taspr-Group-End'];\n    \n    if (startId \u0026\u0026 !currentGroup) {\n      // Start a new group\n      currentGroup = {\n        type: 'group',\n        id: startId,\n        title: commit.trailers['Taspr-Group-Title'] || commit.subject,\n        commitIds: [commitId],\n        commits: [commit.hash],\n      };\n    } else if (currentGroup) {\n      // Add to current group\n      currentGroup.commitIds!.push(commitId);\n      currentGroup.commits!.push(commit.hash);\n      \n      if (endId === currentGroup.id) {\n        // End of group\n        units.push(currentGroup as PRUnit);\n        currentGroup = null;\n      }\n    } else {\n      // Single commit\n      units.push({\n        type: 'single',\n        id: commitId,\n        title: commit.subject,\n        commitIds: [commitId],\n        commits: [commit.hash],\n      });\n    }\n  }\n  \n  // Handle unclosed group (validation error - covered in next task)\n  return units;\n}\n```\n\n## Edge Cases\n1. **Empty stack**: Return empty array\n2. **All singles**: Each commit becomes a PRUnit\n3. **All in one group**: One PRUnit with all commits\n4. **Mixed**: Singles and groups interspersed\n5. **Commit without Taspr-Commit-Id**: Still include (ID will be undefined, handled by sync later)\n\n## Testing Strategy\nTest with various commit arrangements:\n1. Three singles\n2. Three commits in one group\n3. Single, group of 2, single\n4. Group of 3, group of 2\n\n## Files to Create/Modify\n- src/core/stack.ts (create)\n\n## Acceptance Criteria\n- [ ] Correctly identifies single commits\n- [ ] Correctly identifies group boundaries\n- [ ] Preserves commit order (oldest first)\n- [ ] Handles commits without IDs gracefully\n- [ ] Has comprehensive tests for various scenarios","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T14:23:08.166742-05:00","updated_at":"2025-12-26T01:10:10.855841-05:00","closed_at":"2025-12-26T01:10:10.855841-05:00","close_reason":"Implemented detectPRUnits() in src/core/stack.ts with 10 passing tests","dependencies":[{"issue_id":"taspr-868","depends_on_id":"taspr-h87","type":"parent-child","created_at":"2025-12-25T14:23:12.019736-05:00","created_by":"daemon"},{"issue_id":"taspr-868","depends_on_id":"taspr-8i9","type":"blocks","created_at":"2025-12-25T14:23:12.300646-05:00","created_by":"daemon"},{"issue_id":"taspr-868","depends_on_id":"taspr-8i9","type":"depends-on","created_at":"2025-12-25T14:23:12.300646-05:00","created_by":"daemon"}]}
{"id":"taspr-8bs","title":"Prevent fixup!/amend! commits from auto-reordering during rebases","description":"## Problem\nGit's `rebase --autosquash` automatically reorders `fixup!` and `amend!` commits to be placed after their target commits. This can interfere with our custom rebase operations in the group TUI and other places.\n\n## Solution\nEnsure all our rebasing operations (group rebase, sync rebase, etc.) do NOT use `--autosquash` or explicitly disable it with `--no-autosquash` to prevent unexpected commit reordering.\n\n## Files to Check\n- `src/git/group-rebase.ts` - group reordering rebases\n- Any other files that invoke `git rebase`\n\n## Acceptance Criteria\n- All rebase commands explicitly use `--no-autosquash` \n- Test with a stack containing `fixup! \u003ccommit-msg\u003e` commits to verify they stay in place\n- Document this behavior if needed","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-02T11:20:47.826886-05:00","updated_at":"2026-01-02T12:02:33.757385-05:00","closed_at":"2026-01-02T12:02:33.757385-05:00","close_reason":"Closed","dependencies":[{"issue_id":"taspr-8bs","depends_on_id":"taspr-7mu","type":"parent-child","created_at":"2026-01-02T11:20:56.54861-05:00","created_by":"dondenton"}]}
{"id":"taspr-8i9","title":"Trailer parsing","description":"## Goal\nExtract taspr-specific trailers from commit messages.\n\n## Background\nGit trailers are key-value pairs at the end of commit messages, following a specific format:\n```\nfeat: add user authentication\n\nImplements login flow with session management.\n\nTaspr-Commit-Id: a1b2c3d4\nTaspr-Group-Start: f7e8d9c0\nTaspr-Group-Title: Authentication feature\n```\n\ntaspr uses these trailers:\n- `Taspr-Commit-Id`: 8 hex chars, unique ID for each commit (survives rebases)\n- `Taspr-Group-Start`: 8 hex chars, marks the first commit of a group\n- `Taspr-Group-Title`: String, PR title for the group\n- `Taspr-Group-End`: 8 hex chars (same as Group-Start), marks the last commit of a group\n\n## Implementation\n\n### Using git interpret-trailers\n```bash\ngit interpret-trailers --parse \u003c\u003c\u003c \"commit message body\"\n```\n\nThis outputs:\n```\nTaspr-Commit-Id: a1b2c3d4\nTaspr-Group-Start: f7e8d9c0\n```\n\n### Function Signatures\n```typescript\ninterface CommitTrailers {\n  'Taspr-Commit-Id'?: string;\n  'Taspr-Group-Start'?: string;\n  'Taspr-Group-Title'?: string;\n  'Taspr-Group-End'?: string;\n  [key: string]: string | undefined;  // Allow other trailers\n}\n\nasync function parseTrailers(commitBody: string): Promise\u003cCommitTrailers\u003e\n\n// Convenience function to get trailers for a commit\nasync function getCommitTrailers(commitHash: string): Promise\u003cCommitTrailers\u003e\n```\n\n### Edge Cases\n1. **No trailers**: Return empty object\n2. **Non-taspr trailers**: Include them (e.g., Co-authored-by)\n3. **Malformed trailers**: Let git interpret-trailers handle\n4. **Multiple values for same key**: Use last value (git's behavior)\n\n## Testing Strategy\nTest with various commit message formats:\n1. No trailers\n2. Single trailer\n3. Multiple trailers\n4. Mixed taspr and other trailers\n5. Trailers with special characters in values\n\n## Files to Create/Modify\n- src/git/trailers.ts (create)\n\n## Acceptance Criteria\n- [ ] Correctly parses all taspr trailer types\n- [ ] Handles commits without trailers\n- [ ] Uses git interpret-trailers for correct parsing\n- [ ] Has unit tests for various message formats","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T14:22:49.259548-05:00","updated_at":"2025-12-26T01:07:19.162812-05:00","closed_at":"2025-12-26T01:07:19.162812-05:00","close_reason":"Implemented parseTrailers() and getCommitTrailers() in src/git/trailers.ts with 13 passing tests","dependencies":[{"issue_id":"taspr-8i9","depends_on_id":"taspr-h87","type":"parent-child","created_at":"2025-12-25T14:22:53.156159-05:00","created_by":"daemon"},{"issue_id":"taspr-8i9","depends_on_id":"taspr-6nw","type":"blocks","created_at":"2025-12-25T14:22:53.429839-05:00","created_by":"daemon"},{"issue_id":"taspr-8i9","depends_on_id":"taspr-6nw","type":"depends-on","created_at":"2025-12-25T14:22:53.429839-05:00","created_by":"daemon"}]}
{"id":"taspr-8iv","title":"Epic 9: Polish and Distribution","description":"## Goal\nProduction-ready CLI with good error handling and installation.\n\n## Background\nAfter all features are implemented, this epic focuses on:\n- Consistent, helpful error messages\n- Dependency checks (gh CLI)\n- Cross-platform builds\n- Easy installation\n- Documentation\n\n## Deliverable\ntaspr can be installed and used on a fresh machine without friction.\n\n## Dependencies\n- All previous epics should be complete\n\n## Priority\nP3 - Release prep after features are stable.\n\n## Key Areas\n\n### Error Messages\nEvery error should:\n- Explain what went wrong\n- Suggest how to fix it\n- Include relevant context (commit hashes, PR numbers)\n\n### gh CLI Dependency\ntaspr requires gh CLI for GitHub operations:\n- Check for installation\n- Check for authentication\n- Clear messages if missing\n\n### Cross-Platform\nSupport:\n- macOS (Intel and Apple Silicon)\n- Linux (x64 and ARM64)\n- (Optional) Windows\n\n### Installation\n- `curl | bash` installer for Unix\n- npm package fallback\n- Direct binary download from releases\n\n### Documentation\n- README with quick start\n- Command reference\n- Troubleshooting guide\n- Update CLAUDE.md with real commands","status":"open","priority":3,"issue_type":"epic","created_at":"2025-12-25T14:47:40.093629-05:00","updated_at":"2025-12-25T14:47:40.093629-05:00"}
{"id":"taspr-8iv.1","title":"Add alt/option key as temporary mode switch in grouping TUI","description":"Use the alt/option key as a temporary mode switch key in the grouping TUI. It should enter move mode when pressed down and exit move mode when released, allowing quick move operations without explicitly toggling modes.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-02T11:30:14.583351-05:00","updated_at":"2026-01-03T14:39:49.295083-05:00","closed_at":"2026-01-03T14:39:49.295083-05:00","close_reason":"Closed","dependencies":[{"issue_id":"taspr-8iv.1","depends_on_id":"taspr-8iv","type":"parent-child","created_at":"2026-01-02T11:30:14.583969-05:00","created_by":"dondenton"}]}
{"id":"taspr-8iv.2","title":"Optimize TUI redrawing to avoid creating excessive output lines","description":"Evaluate how we are redrawing the TUI on each state change. Currently, the TUI may be creating more and more lines of output instead of redrawing in place. Investigate and optimize to use proper terminal control sequences for in-place updates.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-02T11:52:41.606296-05:00","updated_at":"2026-01-02T11:52:41.606296-05:00","dependencies":[{"issue_id":"taspr-8iv.2","depends_on_id":"taspr-8iv","type":"parent-child","created_at":"2026-01-02T11:52:41.606988-05:00","created_by":"dondenton"}]}
{"id":"taspr-8ja","title":"View --all flag for all stacks","description":"## Goal\nShow all known stacks across branches with `taspr view --all`.\n\n## Implementation\n\n```typescript\n// src/cli/commands/view.ts\n\nasync function viewAll() {\n  // Find all branches with taspr prefix\n  const config = await getBranchNameConfig();\n  const prefix = config.branchPrefix;\n  \n  const result = await $\\`git branch -r --list 'origin/\\${prefix}/*'\\`;\n  const branches = result.stdout.toString().trim().split('\\n')\n    .map(b =\u003e b.trim().replace('origin/', ''));\n  \n  // Group by user\n  const byUser = groupBy(branches, b =\u003e b.split('/')[1]);\n  \n  // Display each stack\n  for (const [user, userBranches] of Object.entries(byUser)) {\n    console.log(\\`\\\\n### \\${user}'s stacks\\\\n\\`);\n    \n    // Group by local branch (if we can determine it)\n    // For now, just list all PRs\n    for (const branch of userBranches) {\n      const pr = await findPRByBranch(branch);\n      if (pr) {\n        console.log(\\`  \\${getPRStatusIcon(pr)} #\\${pr.number} \\${pr.title}\\`);\n      }\n    }\n  }\n}\n```\n\n## Output\n```\n$ taspr view --all\n\n### msims's stacks\n\nfeature/auth (3 PRs)\n  âœ“ #142 Add user model\n  â— #143 Authentication feature\n  â— #144 Add admin dashboard\n\nfeature/api (2 PRs)\n  â— #145 Add REST endpoints\n  â—‹ Add GraphQL\n\n### other-user's stacks\n...\n```\n\n## Challenges\n- Determining which branches belong to which \"stack\"\n- May require local state to track stack groupings\n\n## Simpler Alternative\nJust list all PRs owned by current user:\n```typescript\nasync function viewAll() {\n  const username = await getGitHubUsername();\n  const result = await $\\`gh pr list --author \\${username} --json number,title,state,headRefName\\`;\n  // Display all user's PRs\n}\n```\n\n## Files to Modify\n- src/cli/commands/view.ts\n\n## Acceptance Criteria\n- [ ] Lists all stacks/PRs with --all flag\n- [ ] Groups by user or branch\n- [ ] Shows status for each","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-25T14:33:18.747309-05:00","updated_at":"2025-12-31T14:28:25.392643-05:00","closed_at":"2025-12-31T14:28:25.392643-05:00","close_reason":"Implemented --all flag for view command that lists all PRs authored by the current user, grouped by state (Open/Merged/Closed)","dependencies":[{"issue_id":"taspr-8ja","depends_on_id":"taspr-v0c","type":"parent-child","created_at":"2025-12-25T14:33:23.016339-05:00","created_by":"daemon"},{"issue_id":"taspr-8ja","depends_on_id":"taspr-2m1","type":"blocks","created_at":"2025-12-25T14:33:23.289568-05:00","created_by":"daemon"},{"issue_id":"taspr-8ja","depends_on_id":"taspr-2m1","type":"depends-on","created_at":"2025-12-25T14:33:23.289568-05:00","created_by":"daemon"}]}
{"id":"taspr-8mh","title":"Build for all platforms - macOS and Linux binaries","description":"## Goal\nBuild standalone taspr binaries for macOS and Linux using Bun\\'s `bun build --compile` feature.\n\n## Target Platforms\n\n| Platform | Architecture | Target Flag | Binary Name |\n|----------|-------------|-------------|-------------|\n| macOS Intel | x64 | `--target=bun-darwin-x64` | taspr-darwin-x64 |\n| macOS Apple Silicon | ARM64 | `--target=bun-darwin-arm64` | taspr-darwin-arm64 |\n| Linux | x64 | `--target=bun-linux-x64` | taspr-linux-x64 |\n| Linux | ARM64 | `--target=bun-linux-arm64` | taspr-linux-arm64 |\n\nWindows support deferred - most stacked PR workflows are macOS/Linux.\n\n## Bun Compile Basics\n\n```bash\n# Single platform (current)\nbun build --compile src/cli/index.ts --outfile taspr\n\n# Cross-compile for specific target\nbun build --compile --target=bun-darwin-arm64 src/cli/index.ts --outfile taspr-darwin-arm64\n\n# With bytecode for faster startup (experimental)\nbun build --compile --bytecode src/cli/index.ts --outfile taspr\n```\n\n## Binary Size Expectations\n- macOS: ~51MB (includes Bun runtime)\n- Linux: ~50MB\n- These are larger than Go binaries but acceptable for dev tools\n\n## Build Script\n\n```typescript\n// scripts/build.ts\nimport { $ } from 'bun';\n\nconst targets = [\n  { name: 'darwin-x64', target: 'bun-darwin-x64' },\n  { name: 'darwin-arm64', target: 'bun-darwin-arm64' },\n  { name: 'linux-x64', target: 'bun-linux-x64' },\n  { name: 'linux-arm64', target: 'bun-linux-arm64' },\n];\n\nconst entrypoint = 'src/cli/index.ts';\nconst outdir = 'dist';\n\nawait $`mkdir -p ${outdir}`;\n\nfor (const { name, target } of targets) {\n  console.log(`Building for ${name}...`);\n  await $`bun build --compile --target=${target} ${entrypoint} --outfile ${outdir}/taspr-${name}`;\n  console.log(`  âœ“ dist/taspr-${name}`);\n}\n\nconsole.log('\\nAll builds complete\\!');\n```\n\n## package.json Scripts\n\n```json\n{\n  \"scripts\": {\n    \"build\": \"bun run scripts/build.ts\",\n    \"build:local\": \"bun build --compile src/cli/index.ts --outfile dist/taspr\",\n    \"build:darwin-arm64\": \"bun build --compile --target=bun-darwin-arm64 src/cli/index.ts --outfile dist/taspr-darwin-arm64\",\n    \"build:darwin-x64\": \"bun build --compile --target=bun-darwin-x64 src/cli/index.ts --outfile dist/taspr-darwin-x64\",\n    \"build:linux-x64\": \"bun build --compile --target=bun-linux-x64 src/cli/index.ts --outfile dist/taspr-linux-x64\",\n    \"build:linux-arm64\": \"bun build --compile --target=bun-linux-arm64 src/cli/index.ts --outfile dist/taspr-linux-arm64\"\n  }\n}\n```\n\n## GitHub Actions for Releases\n\n```yaml\n# .github/workflows/release.yml\nname: Release\n\non:\n  push:\n    tags:\n      - 'v*'\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      \n      - uses: oven-sh/setup-bun@v1\n        with:\n          bun-version: latest\n      \n      - run: bun install\n      \n      - run: bun run build\n      \n      - name: Create Release\n        uses: softprops/action-gh-release@v1\n        with:\n          files: |\n            dist/taspr-darwin-x64\n            dist/taspr-darwin-arm64\n            dist/taspr-linux-x64\n            dist/taspr-linux-arm64\n```\n\n## Version Embedding\n\n```typescript\n// src/version.ts\n// This file is updated by build script\nexport const VERSION = '0.1.0';\nexport const BUILD_DATE = '2025-01-01';\nexport const COMMIT_SHA = 'abc1234';\n```\n\nBuild script can update this from git:\n```typescript\nconst version = await $`git describe --tags --always`.text();\nconst sha = await $`git rev-parse --short HEAD`.text();\n```\n\n## Testing Binaries\n\nTest each platform binary:\n```bash\n# On appropriate platform\n./dist/taspr-darwin-arm64 --version\n./dist/taspr-darwin-arm64 --help\n./dist/taspr-darwin-arm64 view\n```\n\nCross-platform testing via Docker for Linux binaries.\n\n## Acceptance Criteria\n- [ ] `bun run build` produces all 4 platform binaries\n- [ ] `bun run build:local` produces binary for current platform\n- [ ] Binaries are standalone (no external dependencies except git, gh)\n- [ ] --version shows correct version info\n- [ ] GitHub Actions workflow builds on tag push\n- [ ] Binaries are attached to GitHub releases\n- [ ] dist/ is in .gitignore","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-25T14:50:24.67684-05:00","updated_at":"2025-12-25T14:50:24.67684-05:00","dependencies":[{"issue_id":"taspr-8mh","depends_on_id":"taspr-8iv","type":"parent-child","created_at":"2025-12-25T15:01:37.342706-05:00","created_by":"daemon"}]}
{"id":"taspr-a64","title":"Epic 8: Rebase and Conflict Handling","description":"## Goal\nHandle rebasing onto updated main and conflict resolution.\n\n## Background\n\n### The Rebase Problem\nAs main advances, stacks fall behind. `taspr sync` should:\n1. Detect when stack is behind origin/main\n2. Rebase stack onto latest main\n3. Handle conflicts gracefully\n4. Update all affected PR branches\n\n### Conflict Scenarios\n1. **Automatic resolve**: Git handles the conflict automatically\n2. **Manual resolve**: User must fix conflicts\n3. **Stack cascade**: Rebasing bottom changes all commits above\n\n## Workflow\n\n### Normal Rebase\n```\n$ taspr sync\n\nâœ“ Rebased onto origin/main (4 commits)\nâœ“ Updated 3 PR branches\n```\n\n### Conflict\n```\n$ taspr sync\n\nRebasing onto origin/main...\nâœ— Conflict in src/auth.ts\n\n  Please resolve the conflict and run:\n    git add src/auth.ts\n    git rebase --continue\n    taspr sync\n```\n\n## Deliverable\n`taspr sync` rebases if behind origin/main, with clear conflict handling.\n\n## Dependencies\n- Epic 4 must be complete (branch updates)\n\n## Key Considerations\n- Preserving Taspr-Commit-Id trailers through rebase\n- Updating all affected branches after rebase\n- Clear instructions for manual conflict resolution\n\n## Priority\nP2 - Robustness feature after MVP.","status":"closed","priority":2,"issue_type":"epic","created_at":"2025-12-25T14:35:58.534692-05:00","updated_at":"2025-12-31T14:20:52.111538-05:00","closed_at":"2025-12-31T14:20:52.111538-05:00","close_reason":"Closed","dependencies":[{"issue_id":"taspr-a64","depends_on_id":"taspr-1ni","type":"blocks","created_at":"2025-12-25T14:36:02.243595-05:00","created_by":"daemon"},{"issue_id":"taspr-a64","depends_on_id":"taspr-1ni","type":"depends-on","created_at":"2025-12-25T14:36:02.243595-05:00","created_by":"daemon"}]}
{"id":"taspr-ak3","title":"Reevaluate necessity of pushing branches to origin before PR","description":"Review whether we need to push branches to origin when a PR hasn't been opened yet. Consider if this adds unnecessary remote clutter or if there are valid reasons to keep this behavior (e.g., backup, collaboration, CI triggers).","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-02T23:44:16.218254-05:00","updated_at":"2026-01-02T23:51:55.453529-05:00","closed_at":"2026-01-02T23:51:55.453529-05:00","close_reason":"Closed"}
{"id":"taspr-ar8","title":"Prevent WIP/fixup/amend commits from becoming PRs","description":"Commits with certain prefixes should be handled specially during `taspr sync --open`:\n- WIP (case insensitive)\n- fixup!\n- amend!\n- squash!\n\n## Behavior\n\n**These commits should NOT automatically get PRs**, but they don't block anything:\n1. Push branch (needed for stacking if there are dependent commits)\n2. Skip PR creation\n3. Dependent commits CAN have PRs (reviewable, but base has no PR)\n4. Output: `âš  Skipped PR for \"WIP: ...\" (work in progress)` or similar\n\n**Escape hatch**: Explicit grouping allows PR creation. If user groups a WIP commit with others, we create the PR.\n\n## Implementation Notes\n\n- Add `isWorkInProgress(title: string): boolean` helper\n- Modify sync to check title before PR creation\n- Still push branches for stacking (unlike regular commits without --open)\n- Track \"skipped WIP\" separately in sync output","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-03T00:00:37.575334-05:00","updated_at":"2026-01-03T13:57:47.20772-05:00","closed_at":"2026-01-03T13:57:47.20772-05:00","close_reason":"Implemented temp commit detection with configurable prefixes via git config taspr.tempCommitPrefixes. WIP, fixup!, amend!, squash! commits now skip PR creation during sync --open while still pushing branches for stacking. Added unit tests for isTempCommit() and config parsing, plus integration tests for the sync behavior."}
{"id":"taspr-b3e","title":"Fix group integrity when fixup! commits are squashed","description":"## Problem\n\nWhen a group contains a fixup! commit that gets squashed via `git rebase --autosquash`, the group loses a commit and becomes invalid (missing end marker). This causes sync to fail with a group error.\n\n**Example scenario:**\n1. Create commit A (single commit, gets PR)\n2. Create `fixup! A` commit\n3. Group them together (now A has Group-Start, fixup! has Group-End)\n4. Run `git rebase -i --autosquash origin/main` - fixup! squashes into A\n5. Group-End trailer is lost\n6. `taspr sync` fails: unclosed group\n\n## Possible Solutions\n\n1. **All grouped commits get shared ID** - Instead of Start/End markers, all commits in a group share the same Taspr-Commit-Id. Squashing doesn't break anything since the ID persists.\n\n2. **Custom autosquash command** - `taspr squash` that handles group integrity before/after rebase. Knows which commits are grouped and repairs trailers.\n\n3. **Group repair on sync** - Detect orphaned Group-Start without Group-End and auto-repair (convert to single commit).\n\n4. **Warn before breaking operation** - Detect when autosquash would break groups and warn user.\n\n## Related Documentation\n\nThe README documents the fixup! workflow but doesn't mention this edge case. Look for marker:\n`FIXUP_GROUP_DOCS` in README.md - update after resolving this issue.\n\n## Acceptance Criteria\n\n- [ ] Squashing fixup! commits doesn't break group integrity\n- [ ] Clear error or auto-repair when group becomes invalid\n- [ ] Documentation updated (remove FIXUP_GROUP_DOCS marker)","status":"closed","priority":1,"issue_type":"bug","created_at":"2026-01-03T14:15:25.350772-05:00","updated_at":"2026-01-03T21:24:33.669761-05:00","closed_at":"2026-01-03T21:24:33.669761-05:00","close_reason":"Planning complete. Implementation plan created. Solution: Replace Taspr-Group-Start/End markers with Taspr-Group and Taspr-Group-Title on ALL commits in a group for squash resilience.","dependencies":[{"issue_id":"taspr-b3e","depends_on_id":"taspr-7x3","type":"relates-to","created_at":"2026-01-03T14:18:19.81405-05:00","created_by":"dondenton"}]}
{"id":"taspr-b7d","title":"Group validation (overlapping and unclosed)","description":"## Goal\nDetect and report malformed groups: overlapping groups and unclosed groups.\n\n## Background\nGroups must follow strict rules:\n1. **No overlapping**: A group cannot start inside another group\n2. **Must close**: Every Taspr-Group-Start must have a matching Taspr-Group-End\n\nValidation happens during stack parsing and should return clear, actionable errors.\n\n## Error Types\n\n```typescript\ntype StackParseResult = \n  | { ok: true; units: PRUnit[] }\n  | { ok: false; error: 'unclosed-group'; groupId: string; startCommit: string; groupTitle: string }\n  | { ok: false; error: 'overlapping-groups'; \n      group1: { id: string; title: string; startCommit: string };\n      group2: { id: string; title: string; startCommit: string };\n      overlappingCommit: string }\n```\n\n## Validation Algorithm\n\n```typescript\nfunction validateAndDetectPRUnits(commits: CommitInfo[]): StackParseResult {\n  let activeGroup: { id: string; title: string; start: string } | null = null;\n  \n  for (const commit of commits) {\n    const startId = commit.trailers['Taspr-Group-Start'];\n    const endId = commit.trailers['Taspr-Group-End'];\n    \n    // Check for overlapping groups\n    if (startId \u0026\u0026 activeGroup \u0026\u0026 startId !== activeGroup.id) {\n      return {\n        ok: false,\n        error: 'overlapping-groups',\n        group1: activeGroup,\n        group2: { \n          id: startId, \n          title: commit.trailers['Taspr-Group-Title'] || commit.subject,\n          startCommit: commit.hash \n        },\n        overlappingCommit: commit.hash,\n      };\n    }\n    \n    if (startId \u0026\u0026 !activeGroup) {\n      activeGroup = { \n        id: startId, \n        title: commit.trailers['Taspr-Group-Title'] || commit.subject,\n        start: commit.hash \n      };\n    }\n    \n    if (endId \u0026\u0026 activeGroup \u0026\u0026 endId === activeGroup.id) {\n      activeGroup = null;\n    }\n  }\n  \n  // Check for unclosed group\n  if (activeGroup) {\n    return {\n      ok: false,\n      error: 'unclosed-group',\n      groupId: activeGroup.id,\n      startCommit: activeGroup.start,\n      groupTitle: activeGroup.title,\n    };\n  }\n  \n  // If validation passes, run detection\n  return { ok: true, units: detectPRUnits(commits) };\n}\n```\n\n## Error Messages (for CLI)\n\n### Unclosed Group\n```\nâœ— Error: Unclosed group starting at commit b2c3d4e5\n\n  Group f7e8d9c0 (\"Auth feature\") has Taspr-Group-Start but no \n  matching Taspr-Group-End was found in subsequent commits.\n  \n  To fix, either:\n    1. Run `taspr group edit` to set the end boundary\n    2. Run `taspr group dissolve` to remove the incomplete group\n```\n\n### Overlapping Groups\n```\nâœ— Error: Overlapping groups detected\n\n  Group \"Auth feature\" (f7e8d9c0):\n    starts at b2c3d4e5\n\n  Group \"Login flow\" (a9b8c7d6):\n    starts at c3d4e5f6 (inside \"Auth feature\")\n\n  To fix, run `taspr group edit` to adjust the ranges.\n```\n\n## Testing Strategy\n1. Valid stack with no groups\n2. Valid stack with one group\n3. Valid stack with multiple non-overlapping groups\n4. Unclosed group (Start but no End)\n5. Overlapping groups (Start inside another Start)\n6. End without Start (malformed, should be ignored or warned)\n\n## Files to Create/Modify\n- src/core/stack.ts (modify to add validation)\n\n## Acceptance Criteria\n- [ ] Detects unclosed groups with clear error\n- [ ] Detects overlapping groups with clear error\n- [ ] Returns success with PRUnits when valid\n- [ ] Error messages include commit hashes for debugging\n- [ ] Has tests for all validation scenarios","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T14:23:31.178628-05:00","updated_at":"2025-12-26T01:18:36.350318-05:00","closed_at":"2025-12-26T01:18:36.350318-05:00","close_reason":"Implemented parseStack() with validation for unclosed and overlapping groups, 7 new tests","dependencies":[{"issue_id":"taspr-b7d","depends_on_id":"taspr-h87","type":"parent-child","created_at":"2025-12-25T14:23:35.162413-05:00","created_by":"daemon"},{"issue_id":"taspr-b7d","depends_on_id":"taspr-868","type":"blocks","created_at":"2025-12-25T14:23:35.437374-05:00","created_by":"daemon"},{"issue_id":"taspr-b7d","depends_on_id":"taspr-868","type":"depends-on","created_at":"2025-12-25T14:23:35.437374-05:00","created_by":"daemon"}]}
{"id":"taspr-bg5","title":"Merged PR detection and cleanup","description":"## Goal\nIdentify merged PRs and clean them up from local tracking.\n\n## Background\nAfter a PR merges:\n1. The PR is in \"merged\" state on GitHub\n2. The branch can be deleted\n3. Local tracking should stop including it in the stack\n\n## Implementation\n\n### Detecting Merged PRs\n```typescript\nasync function getMergedPRUnits(\n  units: PRUnit[],\n  config: BranchNameConfig\n): Promise\u003cPRUnit[]\u003e {\n  const merged: PRUnit[] = [];\n  \n  for (const unit of units) {\n    const branch = getBranchName(unit.id, config);\n    const pr = await findPRByBranch(branch);\n    \n    if (pr?.state === 'merged') {\n      merged.push(unit);\n    }\n  }\n  \n  return merged;\n}\n```\n\n### Cleanup Actions\n1. **Delete remote branch** (optional):\n   ```bash\n   git push origin --delete taspr/msims/a1b2c3d4\n   ```\n\n2. **Report merged PRs**:\n   ```\n   âœ“ PR #142 merged to main\n   âœ“ Deleted branch taspr/msims/a1b2c3d4\n   ```\n\n### During Sync\n```typescript\nasync function cleanupMergedPRs(units: PRUnit[]): Promise\u003cPRUnit[]\u003e {\n  const merged = await getMergedPRUnits(units);\n  \n  if (merged.length \u003e 0) {\n    console.log(\\`âœ“ Removed \\${merged.length} merged PR(s) from tracking\\`);\n    \n    // Optionally delete remote branches\n    for (const unit of merged) {\n      await deleteRemoteBranch(getBranchName(unit.id));\n    }\n  }\n  \n  // Return remaining (non-merged) units\n  return units.filter(u =\u003e !merged.includes(u));\n}\n```\n\n## Integration with View\nAfter landing, `taspr view` shows:\n- Merged PRs with âœ“ status\n- Or excludes merged PRs entirely (after sync)\n\n## Testing\n- Detect merged state\n- Delete remote branch\n- Remaining PRs still tracked\n\n## Files to Create/Modify\n- src/core/sync.ts\n- src/github/branches.ts\n\n## Acceptance Criteria\n- [ ] Detects merged PRs via GitHub API\n- [ ] Optionally deletes remote branches\n- [ ] Reports cleanup in sync output\n- [ ] Remaining stack is correctly updated","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T14:31:11.906558-05:00","updated_at":"2025-12-31T00:19:36.836181-05:00","closed_at":"2025-12-31T00:19:36.836181-05:00","close_reason":"Implemented merged PR detection and cleanup in sync command. During sync, detects merged PRs via GitHub API, deletes their remote branches, and reports the cleanup.","dependencies":[{"issue_id":"taspr-bg5","depends_on_id":"taspr-6le","type":"parent-child","created_at":"2025-12-25T14:31:15.902133-05:00","created_by":"daemon"},{"issue_id":"taspr-bg5","depends_on_id":"taspr-bwi","type":"blocks","created_at":"2025-12-25T14:31:16.180399-05:00","created_by":"daemon"},{"issue_id":"taspr-bg5","depends_on_id":"taspr-bwi","type":"depends-on","created_at":"2025-12-25T14:31:16.180399-05:00","created_by":"daemon"}]}
{"id":"taspr-bvy","title":"GitHub username detection","description":"## Goal\nGet the current user's GitHub username for branch naming.\n\n## Implementation\n\n```typescript\n// src/github/api.ts\n\nasync function getGitHubUsername(): Promise\u003cstring\u003e {\n  const result = await $\\`gh api user --jq .login\\`.nothrow();\n  \n  if (result.exitCode !== 0) {\n    throw new GitHubAuthError(\n      'Failed to get GitHub username. Ensure gh CLI is installed and authenticated.\\n' +\n      'Run: gh auth login'\n    );\n  }\n  \n  return result.stdout.toString().trim();\n}\n```\n\n### Error Handling\nThe `gh api user` command fails if:\n1. `gh` CLI is not installed\n2. User is not authenticated\n3. Network issues\n\nProvide clear error messages for each case.\n\n### gh CLI Dependency\ntaspr delegates all GitHub auth to `gh`. This means:\n- No token management in taspr\n- User's existing `gh` auth works automatically\n- Enterprise GitHub works if configured in `gh`\n\n### Check for gh Installation\n```typescript\nasync function ensureGhInstalled(): Promise\u003cvoid\u003e {\n  const result = await $\\`which gh\\`.nothrow();\n  if (result.exitCode !== 0) {\n    throw new DependencyError(\n      'gh CLI not found. Please install it:\\n' +\n      '  brew install gh          # macOS\\n' +\n      '  apt install gh           # Ubuntu\\n' +\n      '  https://cli.github.com   # Other'\n    );\n  }\n}\n```\n\n## Testing\n- Mock successful gh api response\n- Mock gh not installed\n- Mock gh not authenticated\n\n## Files to Create\n- src/github/api.ts\n\n## Acceptance Criteria\n- [ ] Returns GitHub username\n- [ ] Clear error if gh not installed\n- [ ] Clear error if gh not authenticated\n- [ ] Error messages include remediation steps","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T14:27:02.008649-05:00","updated_at":"2025-12-26T23:29:21.498338-05:00","closed_at":"2025-12-26T23:29:21.498338-05:00","close_reason":"Implemented and tested","dependencies":[{"issue_id":"taspr-bvy","depends_on_id":"taspr-osw","type":"parent-child","created_at":"2025-12-25T14:27:05.694237-05:00","created_by":"daemon"}]}
{"id":"taspr-bwi","title":"PR merge via GitHub API","description":"## Goal\nMerge a PR using the GitHub API via gh CLI.\n\n## Implementation\n\n```typescript\n// src/github/pr.ts\n\ntype MergeMethod = 'merge' | 'squash' | 'rebase';\n\ninterface MergeResult {\n  sha: string;      // Merge commit SHA\n  merged: boolean;\n}\n\nasync function mergePR(\n  prNumber: number,\n  method?: MergeMethod\n): Promise\u003cMergeResult\u003e {\n  // Use gh CLI to merge\n  const methodFlag = method ? \\`--\\${method}\\` : '';\n  \n  const result = await $\\`gh pr merge \\${prNumber} \\${methodFlag} --json sha,state\\`.nothrow();\n  \n  if (result.exitCode !== 0) {\n    const error = result.stderr.toString();\n    if (error.includes('not mergeable')) {\n      throw new PRNotMergeableError(prNumber);\n    }\n    throw new GitHubAPIError(\\`Failed to merge PR #\\${prNumber}: \\${error}\\`);\n  }\n  \n  const data = JSON.parse(result.stdout.toString());\n  return { sha: data.sha, merged: true };\n}\n```\n\n### Checking Mergeability\n```typescript\ninterface PRMergeStatus {\n  mergeable: boolean;\n  mergeableState: string;\n  checksStatus: 'pending' | 'passing' | 'failing';\n  reviewDecision: 'approved' | 'review_required' | 'changes_requested';\n}\n\nasync function getPRMergeStatus(prNumber: number): Promise\u003cPRMergeStatus\u003e {\n  const result = await $\\`gh pr view \\${prNumber} --json mergeable,mergeStateStatus,reviewDecision,statusCheckRollup\\`;\n  const data = JSON.parse(result.stdout.toString());\n  \n  return {\n    mergeable: data.mergeable === 'MERGEABLE',\n    mergeableState: data.mergeStateStatus,\n    checksStatus: getChecksStatus(data.statusCheckRollup),\n    reviewDecision: data.reviewDecision?.toLowerCase() || 'review_required',\n  };\n}\n```\n\n## Error Handling\n- PR not found â†’ clear error\n- PR not mergeable â†’ explain why (conflicts, checks, reviews)\n- Network error â†’ retry logic\n\n## Testing\n- Successful merge\n- Merge blocked by checks\n- Merge blocked by reviews\n- Merge blocked by conflicts\n\n## Files to Modify\n- src/github/pr.ts\n\n## Acceptance Criteria\n- [ ] Merges PR via gh CLI\n- [ ] Returns merge commit SHA\n- [ ] Clear errors for non-mergeable PRs\n- [ ] Respects repo's merge settings","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T14:30:56.060186-05:00","updated_at":"2025-12-30T00:47:30.077665-05:00","closed_at":"2025-12-30T00:47:30.077665-05:00","close_reason":"Implemented landPR() function that fast-forwards target branch to PR head commit, preserving commit hashes. Uses git push directly instead of GitHub merge API. Includes canFastForward check and deleteRemoteBranch helper.","dependencies":[{"issue_id":"taspr-bwi","depends_on_id":"taspr-6le","type":"parent-child","created_at":"2025-12-25T14:30:59.702866-05:00","created_by":"daemon"}]}
{"id":"taspr-cv0","title":"Implement squash-resilient group markers","description":"## Summary\n\nReplace `Taspr-Group-Start`/`Taspr-Group-End` markers with redundant markers on ALL commits in a group for squash resilience.\n\n## Solution\n\nEvery commit in a group gets **both**:\n- `Taspr-Group: \u003cgroupId\u003e`\n- `Taspr-Group-Title: \u003ctitle\u003e`\n\nNo Start/End markers needed. Group ends when we encounter a commit without the same group marker.\n\n**Why this works:**\n- Squashing any commits leaves remaining commits with their group trailers\n- Title on every commit means no fallback logic needed\n- Detection is simpler: contiguous commits with same `Taspr-Group` = one group\n\n## Files to Modify\n\n1. **src/git/trailers.ts** - Add `Taspr-Group`, remove `Taspr-Group-Start`/`End`\n2. **src/types.ts** - Add `split-group` and `inconsistent-group-title` errors, remove old errors\n3. **src/core/stack.ts** - Rewrite detection: group = contiguous commits with same `Taspr-Group`\n4. **src/git/group-rebase.ts** - Add both trailers to ALL commits, remove old helpers\n5. **src/cli/commands/group.ts** - Update `--fix` for new error types\n6. **src/tui/group-editor.ts** - Detect groups by `Taspr-Group` trailer\n7. **src/cli/output.ts** - Error messages for new types\n8. **Tests** - Update all group-related tests\n9. **README.md** - Update docs, remove FIXUP_GROUP_DOCS marker\n\n## Implementation Order\n\n1. trailers.ts - Add/remove trailer types\n2. types.ts - Add new error types\n3. stack.ts - Update detection\n4. group-rebase.ts - Update group creation\n5. group.ts + group-editor.ts - Update CLI/TUI\n6. output.ts - Update error messages\n7. Tests\n8. README.md\n\n## Acceptance Criteria\n\n- [ ] Squashing fixup! commits doesn't break group integrity\n- [ ] Clear error for split groups (non-contiguous commits with same ID)\n- [ ] Clear error for inconsistent group titles\n- [ ] `taspr group --fix` can repair split groups and inconsistent titles\n- [ ] Documentation updated (remove FIXUP_GROUP_DOCS marker)\n\nFull plan: ~/.claude/plans/binary-mapping-haven.md","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-03T21:24:54.549773-05:00","updated_at":"2026-01-03T21:53:33.115258-05:00","closed_at":"2026-01-03T21:53:33.115258-05:00","close_reason":"Implemented squash-resilient group markers. Replaced Taspr-Group-Start/End with Taspr-Group+Taspr-Group-Title on ALL commits in a group. Updated all related code, tests, and scenarios.","dependencies":[{"issue_id":"taspr-cv0","depends_on_id":"taspr-b3e","type":"discovered-from","created_at":"2026-01-03T21:25:01.758401-05:00","created_by":"dondenton"}]}
{"id":"taspr-d55","title":"Group rebase logic","description":"## Goal\nImplement the rebase logic that reorders commits and adds group trailers after the user confirms their arrangement in the TUI.\n\n## Context\nThis is part of Epic 7: Group Management. After the user arranges commits and assigns groups in the TUI, this module performs the actual git operations:\n1. Reorder commits via interactive rebase\n2. Add group trailers (Taspr-Group-Start, Taspr-Group-Title, Taspr-Group-End) to appropriate commits\n\n## Implementation\n\n### Main Function\n```typescript\ninterface GroupAssignment {\n  commits: string[];  // Commit hashes in this group\n  name: string;       // User-provided group name\n}\n\ninterface ReorderResult {\n  success: boolean;\n  error?: string;\n  conflictFile?: string;\n}\n\nasync function reorderAndGroup(\n  originalOrder: string[],      // Original commit hashes (oldest first)\n  newOrder: string[],           // New commit order\n  groups: GroupAssignment[],    // Groups with their commits and names\n  options: GitOptions = {}\n): Promise\u003cReorderResult\u003e {\n  // 1. Check if reorder is needed\n  const needsReorder = !arraysEqual(originalOrder, newOrder);\n  \n  // 2. Perform rebase to reorder (if needed)\n  if (needsReorder) {\n    const rebaseResult = await rebaseToReorder(originalOrder, newOrder, options);\n    if (!rebaseResult.success) {\n      return rebaseResult;\n    }\n  }\n  \n  // 3. Add group trailers\n  for (const group of groups) {\n    await addGroupTrailers(group.commits, group.name, options);\n  }\n  \n  return { success: true };\n}\n```\n\n### Reordering via Interactive Rebase\n```typescript\nasync function rebaseToReorder(\n  originalOrder: string[],\n  newOrder: string[],\n  options: GitOptions = {}\n): Promise\u003cReorderResult\u003e {\n  const { cwd } = options;\n  const mergeBase = await getMergeBase(options);\n  \n  // Create a sequence editor script that outputs the new order\n  const todoScript = createReorderTodoScript(newOrder);\n  const scriptPath = join(tmpdir(), \\`taspr-reorder-\\${Date.now()}.sh\\`);\n  \n  try {\n    await writeFile(scriptPath, todoScript);\n    await chmod(scriptPath, '755');\n    \n    // Run interactive rebase with custom sequence editor\n    const result = cwd\n      ? await \\$\\`GIT_SEQUENCE_EDITOR=\\${scriptPath} git -C \\${cwd} rebase -i \\${mergeBase}\\`\n          .quiet().nothrow()\n      : await \\$\\`GIT_SEQUENCE_EDITOR=\\${scriptPath} git rebase -i \\${mergeBase}\\`\n          .quiet().nothrow();\n    \n    if (result.exitCode !== 0) {\n      // Check for conflict\n      const conflictInfo = await getConflictInfo(options);\n      if (conflictInfo) {\n        return { \n          success: false, \n          error: 'Rebase conflict',\n          conflictFile: conflictInfo.files[0]\n        };\n      }\n      return { success: false, error: result.stderr.toString() };\n    }\n    \n    return { success: true };\n  } finally {\n    await unlink(scriptPath).catch(() =\u003e {});\n  }\n}\n\nfunction createReorderTodoScript(newOrder: string[]): string {\n  // Script that rewrites the todo file with commits in new order\n  return \\`#!/bin/bash\nset -e\nTODO_FILE=\"\\$1\"\n\n# Write new order\ncat \u003e \"\\$TODO_FILE\" \u003c\u003c 'TODOEOF'\n\\${newOrder.map(hash =\u003e \\`pick \\${hash}\\`).join('\\n')}\nTODOEOF\n\\`;\n}\n```\n\n### Adding Group Trailers\n```typescript\nasync function addGroupTrailers(\n  commits: string[],\n  groupName: string,\n  options: GitOptions = {}\n): Promise\u003cvoid\u003e {\n  const groupId = generateId();  // 8-char hex like existing Taspr-Commit-Id\n  \n  const first = commits[0];\n  const last = commits[commits.length - 1];\n  \n  // Add Start and Title to first commit\n  await addTrailersToCommit(first, {\n    'Taspr-Group-Start': groupId,\n    'Taspr-Group-Title': groupName,\n  }, options);\n  \n  // Add End to last commit (handles single-commit groups too)\n  await addTrailersToCommit(last, {\n    'Taspr-Group-End': groupId,\n  }, options);\n}\n\nasync function addTrailersToCommit(\n  hash: string,\n  trailers: Record\u003cstring, string\u003e,\n  options: GitOptions = {}\n): Promise\u003cvoid\u003e {\n  // Use git rebase --exec to amend the specific commit\n  // Pattern from src/git/rebase.ts injectMissingIds()\n}\n```\n\n## Group Trailers Format\n- First commit in group: \\`Taspr-Group-Start: \u003cid\u003e\\`, \\`Taspr-Group-Title: \u003cname\u003e\\`\n- Last commit in group: \\`Taspr-Group-End: \u003cid\u003e\\`\n- Single-commit groups: both Start/Title and End on same commit\n\n## Existing Patterns to Follow\nSee `src/git/rebase.ts`:\n- `injectMissingIds()` - pattern for `git rebase -i --exec` with temp scripts\n- `rebaseOntoMain()` - pattern for rebase with conflict detection\n- `getConflictInfo()` - pattern for detecting rebase conflicts\n\n## Files to Create\n- src/git/group-rebase.ts\n\n## Testing\n- Unit tests for reorder detection\n- Unit tests for todo script generation\n- Integration tests for actual rebase operations\n- Test single-commit groups\n- Test conflict handling (abort and restore)\n\n## Edge Cases\n1. **No reorder needed**: Skip rebase, just add trailers\n2. **Single-commit group**: Both Start and End on same commit\n3. **Rebase conflict**: Abort rebase, restore original state, return error\n4. **Empty groups**: Should not happen (TUI prevents), but handle gracefully\n\n## Acceptance Criteria\n- [ ] Reorders commits via interactive rebase\n- [ ] Adds correct trailers to correct commits\n- [ ] Handles single-commit groups\n- [ ] Detects and reports rebase conflicts\n- [ ] Aborts cleanly on failure\n- [ ] Preserves existing Taspr-Commit-Id trailers","notes":"## Testing Workflow\nAfter completing implementation:\n1. Run `bun run build` to build the CLI\n2. Run `bun test --no-coverage` to verify all tests pass\n3. Tell the user to run `bun run scenario` and select one of these scenarios for manual testing:\n   - **multiCommitStack** - 3 commits on feature branch (best for testing reorder)\n   - **withTasprIds** - 2 commits with existing Taspr-Commit-Id trailers\n   - **mixedTrailerStack** - some commits have IDs, some don't\n\n## Scenario Usage\nThe `bun run scenario` command spawns a shell in a temp git repo with `taspr` in PATH. Use this to manually verify the rebase logic works correctly. After testing, type `exit` to clean up.\n\n## New Scenarios Needed\nIf testing reveals gaps, consider adding scenarios to `src/scenario/definitions.ts`:\n- A scenario with existing group trailers (for testing group modification)","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-01T22:48:40.229535-05:00","updated_at":"2026-01-02T10:33:48.807287-05:00","closed_at":"2026-01-02T10:33:48.807287-05:00","close_reason":"Closed","dependencies":[{"issue_id":"taspr-d55","depends_on_id":"taspr-7mu","type":"parent-child","created_at":"2026-01-01T22:48:51.95459-05:00","created_by":"daemon"}]}
{"id":"taspr-d6b","title":"Conflict detection and reporting","description":"## Goal\nDetect rebase conflicts and provide clear instructions for resolution.\n\n## Implementation\n\n```typescript\n// src/git/rebase.ts\n\ninterface ConflictInfo {\n  files: string[];\n  currentCommit: string;\n  currentSubject: string;\n}\n\nasync function getConflictInfo(): Promise\u003cConflictInfo | null\u003e {\n  // Check if we're in a rebase\n  const rebaseDir = await $\\`git rev-parse --git-path rebase-merge\\`.text();\n  const exists = await Bun.file(rebaseDir.trim()).exists();\n  \n  if (!exists) return null;\n  \n  // Get conflicting files\n  const status = await $\\`git status --porcelain\\`.text();\n  const conflicts = status\n    .split('\\n')\n    .filter(line =\u003e line.startsWith('UU ') || line.startsWith('AA '))\n    .map(line =\u003e line.slice(3));\n  \n  // Get current commit being rebased\n  const head = await $\\`git rev-parse HEAD\\`.text();\n  const subject = await $\\`git log -1 --format=%s HEAD\\`.text();\n  \n  return {\n    files: conflicts,\n    currentCommit: head.trim().slice(0, 8),\n    currentSubject: subject.trim(),\n  };\n}\n```\n\n### Error Message\n```typescript\nfunction formatConflictError(info: ConflictInfo): string {\n  return \\`\nâœ— Rebase conflict while applying commit \\${info.currentCommit}\n  \"\\${info.currentSubject}\"\n\nConflicting files:\n\\${info.files.map(f =\u003e \\`  â€¢ \\${f}\\`).join('\\n')}\n\nTo resolve:\n  1. Edit the conflicting files\n  2. git add \u003cfixed files\u003e\n  3. git rebase --continue\n  4. taspr sync\n\nTo abort:\n  git rebase --abort\n\\`.trim();\n}\n```\n\n## Testing\n- Detect conflict in progress\n- List all conflicting files\n- Clear resolution instructions\n\n## Files to Modify\n- src/git/rebase.ts\n- src/cli/output.ts\n\n## Acceptance Criteria\n- [ ] Detects ongoing rebase conflict\n- [ ] Lists conflicting files\n- [ ] Shows which commit is being applied\n- [ ] Provides clear resolution steps","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-25T14:36:43.502623-05:00","updated_at":"2025-12-31T14:12:02.338606-05:00","closed_at":"2025-12-31T14:12:02.338606-05:00","close_reason":"Added getConflictInfo() and formatConflictError() functions. All 4 new tests passing.","dependencies":[{"issue_id":"taspr-d6b","depends_on_id":"taspr-a64","type":"parent-child","created_at":"2025-12-25T14:36:47.54253-05:00","created_by":"daemon"},{"issue_id":"taspr-d6b","depends_on_id":"taspr-gs1","type":"blocks","created_at":"2025-12-25T14:36:47.822256-05:00","created_by":"daemon"},{"issue_id":"taspr-d6b","depends_on_id":"taspr-gs1","type":"depends-on","created_at":"2025-12-25T14:36:47.822256-05:00","created_by":"daemon"}]}
{"id":"taspr-d6u","title":"Fetch PR checks status","description":"## Goal\nGet CI check status for PRs.\n\n## Implementation\n\n```typescript\n// src/github/pr.ts\n\ntype ChecksStatus = 'pending' | 'passing' | 'failing';\n\nasync function getPRChecksStatus(prNumber: number): Promise\u003cChecksStatus\u003e {\n  const result = await $\\`gh pr checks \\${prNumber} --json state\\`;\n  const checks = JSON.parse(result.stdout.toString());\n  \n  const states = checks.map((c: any) =\u003e c.state);\n  \n  if (states.some((s: string) =\u003e s === 'FAILURE')) return 'failing';\n  if (states.some((s: string) =\u003e s === 'PENDING')) return 'pending';\n  return 'passing';\n}\n```\n\n## Alternative: gh pr view\n```typescript\nasync function getPRChecksStatus(prNumber: number): Promise\u003cChecksStatus\u003e {\n  const result = await $\\`gh pr view \\${prNumber} --json statusCheckRollup\\`;\n  const data = JSON.parse(result.stdout.toString());\n  \n  // statusCheckRollup contains aggregated status\n  const rollup = data.statusCheckRollup;\n  \n  if (rollup.some((c: any) =\u003e c.conclusion === 'FAILURE')) return 'failing';\n  if (rollup.some((c: any) =\u003e c.status === 'IN_PROGRESS')) return 'pending';\n  return 'passing';\n}\n```\n\n## Testing\n- PR with passing checks\n- PR with failing checks\n- PR with pending checks\n- PR with no checks configured\n\n## Files to Modify\n- src/github/pr.ts\n\n## Acceptance Criteria\n- [ ] Returns passing/failing/pending status\n- [ ] Handles PRs without checks\n- [ ] Works with various CI providers","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-25T14:32:24.225276-05:00","updated_at":"2025-12-31T11:37:23.143026-05:00","closed_at":"2025-12-31T11:37:23.143026-05:00","close_reason":"Implemented getPRChecksStatus function with shared determineChecksStatus helper. Added optional repo parameter for cross-repo queries. Unit tests cover all status states (none, pending, passing, failing). Integration tests verify all four states: passing CI, failing CI, pending CI, and no CI (by removing the workflow file in the PR).","dependencies":[{"issue_id":"taspr-d6u","depends_on_id":"taspr-v0c","type":"parent-child","created_at":"2025-12-25T14:32:27.950028-05:00","created_by":"daemon"}]}
{"id":"taspr-dbl","title":"Refactor tests to reduce repetition with helper functions","description":"The test files contain a lot of repetitive code that could be extracted into reusable helper functions. This would make tests easier to write and maintain.\n\n## Examples of repetition to address\n- Setting up test repositories\n- Creating commits with trailers\n- Mocking GitHub API responses\n- Common assertions\n\n## Acceptance Criteria\n- [ ] Identify common patterns across test files\n- [ ] Create test helper module(s)\n- [ ] Refactor existing tests to use helpers\n- [ ] Tests still pass after refactoring","status":"closed","priority":3,"issue_type":"task","created_at":"2025-12-31T14:39:29.230176-05:00","updated_at":"2025-12-31T14:58:00.031368-05:00","closed_at":"2025-12-31T14:58:00.031368-05:00","close_reason":"Refactored 11 test files to use new helpers: fixtureManager() for automatic cleanup, updateOriginMain() for simulating other developer's work. Made createGitFixture() private. All 164 tests pass."}
{"id":"taspr-de7","title":"PR creation via gh CLI","description":"## Goal\nCreate GitHub PRs for PRUnits using the gh CLI.\n\n## Implementation\n\n```typescript\n// src/github/pr.ts\n\ninterface CreatePROptions {\n  title: string;\n  head: string;      // Branch name for this PR\n  base: string;      // Parent branch or main\n  body?: string;\n}\n\nasync function createPR(options: CreatePROptions): Promise\u003c{ number: number; url: string }\u003e {\n  const result = await $\\`gh pr create \n    --title ${options.title}\n    --head ${options.head}\n    --base ${options.base}\n    --body ${options.body || ''}\n  \\`.json();\n  \n  return {\n    number: result.number,\n    url: result.url,\n  };\n}\n```\n\n### Stack Structure\nFor a stack [A, B, C] (bottom to top):\n```\nPR for A: base = main,     head = taspr/user/a-id\nPR for B: base = A's head, head = taspr/user/b-id\nPR for C: base = B's head, head = taspr/user/c-id\n```\n\n```typescript\nasync function createStackPRs(\n  units: PRUnit[], \n  branches: Map\u003cstring, string\u003e,\n  defaultBranch: string\n): Promise\u003cMap\u003cstring, { number: number; url: string }\u003e\u003e {\n  const prs = new Map();\n  \n  let baseBranch = defaultBranch;\n  \n  for (const unit of units) {\n    const headBranch = branches.get(unit.id)!;\n    \n    const pr = await createPR({\n      title: unit.title,\n      head: headBranch,\n      base: baseBranch,\n    });\n    \n    prs.set(unit.id, pr);\n    baseBranch = headBranch; // Next PR bases on this one\n  }\n  \n  return prs;\n}\n```\n\n### Default Branch Detection\n```typescript\nasync function getDefaultBranch(): Promise\u003cstring\u003e {\n  // Try git config first\n  const configResult = await $\\`git config --get taspr.defaultBranch\\`.nothrow();\n  if (configResult.exitCode === 0) {\n    return configResult.stdout.toString().trim();\n  }\n  \n  // Fall back to origin's default\n  const remote = await $\\`git remote show origin\\`.text();\n  const match = remote.match(/HEAD branch: (\\S+)/);\n  return match?.[1] || 'main';\n}\n```\n\n### PR Body\nFor now, minimal body. Later can add stack visualization:\n\n```typescript\nfunction generatePRBody(unit: PRUnit): string {\n  if (unit.type === 'single') {\n    return ''; // Use commit message\n  }\n  \n  // For groups, list commits\n  return `## Commits\\n${unit.commits.map(c =\u003e `- ${c}`).join('\\n')}`;\n}\n```\n\n## Edge Cases\n1. **PR already exists**: Don't create duplicate (handled by lookup task)\n2. **Base branch doesn't exist**: Error (shouldn't happen if we push in order)\n3. **Rate limiting**: Retry logic\n\n## Testing\n- Create single PR\n- Create stacked PRs with correct base/head\n- Verify titles match PRUnit titles\n\n## Files to Create\n- src/github/pr.ts\n\n## Acceptance Criteria\n- [ ] Creates PR with correct title\n- [ ] Sets correct base/head branches\n- [ ] Returns PR number and URL\n- [ ] PRs form correct stack (each bases on previous)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T14:27:38.225862-05:00","updated_at":"2025-12-26T23:29:21.528274-05:00","closed_at":"2025-12-26T23:29:21.528274-05:00","close_reason":"Implemented and tested","dependencies":[{"issue_id":"taspr-de7","depends_on_id":"taspr-osw","type":"parent-child","created_at":"2025-12-25T14:27:41.917963-05:00","created_by":"daemon"},{"issue_id":"taspr-de7","depends_on_id":"taspr-n48","type":"blocks","created_at":"2025-12-25T14:27:42.19973-05:00","created_by":"daemon"},{"issue_id":"taspr-de7","depends_on_id":"taspr-n48","type":"depends-on","created_at":"2025-12-25T14:27:42.19973-05:00","created_by":"daemon"}]}
{"id":"taspr-e6f","title":"Fetch PR comment threads","description":"## Goal\nGet comment thread resolution status for PRs.\n\n## Implementation\n\n```typescript\n// src/github/pr.ts\n\ninterface CommentStatus {\n  total: number;\n  resolved: number;\n}\n\nasync function getPRCommentStatus(prNumber: number): Promise\u003cCommentStatus\u003e {\n  const result = await $\\`gh api repos/{owner}/{repo}/pulls/\\${prNumber}/comments --jq 'length'\\`;\n  const total = parseInt(result.stdout.toString().trim(), 10);\n  \n  // GraphQL needed for resolved count\n  const query = \\`\n    query {\n      repository(owner: \"{owner}\", name: \"{repo}\") {\n        pullRequest(number: \\${prNumber}) {\n          reviewThreads(first: 100) {\n            nodes {\n              isResolved\n            }\n          }\n        }\n      }\n    }\n  \\`;\n  \n  const gqlResult = await $\\`gh api graphql -f query='\\${query}'\\`;\n  const threads = JSON.parse(gqlResult.stdout.toString())\n    .data.repository.pullRequest.reviewThreads.nodes;\n  \n  const resolved = threads.filter((t: any) =\u003e t.isResolved).length;\n  \n  return { total: threads.length, resolved };\n}\n```\n\n## Display\n```\nğŸ’¬ 3/5  # 3 of 5 threads resolved\n```\n\nWhen all resolved, don't show indicator.\n\n## Testing\n- PR with unresolved threads\n- PR with all threads resolved\n- PR with no review threads\n\n## Files to Modify\n- src/github/pr.ts\n\n## Acceptance Criteria\n- [ ] Returns thread count and resolved count\n- [ ] Uses GraphQL API for resolution status\n- [ ] Handles PRs without review threads","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-25T14:32:47.011606-05:00","updated_at":"2025-12-31T13:36:01.842102-05:00","closed_at":"2025-12-31T13:36:01.842102-05:00","close_reason":"Implemented getPRCommentStatus function with GraphQL API, added unit tests for computeCommentStatus, and integration tests for PR comment thread resolution status","dependencies":[{"issue_id":"taspr-e6f","depends_on_id":"taspr-v0c","type":"parent-child","created_at":"2025-12-25T14:32:50.920704-05:00","created_by":"daemon"}]}
{"id":"taspr-eik","title":"Change detection (local vs remote)","description":"## Goal\nDetect when local commits have changed relative to their remote branches.\n\n## Implementation\n\n```typescript\n// src/git/remote.ts\n\nasync function getRemoteBranchCommit(branchName: string): Promise\u003cstring | null\u003e {\n  // Fetch latest (optional - can skip for performance)\n  // await $\\`git fetch origin ${branchName}\\`.nothrow();\n  \n  const result = await $\\`git rev-parse origin/${branchName}\\`.nothrow();\n  if (result.exitCode !== 0) {\n    return null; // Branch doesn't exist on remote\n  }\n  return result.stdout.toString().trim();\n}\n\ninterface SyncStatus {\n  branchName: string;\n  localCommit: string;\n  remoteCommit: string | null;\n  needsUpdate: boolean;\n  needsCreate: boolean;\n}\n\nasync function getSyncStatus(unit: PRUnit, branchName: string): Promise\u003cSyncStatus\u003e {\n  const localCommit = unit.commits[unit.commits.length - 1];\n  const remoteCommit = await getRemoteBranchCommit(branchName);\n  \n  return {\n    branchName,\n    localCommit,\n    remoteCommit,\n    needsUpdate: remoteCommit !== null \u0026\u0026 remoteCommit !== localCommit,\n    needsCreate: remoteCommit === null,\n  };\n}\n```\n\n### Batch Status Check\n```typescript\nasync function getAllSyncStatuses(\n  units: PRUnit[], \n  config: BranchNameConfig\n): Promise\u003cMap\u003cstring, SyncStatus\u003e\u003e {\n  const statuses = new Map();\n  \n  for (const unit of units) {\n    const branch = getBranchName(unit.id, config);\n    const status = await getSyncStatus(unit, branch);\n    statuses.set(unit.id, status);\n  }\n  \n  return statuses;\n}\n```\n\n## Usage in Sync\n```typescript\nconst statuses = await getAllSyncStatuses(units, config);\n\nfor (const [id, status] of statuses) {\n  if (status.needsCreate) {\n    // Push new branch, create PR\n  } else if (status.needsUpdate) {\n    // Force push updated branch\n  } else {\n    // No change needed\n  }\n}\n```\n\n## Edge Cases\n1. **Branch doesn't exist**: needsCreate = true\n2. **Branch up to date**: needsUpdate = false\n3. **Branch behind**: needsUpdate = true\n\n## Testing\n- Local matches remote â†’ no update needed\n- Local differs from remote â†’ update needed\n- Remote branch doesn't exist â†’ create needed\n\n## Files to Create\n- src/git/remote.ts\n\n## Acceptance Criteria\n- [ ] Detects when local differs from remote\n- [ ] Detects when branch doesn't exist\n- [ ] Handles fetch errors gracefully","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T14:29:23.93778-05:00","updated_at":"2025-12-29T20:55:34.614871-05:00","closed_at":"2025-12-29T20:55:34.614876-05:00","dependencies":[{"issue_id":"taspr-eik","depends_on_id":"taspr-1ni","type":"parent-child","created_at":"2025-12-25T14:29:27.510279-05:00","created_by":"daemon"}]}
{"id":"taspr-euc","title":"Add story logging to sync.test.ts","description":"Read the parent epic taspr-ww0 for full context.\n\n## Task\nAdd story logging annotations to tests/integration/sync.test.ts as the first integration test file.\n\n## Pattern\n\n1. Import and create story at describe level:\n```\nimport { createStory } from \"../helpers/story.ts\";\n\ndescribe(\"sync command\", () =\u003e {\n  const story = createStory(\"sync.test.ts\");\n\n  afterAll(async () =\u003e {\n    await story.flush();\n  });\n  ...\n});\n```\n\n2. For each test, add story annotations:\n```\ntest(\"test name\", async () =\u003e {\n  story.begin(\"test name\");\n  story.narrate(\"Plain English description of the scenario...\");\n\n  // ... test setup (no logging needed) ...\n\n  const result = await runSync(repo.path, { open: true });\n  story.log(result);\n  story.end();\n\n  // ... assertions ...\n});\n```\n\n## Guidelines\n- Narratives describe scenarios contextually, not mechanically\n- Focus on what is being demonstrated\n- Err on showing less - only log the key command output\n- Setup steps dont need to be logged unless they add clarity\n\n## Files\n- tests/integration/sync.test.ts\n\n## Acceptance\n- All tests in sync.test.ts have story annotations\n- Running TASPR_STORY_TEST_LOGGING=1 bun test tests/integration/sync.test.ts produces test-logs/sync.md and test-logs/sync.ansi","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T00:33:20.666806-05:00","updated_at":"2026-01-05T00:33:20.666806-05:00","dependencies":[{"issue_id":"taspr-euc","depends_on_id":"taspr-ww0","type":"parent-child","created_at":"2026-01-05T00:33:43.894204-05:00","created_by":"dondenton"},{"issue_id":"taspr-euc","depends_on_id":"taspr-ycg","type":"blocks","created_at":"2026-01-05T00:33:48.15932-05:00","created_by":"dondenton"}]}
{"id":"taspr-ffp","title":"Add story logging to remaining integration tests","description":"Read the parent epic taspr-ww0 for full context.\n\n## Task\nAdd story logging to the remaining integration test files, following the pattern established in sync.test.ts (taspr-euc).\n\n## Files to Update\n- tests/integration/land.test.ts\n- tests/integration/clean.test.ts  \n- tests/integration/group-fix.test.ts\n- tests/integration/pr-status.test.ts\n\n## Pattern\nSame as sync.test.ts - see taspr-euc for the exact pattern.\n\n## Acceptance\n- All integration test files have story annotations\n- Running TASPR_STORY_TEST_LOGGING=1 bun test tests/integration/ produces markdown files for each test file","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-05T00:33:28.022045-05:00","updated_at":"2026-01-05T00:33:28.022045-05:00","dependencies":[{"issue_id":"taspr-ffp","depends_on_id":"taspr-ww0","type":"parent-child","created_at":"2026-01-05T00:33:43.937679-05:00","created_by":"dondenton"},{"issue_id":"taspr-ffp","depends_on_id":"taspr-euc","type":"blocks","created_at":"2026-01-05T00:33:48.205808-05:00","created_by":"dondenton"}]}
{"id":"taspr-fli","title":"Installation script - curl | bash installer","description":"## Goal\nCreate a simple installation script that users can run via `curl | bash` to install taspr.\n\n## Installation Command\n\n```bash\ncurl -fsSL https://raw.githubusercontent.com/OWNER/taspr/main/install.sh | bash\n```\n\n## Installation Script\n\n```bash\n#\\!/bin/bash\n# install.sh - Install taspr CLI\n\nset -euo pipefail\n\n# Configuration\nREPO=\"OWNER/taspr\"\nINSTALL_DIR=\"${INSTALL_DIR:-$HOME/.local/bin}\"\n\n# Detect platform\nOS=\"$(uname -s | tr '[:upper:]' '[:lower:]')\"\nARCH=\"$(uname -m)\"\n\ncase \"$OS\" in\n  darwin) OS=\"darwin\" ;;\n  linux) OS=\"linux\" ;;\n  *) echo \"Error: Unsupported OS: $OS\"; exit 1 ;;\nesac\n\ncase \"$ARCH\" in\n  x86_64) ARCH=\"x64\" ;;\n  amd64) ARCH=\"x64\" ;;\n  arm64) ARCH=\"arm64\" ;;\n  aarch64) ARCH=\"arm64\" ;;\n  *) echo \"Error: Unsupported architecture: $ARCH\"; exit 1 ;;\nesac\n\nBINARY=\"taspr-${OS}-${ARCH}\"\n\n# Get latest release\necho \"Fetching latest release...\"\nLATEST_TAG=$(curl -fsSL \"https://api.github.com/repos/$REPO/releases/latest\" | grep '\"tag_name\":' | sed -E 's/.*\"([^\"]+)\".*/\\1/')\n\nif [ -z \"$LATEST_TAG\" ]; then\n  echo \"Error: Could not determine latest release\"\n  exit 1\nfi\n\necho \"Installing taspr $LATEST_TAG for $OS/$ARCH...\"\n\n# Download binary\nDOWNLOAD_URL=\"https://github.com/$REPO/releases/download/$LATEST_TAG/$BINARY\"\nTMP_FILE=\"$(mktemp)\"\n\ncurl -fsSL \"$DOWNLOAD_URL\" -o \"$TMP_FILE\"\n\n# Create install directory if needed\nmkdir -p \"$INSTALL_DIR\"\n\n# Install binary\nchmod +x \"$TMP_FILE\"\nmv \"$TMP_FILE\" \"$INSTALL_DIR/taspr\"\n\necho \"\"\necho \"âœ“ taspr installed to $INSTALL_DIR/taspr\"\necho \"\"\n\n# Check if install dir is in PATH\nif [[ \":$PATH:\" \\!= *\":$INSTALL_DIR:\"* ]]; then\n  echo \"âš  $INSTALL_DIR is not in your PATH\"\n  echo \"\"\n  echo \"Add it to your shell config:\"\n  echo \"  echo 'export PATH=\\\"$INSTALL_DIR:\\$PATH\\\"' \u003e\u003e ~/.bashrc\"\n  echo \"  # or for zsh:\"\n  echo \"  echo 'export PATH=\\\"$INSTALL_DIR:\\$PATH\\\"' \u003e\u003e ~/.zshrc\"\n  echo \"\"\nfi\n\n# Verify installation\nif command -v taspr \u0026\u003e /dev/null; then\n  echo \"Installed version:\"\n  taspr --version\nelse\n  echo \"Run 'taspr --version' to verify installation\"\nfi\n\necho \"\"\necho \"Prerequisites:\"\necho \"  - git (you probably have this)\"\necho \"  - gh CLI (https://cli.github.com)\"\necho \"\"\necho \"Quick start:\"\necho \"  cd your-repo\"\necho \"  taspr view    # See your stack\"\necho \"  taspr sync    # Push to GitHub\"\n```\n\n## Alternative: npm/bunx Installation\n\nFor users who prefer npm/bun:\n\n```json\n// package.json\n{\n  \"name\": \"taspr\",\n  \"version\": \"0.1.0\",\n  \"bin\": {\n    \"taspr\": \"./dist/taspr\"\n  },\n  \"files\": [\n    \"dist/taspr\"\n  ]\n}\n```\n\n```bash\n# Global install via npm\nnpm install -g taspr\n\n# Or run without installing\nnpx taspr view\nbunx taspr view\n```\n\n## Uninstall Script\n\n```bash\n#\\!/bin/bash\n# uninstall.sh\n\nrm -f \"${INSTALL_DIR:-$HOME/.local/bin}/taspr\"\necho \"âœ“ taspr uninstalled\"\n```\n\n## Version Check / Update\n\nThe CLI could include update checking:\n```typescript\n// Check for updates (run occasionally, not every command)\nasync function checkForUpdates() {\n  const current = VERSION;\n  const latest = await fetchLatestVersion();\n  \n  if (semver.gt(latest, current)) {\n    console.log(`Update available: ${current} â†’ ${latest}`);\n    console.log('Run: curl -fsSL https://example.com/install.sh | bash');\n  }\n}\n```\n\n## Security Considerations\n\n- Script should verify checksums if we provide them\n- Use HTTPS for all downloads\n- Consider signing binaries (future enhancement)\n\n## Acceptance Criteria\n- [ ] install.sh works on macOS (Intel and Apple Silicon)\n- [ ] install.sh works on Linux (x64 and ARM64)\n- [ ] Script detects platform automatically\n- [ ] Script downloads correct binary from GitHub releases\n- [ ] Script provides PATH guidance if needed\n- [ ] Script verifies installation with --version\n- [ ] Prerequisites (git, gh) are clearly documented\n- [ ] Uninstall instructions provided","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-25T15:00:34.84736-05:00","updated_at":"2025-12-25T15:00:34.84736-05:00","dependencies":[{"issue_id":"taspr-fli","depends_on_id":"taspr-8iv","type":"parent-child","created_at":"2025-12-25T15:01:37.614674-05:00","created_by":"daemon"}]}
{"id":"taspr-fwm","title":"Trailer writing (add/update trailers)","description":"## Goal\nAdd the ability to write trailers to commit messages, not just read them.\n\n## Background\nEpic 1 implemented trailer reading. Now we need to write trailers:\n- Add new trailers to commits\n- Preserve existing trailers\n\n## Implementation\n\n### Using git interpret-trailers\n```bash\n# Add a trailer to a message\necho \"commit message\" | git interpret-trailers --trailer \"Taspr-Commit-Id: a1b2c3d4\"\n\n# Add multiple trailers\necho \"commit message\" | git interpret-trailers \\\n  --trailer \"Taspr-Commit-Id: a1b2c3d4\" \\\n  --trailer \"Taspr-Group-Start: f7e8d9c0\"\n```\n\n### Function Signatures\n```typescript\n// src/git/trailers.ts\n\n// Add trailers to a message string\nexport function addTrailers(\n  message: string, \n  trailers: Record\u003cstring, string\u003e\n): Promise\u003cstring\u003e\n\n// Add trailers to a specific commit (amends the commit)\nexport async function addTrailersToCommit(\n  commitHash: string, \n  trailers: Record\u003cstring, string\u003e\n): Promise\u003cvoid\u003e\n```\n\n### Amending a Commit\n```typescript\nasync function addTrailersToCommit(hash: string, trailers: Record\u003cstring, string\u003e) {\n  // Get current message\n  const message = await $`git log -1 --format=%B ${hash}`.text();\n  \n  // Add trailers\n  const newMessage = await addTrailers(message, trailers);\n  \n  // Amend commit (only works for HEAD)\n  // For non-HEAD commits, use rebase\n  await $`git commit --amend --no-edit -m ${newMessage}`;\n}\n```\n\n### Edge Cases\n1. **Message already has the trailer**: Update value or skip\n2. **Message has other trailers**: Preserve them\n3. **Message has no body**: Still works (trailers after blank line)\n\n## Testing\n- Add trailer to message without trailers\n- Add trailer to message with existing trailers\n- Add multiple trailers at once\n- Preserve existing unrelated trailers\n\n## Files to Modify\n- src/git/trailers.ts\n\n## Acceptance Criteria\n- [ ] Can add single trailer to message\n- [ ] Can add multiple trailers to message\n- [ ] Preserves existing trailers\n- [ ] Uses git interpret-trailers for correctness\n- [ ] Has tests for various scenarios","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T14:25:02.634601-05:00","updated_at":"2025-12-26T21:20:05.129066-05:00","closed_at":"2025-12-26T21:20:05.129066-05:00","close_reason":"Implemented addTrailers in src/git/trailers.ts with 6 tests","dependencies":[{"issue_id":"taspr-fwm","depends_on_id":"taspr-7tr","type":"parent-child","created_at":"2025-12-25T14:25:06.604931-05:00","created_by":"daemon"},{"issue_id":"taspr-fwm","depends_on_id":"taspr-1es","type":"blocks","created_at":"2025-12-25T14:25:06.875423-05:00","created_by":"daemon"},{"issue_id":"taspr-fwm","depends_on_id":"taspr-1es","type":"depends-on","created_at":"2025-12-25T14:25:06.875423-05:00","created_by":"daemon"}]}
{"id":"taspr-gp1","title":"Group validation in sync","description":"## Goal\nEnforce group validation during sync: no overlapping groups, no unclosed groups.\n\n## Context\nThis is part of Epic 7: Group Management. Group validation was implemented in Epic 1 for the view command. This task ensures sync also validates and blocks on invalid groups.\n\n## Implementation\n\n```typescript\n// In sync command, after parsing stack\nasync function syncCommand() {\n  const result = await parseStack();\n  \n  if (!result.ok) {\n    console.error(formatValidationError(result));\n    \n    // Provide actionable guidance\n    if (result.error === 'overlapping-groups') {\n      console.error('\\nTo fix, run \\`taspr group\\` to adjust the group boundaries.');\n    } else if (result.error === 'unclosed-group') {\n      console.error('\\nTo fix, either:');\n      console.error('  1. Run \\`taspr group\\` to set the group boundaries');\n      console.error('  2. Run \\`taspr group dissolve\\` to remove the incomplete group');\n    }\n    \n    process.exit(1);\n  }\n  \n  // Continue with sync...\n}\n```\n\n## Error Messages\n\n### Overlapping Groups\n```\nâœ— Error: Overlapping groups detected\n\n  Group \"Auth feature\" (f7e8d9c0):\n    starts at b2c3d4e5\n\n  Group \"Login flow\" (a9b8c7d6):\n    starts at c3d4e5f6 (inside \"Auth feature\")\n\n  To fix, run \\`taspr group\\` to adjust the group boundaries.\n```\n\n### Unclosed Group\n```\nâœ— Error: Unclosed group starting at commit b2c3d4e5\n\n  Group f7e8d9c0 (\"Auth feature\") has Taspr-Group-Start but no \n  matching Taspr-Group-End was found in subsequent commits.\n  \n  To fix, either:\n    1. Run \\`taspr group\\` to set the group boundaries\n    2. Run \\`taspr group dissolve\\` to remove the incomplete group\n```\n\n## Files to Modify\n- src/cli/commands/sync.ts\n- src/cli/output.ts\n\n## Testing\n- Sync with valid groups passes\n- Sync with overlapping groups fails with actionable message\n- Sync with unclosed group fails with actionable message\n\n## Acceptance Criteria\n- [ ] Sync blocks on overlapping groups\n- [ ] Sync blocks on unclosed groups\n- [ ] Error messages include fix instructions\n- [ ] Points to \\`taspr group\\` and \\`taspr group dissolve\\` commands","notes":"## Testing Workflow\nAfter completing implementation:\n1. Run `bun run build` to build the CLI\n2. Run `bun test --no-coverage` to verify all tests pass\n3. Tell the user to run `bun run scenario` and select one of these scenarios for manual testing:\n   - **withTasprIds** - 2 commits with IDs (test sync with valid stack)\n   - **emptyStack** - Test empty stack handling\n\n## Scenario Usage\nThe `bun run scenario` command spawns a shell in a temp git repo with `taspr` in PATH. After testing, type `exit` to clean up.\n\n## New Scenarios Needed\nAdd to `src/scenario/definitions.ts` for testing validation errors:\n- **unclosedGroup** - Stack with Taspr-Group-Start but no Taspr-Group-End (test sync blocking)\n- **overlappingGroups** - Stack with overlapping group trailers (test sync blocking)","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-25T14:35:38.666664-05:00","updated_at":"2026-01-02T11:09:22.507118-05:00","closed_at":"2026-01-02T11:09:22.507118-05:00","close_reason":"Implemented group validation in sync: uses formatValidationError() for actionable errors pointing to taspr group --fix. Added unclosedGroup and overlappingGroups test scenarios."}
{"id":"taspr-gs1","title":"Automated rebase onto main","description":"## Goal\nAutomatically rebase stack onto latest main when behind.\n\n## Implementation\n\n```typescript\n// src/git/rebase.ts\n\ninterface RebaseResult {\n  success: boolean;\n  commitCount: number;\n  conflictFile?: string;\n}\n\nasync function rebaseOntoMain(): Promise\u003cRebaseResult\u003e {\n  const defaultBranch = await getDefaultBranch();\n  \n  // Count commits in stack\n  const mergeBase = await $\\`git merge-base HEAD origin/\\${defaultBranch}\\`.text();\n  const commitCount = parseInt(\n    await $\\`git rev-list \\${mergeBase.trim()}..HEAD --count\\`.text(), \n    10\n  );\n  \n  // Attempt rebase\n  const result = await $\\`git rebase origin/\\${defaultBranch}\\`.nothrow();\n  \n  if (result.exitCode === 0) {\n    return { success: true, commitCount };\n  }\n  \n  // Check for conflict\n  const status = await $\\`git status --porcelain\\`.text();\n  const conflictMatch = status.match(/^UU (.+)$/m);\n  \n  if (conflictMatch) {\n    return { \n      success: false, \n      commitCount, \n      conflictFile: conflictMatch[1] \n    };\n  }\n  \n  throw new Error('Rebase failed for unknown reason');\n}\n```\n\n### Preserving Trailers\nGit rebase preserves commit messages, so Taspr trailers survive automatically.\n\n## Integration with Sync\n```typescript\nasync function sync() {\n  if (await isStackBehindMain()) {\n    console.log('Rebasing onto origin/main...');\n    \n    const result = await rebaseOntoMain();\n    \n    if (result.success) {\n      console.log(\\`âœ“ Rebased \\${result.commitCount} commit(s)\\`);\n    } else {\n      // Handle conflict...\n    }\n  }\n}\n```\n\n## Testing\n- Clean rebase succeeds\n- Rebase with conflict fails gracefully\n- Trailers preserved through rebase\n\n## Files to Modify\n- src/git/rebase.ts\n\n## Acceptance Criteria\n- [ ] Rebases stack onto main\n- [ ] Reports commit count\n- [ ] Detects conflicts\n- [ ] Preserves Taspr trailers","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-25T14:36:27.786184-05:00","updated_at":"2025-12-31T14:05:40.698458-05:00","closed_at":"2025-12-31T14:05:40.698458-05:00","close_reason":"Added rebaseOntoMain() function with conflict detection. All 4 new tests passing, trailers preserved through rebase.","dependencies":[{"issue_id":"taspr-gs1","depends_on_id":"taspr-a64","type":"parent-child","created_at":"2025-12-25T14:36:31.944543-05:00","created_by":"daemon"},{"issue_id":"taspr-gs1","depends_on_id":"taspr-tiz","type":"blocks","created_at":"2025-12-25T14:36:32.225243-05:00","created_by":"daemon"},{"issue_id":"taspr-gs1","depends_on_id":"taspr-tiz","type":"depends-on","created_at":"2025-12-25T14:36:32.225243-05:00","created_by":"daemon"}]}
{"id":"taspr-h87","title":"Epic 1: Read Stack from Git","description":"## Goal\nParse a local git branch into a structured representation of commits and groups.\n\n## Background\n\ntaspr is a Bun-powered CLI tool for managing stacked PRs on GitHub. The fundamental model is:\n- **Each commit = one PR** by default\n- **Groups** bundle multiple contiguous commits into a single PR\n\nThis epic establishes the foundation: reading git history and understanding the stack structure before any GitHub integration.\n\n## Core Concepts\n\n### Stack\nA linear sequence of commits on a branch between HEAD and the merge-base with origin/main. Each commit potentially maps to a PR.\n\n### Group\nA contiguous range of commits that should be treated as a single PR. Defined by trailers:\n- `Taspr-Group-Start: \u003c8-hex-id\u003e` on the first commit\n- `Taspr-Group-Title: \u003ctitle\u003e` on the first commit (PR title)\n- `Taspr-Group-End: \u003csame-8-hex-id\u003e` on the last commit\n\n### Commit Identity\nEvery commit gets a `Taspr-Commit-Id` trailer (8 hex characters) that survives rebases. This is how taspr tracks commits across history rewrites.\n\n### PRUnit\nThe logical unit that maps to a PR:\n- **Single**: One commit = one PR. ID is the Taspr-Commit-Id, title is commit subject.\n- **Group**: Multiple commits = one PR. ID is the group-id, title is Taspr-Group-Title.\n\n## Deliverable\nRunning `taspr view` outputs a tree of commits showing which belong to groups and which are standalone. No GitHub integration yetâ€”purely local git data.\n\n## Key Data Structures\n\n```typescript\ninterface CommitInfo {\n  hash: string;\n  subject: string;\n  body: string;\n  trailers: Record\u003cstring, string\u003e;\n}\n\ninterface PRUnit {\n  type: 'single' | 'group';\n  id: string;           // Taspr-Commit-Id (single) or group-id (group)\n  title: string;        // Commit subject (single) or Taspr-Group-Title (group)\n  commitIds: string[];  // All Taspr-Commit-Id values in this unit\n  commits: string[];    // Current git hashes\n}\n\ntype StackParseResult = \n  | { ok: true; units: PRUnit[] }\n  | { ok: false; error: 'unclosed-group'; groupId: string; startCommit: string }\n  | { ok: false; error: 'overlapping-groups'; group1: GroupInfo; group2: GroupInfo; overlappingCommit: string }\n```\n\n## Technical Decisions\n- **CLI Framework**: Commander (good TypeScript support, works with Bun)\n- **Runtime**: Bun (fast TypeScript execution, native test runner)\n- **Git commands**: Bun Shell ($\\`\\`) for safe command execution\n\n## Testable Outcome\n`taspr view` shows commits, identifies groups, reports validation errors for malformed groups.\n\n## File Structure for This Epic\n```\nsrc/\nâ”œâ”€â”€ cli/\nâ”‚   â”œâ”€â”€ index.ts          # Entry point with Commander\nâ”‚   â””â”€â”€ commands/\nâ”‚       â””â”€â”€ view.ts       # View command implementation\nâ”œâ”€â”€ core/\nâ”‚   â””â”€â”€ stack.ts          # Stack parsing, PRUnit detection\nâ”œâ”€â”€ git/\nâ”‚   â”œâ”€â”€ commands.ts       # Git command wrapper\nâ”‚   â””â”€â”€ trailers.ts       # Trailer parsing\nâ””â”€â”€ types.ts              # TypeScript interfaces\ntests/\nâ”œâ”€â”€ helpers/\nâ”‚   â””â”€â”€ git-fixture.ts    # Test utilities for temp repos\nâ””â”€â”€ core/\n    â””â”€â”€ stack.test.ts     # Stack parsing tests\n```","status":"closed","priority":1,"issue_type":"epic","created_at":"2025-12-25T14:21:57.996735-05:00","updated_at":"2025-12-26T01:28:13.837115-05:00","closed_at":"2025-12-26T01:28:13.837115-05:00","close_reason":"All 6 child tasks completed: project scaffolding, git log parsing, trailer parsing, PRUnit detection, group validation, view command"}
{"id":"taspr-i41","title":"Branch name generation","description":"## Goal\nGenerate stable branch names for PRUnits following the pattern `\u003cprefix\u003e/\u003cusername\u003e/\u003cpr-id\u003e`.\n\n## Implementation\n\n```typescript\n// src/github/branches.ts\n\ninterface BranchNameConfig {\n  prefix: string;      // From git config or default \"taspr\"\n  username: string;    // From GitHub API\n}\n\nasync function getBranchNameConfig(): Promise\u003cBranchNameConfig\u003e {\n  // Get prefix from git config\n  const prefixResult = await $`git config --get taspr.branchPrefix`.nothrow();\n  const prefix = prefixResult.exitCode === 0 \n    ? prefixResult.stdout.toString().trim() \n    : 'taspr';\n  \n  // Get username from GitHub\n  const username = await $`gh api user --jq .login`.text();\n  \n  return { prefix, username: username.trim() };\n}\n\nfunction getBranchName(prId: string, config: BranchNameConfig): string {\n  return `${config.prefix}/${config.username}/${prId}`;\n}\n```\n\n### Examples\n```\ntaspr/msims/a1b2c3d4     # Default prefix, single commit\ntaspr/msims/f7e8d9c0     # Default prefix, group\njaspr/msims/a1b2c3d4     # Custom prefix via git config\n```\n\n### Configuration\n```bash\n# Set custom prefix\ngit config taspr.branchPrefix jaspr\n```\n\n## Caching\nUsername lookup is slow (network call). Cache within a sync operation:\n\n```typescript\nlet cachedConfig: BranchNameConfig | null = null;\n\nasync function getBranchNameConfig(): Promise\u003cBranchNameConfig\u003e {\n  if (cachedConfig) return cachedConfig;\n  // ... fetch\n  cachedConfig = config;\n  return config;\n}\n```\n\n## Testing\n- Default prefix generation\n- Custom prefix from git config\n- Valid branch name characters (pr-ids are hex, always safe)\n\n## Files to Create\n- src/github/branches.ts\n- src/git/config.ts (may already exist from Epic 1)\n\n## Acceptance Criteria\n- [ ] Generates branch names with correct pattern\n- [ ] Reads custom prefix from git config\n- [ ] Fetches username from GitHub API\n- [ ] Caches config within operation","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T14:26:47.651395-05:00","updated_at":"2025-12-26T23:29:21.511757-05:00","closed_at":"2025-12-26T23:29:21.511757-05:00","close_reason":"Implemented and tested","dependencies":[{"issue_id":"taspr-i41","depends_on_id":"taspr-osw","type":"parent-child","created_at":"2025-12-25T14:26:51.374607-05:00","created_by":"daemon"},{"issue_id":"taspr-i41","depends_on_id":"taspr-bvy","type":"blocks","created_at":"2025-12-25T14:27:05.963936-05:00","created_by":"daemon"},{"issue_id":"taspr-i41","depends_on_id":"taspr-bvy","type":"depends-on","created_at":"2025-12-25T14:27:05.963936-05:00","created_by":"daemon"}]}
{"id":"taspr-iol","title":"Add test log files showing full taspr CLI output for UI review","description":"Create log files during test runs that capture the full textual output of all `taspr` CLI invocations. This allows reviewing the UI rendering in all states without running tests manually.\n\n## Implementation Ideas\n- Write output to files in a `test-logs/` or `test-output/` directory\n- Include timestamp and test name in log entries\n- Capture both stdout and stderr\n- Show the command that was run along with its output\n\n## Output Format Example\n```\n=== test: view command shows stack ===\n$ taspr view\nStack: feature/auth (3 commits, PRs: 2/3 opened)\n\n  â†’ origin/main\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  â— #142 Add user model\n    â””â”€ taspr-abc\n    https://github.com/owner/repo/pull/142\n...\n```\n\n## Acceptance Criteria\n- [ ] All integration tests log their CLI output\n- [ ] Logs are organized by test file/suite\n- [ ] Output is human-readable for UI review\n- [ ] Logs can be git-ignored or committed for review","status":"closed","priority":3,"issue_type":"task","created_at":"2025-12-31T14:39:39.068921-05:00","updated_at":"2026-01-07T11:57:32.957092-05:00","closed_at":"2026-01-05T00:34:03.022072-05:00"}
{"id":"taspr-kow","title":"Audit tests for surprising default behaviors","description":"Review all tests to identify surprising or potentially harmful default behaviors that may have been implemented by the LLM.\n\nKnown examples:\n- `group --fix` in non-TTY mode automatically dissolves problematic groups (data loss!)\n\nGoals:\n- Find other cases where defaults could cause unexpected data loss\n- Identify overly aggressive automatic behaviors\n- Document and fix any surprising behaviors found","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-03T23:28:18.845034-05:00","updated_at":"2026-01-03T23:28:18.845034-05:00"}
{"id":"taspr-lr5","title":"Help text - comprehensive --help for all commands","description":"## Goal\nProvide comprehensive, well-formatted help text for all commands using Commander\\'s built-in help system.\n\n## Commands to Document\n\n### Main Command: `taspr`\n```\ntaspr - Stacked PR management for GitHub\n\nUsage: taspr \u003ccommand\u003e [options]\n\nCommands:\n  view      Show current stack structure and PR status\n  sync      Sync local stack with GitHub (push branches, create/update PRs)\n  land      Merge the bottom PR to main\n  group     Manage commit groups (create, edit, dissolve)\n\nOptions:\n  -h, --help     Show this help message\n  -v, --version  Show version number\n\nExamples:\n  taspr view              Show stack structure\n  taspr sync              Push and create PRs\n  taspr sync --open       Push, create PRs, and open in browser\n  taspr land              Merge bottom ready PR\n  taspr group create      Create a new commit group\n\nRun 'taspr \u003ccommand\u003e --help' for detailed help on each command.\n```\n\n### `taspr view`\n```\nShow the current stack structure and PR status\n\nUsage: taspr view [options]\n\nOptions:\n  --all          Show all stacks across branches (not just current)\n  --json         Output as JSON for scripting\n  -h, --help     Show this help message\n\nThe view command shows:\n  - Commits in the current stack (between HEAD and origin/main)\n  - Which commits are grouped into multi-commit PRs\n  - PR numbers and their current status (draft, open, merged)\n  - CI status, review status, and comment threads (if PRs exist)\n\nStatus indicators:\n  âœ“  Checks passing, approved\n  â—  Checks running or pending review\n  âœ—  Checks failing or changes requested\n  â—  Draft PR\n\nExamples:\n  taspr view         Current branch stack\n  taspr view --all   All branches with stacks\n```\n\n### `taspr sync`\n```\nSync local stack with GitHub\n\nUsage: taspr sync [options]\n\nOptions:\n  --open         Open created PRs in browser\n  --dry-run      Show what would be done without doing it\n  -h, --help     Show this help message\n\nThe sync command:\n  1. Adds Taspr-Commit-Id trailers to commits that don\\'t have them\n  2. Creates branches for each PR unit (single commit or group)\n  3. Creates PRs on GitHub with correct stacking (each based on PR below)\n  4. Updates existing PRs if commits have changed\n  5. Rebases on origin/main if behind (with conflict detection)\n\nBranch naming: \u003cprefix\u003e/\u003cusername\u003e/\u003ccommit-id\u003e\n  Example: taspr/alice/a1b2c3d4\n\nEach PR\\'s base branch is the branch of the PR below it in the stack,\nor main/master for the bottom PR.\n\nExamples:\n  taspr sync             Sync stack to GitHub\n  taspr sync --open      Sync and open new PRs in browser\n  taspr sync --dry-run   Preview sync operations\n```\n\n### `taspr land`\n```\nMerge PRs to main\n\nUsage: taspr land [options]\n\nOptions:\n  --all          Land all consecutive ready PRs (not just bottom)\n  -h, --help     Show this help message\n\nThe land command merges the bottom PR in your stack to main/master.\nGitHub automatically retargets child PRs to the new base after merge.\n\nA PR is \"ready\" when:\n  - CI checks are passing\n  - Has required approvals\n  - No unresolved review threads\n  - Not a draft\n\nExamples:\n  taspr land         Merge bottom ready PR\n  taspr land --all   Merge all consecutive ready PRs\n```\n\n### `taspr group`\n```\nManage commit groups (multiple commits as one PR)\n\nUsage: taspr group \u003csubcommand\u003e [options]\n\nSubcommands:\n  create    Create a new group from selected commits\n  edit      Edit an existing group (title or range)\n  dissolve  Remove a group, making commits individual PRs\n\nBy default, each commit becomes its own PR. Groups let you bundle\nmultiple related commits into a single PR while keeping them as\nseparate commits locally.\n\nGroups use git trailers:\n  - Taspr-Group-Start: \u003cgroup-id\u003e   (on first commit)\n  - Taspr-Group-End: \u003cgroup-id\u003e     (on last commit)\n  - Taspr-Group-Title: \u003ctitle\u003e      (on first commit)\n\nExamples:\n  taspr group create     Interactive commit selection\n  taspr group edit       Edit existing group\n  taspr group dissolve   Remove group, keep commits\n```\n\n## Implementation with Commander\n\n```typescript\nimport { program } from 'commander';\n\nprogram\n  .name('taspr')\n  .description('Stacked PR management for GitHub')\n  .version('0.1.0');\n\nprogram\n  .command('view')\n  .description('Show current stack structure and PR status')\n  .option('--all', 'Show all stacks across branches')\n  .option('--json', 'Output as JSON')\n  .addHelpText('after', `\nStatus indicators:\n  âœ“  Checks passing, approved\n  â—  Checks running or pending review\n  âœ—  Checks failing or changes requested\n  â—  Draft PR\n\nExamples:\n  taspr view         Current branch stack\n  taspr view --all   All branches with stacks\n`)\n  .action(viewCommand);\n```\n\n## Acceptance Criteria\n- [ ] Main taspr --help shows all commands\n- [ ] Each command has detailed --help\n- [ ] Examples included for common use cases\n- [ ] Status indicators explained in view help\n- [ ] Group trailer format documented in group help\n- [ ] Help text fits standard terminal width (80 chars)","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-25T14:49:58.136451-05:00","updated_at":"2025-12-25T14:49:58.136451-05:00","dependencies":[{"issue_id":"taspr-lr5","depends_on_id":"taspr-8iv","type":"parent-child","created_at":"2025-12-25T15:01:37.068615-05:00","created_by":"daemon"}]}
{"id":"taspr-m80","title":"Group dissolve command","description":"## Goal\nImplement `taspr group dissolve` to break a group back into individual commits.\n\n## Context\nThis is part of Epic 7: Group Management. The main group functionality is handled by a unified TUI (`taspr group`), but dissolve remains as a separate simple command for quick ungrouping.\n\n## Implementation\n\n```typescript\n// src/cli/commands/group.ts\n\ngroupCommand\n  .command('dissolve')\n  .argument('[group-id]', 'Group to dissolve')\n  .description('Dissolve a group back into individual commits')\n  .action(async (groupId?: string) =\u003e {\n    const result = await parseStack();\n    \n    const groups = result.units.filter(u =\u003e u.type === 'group');\n    if (groups.length === 0) {\n      console.log('No groups in current stack');\n      return;\n    }\n    \n    // If no group-id provided, prompt for selection\n    let group: PRUnit;\n    if (groupId) {\n      group = groups.find(g =\u003e g.id === groupId);\n      if (!group) {\n        console.error(`Group '${groupId}' not found`);\n        process.exit(1);\n      }\n    } else {\n      group = await select({\n        message: 'Select group to dissolve',\n        choices: groups.map(g =\u003e ({\n          name: `${g.title} (${g.commits.length} commits)`,\n          value: g,\n        })),\n      });\n    }\n    \n    // Warn about PR closure\n    const pr = await findPRForGroup(group);\n    if (pr) {\n      console.log(`âš  Warning: This will close PR #${pr.number}.`);\n      console.log('  Each commit will become its own PR when you sync --open.');\n    }\n    \n    const proceed = await confirm({ message: 'Proceed?' });\n    if (!proceed) return;\n    \n    // Remove group trailers\n    await removeGroupTrailers(group);\n    \n    console.log(`âœ“ Dissolved group \"${group.title}\"`);\n    console.log('  Run \\`taspr sync --open\\` to create individual PRs.');\n  });\n```\n\n### Removing Group Trailers\n```typescript\nasync function removeGroupTrailers(group: PRUnit): Promise\u003cvoid\u003e {\n  const first = group.commits[0];\n  const last = group.commits[group.commits.length - 1];\n  \n  // Remove Start and Title from first commit\n  await removeTrailersFromCommit(first, [\n    'Taspr-Group-Start',\n    'Taspr-Group-Title',\n  ]);\n  \n  // Remove End from last commit\n  if (last !== first) {\n    await removeTrailersFromCommit(last, ['Taspr-Group-End']);\n  }\n}\n```\n\n## Files to Modify\n- src/cli/commands/group.ts (add dissolve subcommand)\n\n## Testing\n- Dissolve single group\n- Dissolve with PR warning\n- Cancel dissolve\n- Dissolve by group-id argument\n\n## Acceptance Criteria\n- [ ] Lists existing groups if no argument provided\n- [ ] Accepts group-id as optional argument\n- [ ] Warns about PR closure\n- [ ] Removes all group trailers (Start, Title, End)\n- [ ] Confirms before changes\n- [ ] Works with single-commit groups","notes":"## Testing Workflow\nAfter completing implementation:\n1. Run `bun run build` to build the CLI\n2. Run `bun test --no-coverage` to verify all tests pass\n3. Tell the user to run `bun run scenario` and select a scenario for manual testing\n\n## Scenario Usage\nThe `bun run scenario` command spawns a shell in a temp git repo with `taspr` in PATH. After testing, type `exit` to clean up.\n\n## New Scenarios Needed\nThis task REQUIRES a new scenario. Add to `src/scenario/definitions.ts`:\n- **withGroups** - Stack with existing group trailers (Taspr-Group-Start/End/Title) for testing dissolve command\n\nThe agent should create this scenario before implementing the dissolve command, as it's needed for both unit tests and manual testing.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-25T14:35:21.688433-05:00","updated_at":"2026-01-02T11:01:08.152403-05:00","closed_at":"2026-01-02T11:01:08.152403-05:00","close_reason":"Implemented dissolve command with interactive multi-select, fixed detectPRUnits bug for single-commit groups, fixed dissolveGroup to only remove trailers for target group","dependencies":[{"issue_id":"taspr-m80","depends_on_id":"taspr-7mu","type":"parent-child","created_at":"2025-12-25T14:35:26.08024-05:00","created_by":"daemon"},{"issue_id":"taspr-m80","depends_on_id":"taspr-37l","type":"blocks","created_at":"2025-12-25T14:35:26.356701-05:00","created_by":"daemon"},{"issue_id":"taspr-m80","depends_on_id":"taspr-37l","type":"depends-on","created_at":"2025-12-25T14:35:26.356701-05:00","created_by":"daemon"}]}
{"id":"taspr-mpr","title":"Unified group TUI","description":"## Goal\nImplement a unified interactive TUI for `taspr group` that allows users to reorder commits and assign groups in a single interface.\n\n## Context\nThis replaces the originally planned separate `group create/edit` commands with a single unified experience. The TUI displays all commits in the stack and allows:\n- Reordering commits (via move mode)\n- Assigning commits to groups (A, B, C, ... Z)\n- Previewing conflict risks before committing changes\n\n## UX Design\n\n### Normal Mode\n```\nGroup Editor - 4 commits\n\n  â†’ origin/main\n\n  â”€ a1b2c3d4  Add user model           â† cursor (highlighted)\n  A e5f6a7b8  Add login endpoint\n  A c9d0e1f2  Add password validation\n  B 12345678  Add dashboard\n\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nGroups: A (2 commits), B (1 commit)\nâ†‘â†“ navigate â”‚ Space move mode â”‚ â†â†’ group â”‚ Enter confirm â”‚ Esc cancel\n```\n\n### Move Mode (after pressing Space)\n```\nGroup Editor - 4 commits [MOVE MODE]\n\n  â†’ origin/main\n\n  â”€ a1b2c3d4  Add user model\nÂ» A e5f6a7b8  Add login endpoint       â† MOVING (different color)\n  A c9d0e1f2  Add password validation\n  B 12345678  Add dashboard\n\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ†‘â†“ swap position â”‚ Space exit move mode â”‚ â†â†’ disabled\n```\n\n## Controls\n- **Up/Down arrows**:\n  - Normal mode: Move cursor between commits\n  - Move mode: Swap selected commit with adjacent commit\n- **Space**: Toggle \"move mode\" on current commit\n- **Left/Right arrows**: Cycle group assignment (only works in normal mode)\n  - Left-most = ungrouped (â”€)\n  - Right cycles: A â†’ B â†’ C â†’ ... â†’ Z â†’ ungrouped\n- **Enter**: Confirm, prompt for group names, perform rebase\n- **Esc**: Cancel without changes\n\n## Key Behaviors\n- Only ONE commit can be in \"move mode\" at a time\n- Left/Right arrows are disabled while a commit is in move mode\n- Single-commit groups ARE allowed\n- On confirm: prompt for group names, then immediate git rebase\n- Group trailers are added after rebase\n\n## Implementation Phases\n\n### Phase 1: Terminal Utilities\nCreate `src/tui/terminal.ts`:\n- `enableRawMode()` / `disableRawMode()`\n- `parseKeypress(data: Buffer)` â†’ `{ name, ctrl, shift }`\n- ANSI escape helpers: `clearScreen()`, `moveCursor()`, `colors`\n\n### Phase 2: State Management\nCreate `src/tui/state.ts`:\n```typescript\ninterface TUIState {\n  commits: CommitDisplay[];       // Current order (may differ from original)\n  cursor: number;                 // Current cursor position\n  moveMode: number | null;        // Index of commit in move mode (null = normal mode)\n  groups: Map\u003cnumber, string | null\u003e;  // index â†’ 'A'|'B'|...|null\n}\n```\n- `moveCursor(state, 'up'|'down')` - move cursor in normal mode\n- `toggleMoveMode(state)` - enter/exit move mode for cursor commit\n- `swapCommit(state, direction)` - swap commit in move mode with adjacent\n- `cycleGroup(state, 'left'|'right')` - change group (only in normal mode)\n\n### Phase 3: Rendering\nCreate `src/tui/render.ts`:\n- `renderScreen(state): string`\n- Match existing output patterns from `src/cli/output.ts`\n\n### Phase 4: TUI Main Loop\nCreate `src/tui/group-editor.ts`:\n- Fetch commits with `getStackCommitsWithTrailers()`\n- Validate stack with `parseStack()` - exit if errors\n- Initialize state from existing commits/groups\n- Render loop with raw stdin\n- On move: check for conflicts (see conflict-predict issue)\n- On Enter: exit raw mode, prompt for group names, call rebase logic\n\n### Phase 5: CLI Integration\nCreate `src/cli/commands/group.ts`:\n- `groupCommand()` - launch TUI\n\nUpdate `src/cli/index.ts`:\n```typescript\nconst groupCmd = program.command(\"group\").description(\"Manage commit groups\");\ngroupCmd.action(groupCommand);  // default action launches TUI\ngroupCmd.command(\"dissolve\").argument(\"[group]\").action(dissolveCommand);\n```\n\n## Files to Create\n- src/tui/terminal.ts\n- src/tui/state.ts\n- src/tui/render.ts\n- src/tui/group-editor.ts\n- src/cli/commands/group.ts\n\n## Files to Modify\n- src/cli/index.ts (replace placeholder group command)\n\n## Technical Approach\n**TUI Library**: Raw terminal handling with Node.js `readline` (Bun compatible). No external TUI library needed. Use `process.stdin.setRawMode(true)` for key input.\n\n## Testing\n- Unit tests for state transitions in state.test.ts\n- Unit tests for key parsing in terminal.test.ts\n- Unit tests for rendering in render.test.ts\n- Manual testing across terminal emulators (iTerm2, Terminal.app, VS Code)\n\n## Edge Cases\n1. **Empty stack**: Show message and exit\n2. **Single commit**: Allow grouping (creates single-commit group)\n3. **Existing groups**: Show in initial state, allow modification\n4. **Non-TTY**: Detect `process.stdin.isTTY` and show error\n\n## Acceptance Criteria\n- [ ] TUI launches and displays commits\n- [ ] Arrow key navigation works\n- [ ] Move mode allows reordering commits\n- [ ] Left/Right cycles group assignment\n- [ ] Enter prompts for group names\n- [ ] Esc cancels without changes\n- [ ] Works in common terminal emulators","notes":"## Testing Workflow\nAfter completing implementation:\n1. Run `bun run build` to build the CLI\n2. Run `bun test --no-coverage` to verify all tests pass\n3. Tell the user to run `bun run scenario` and select one of these scenarios for manual testing:\n   - **multiCommitStack** - 3 commits on feature branch (best for testing TUI navigation and reordering)\n   - **withTasprIds** - 2 commits with existing Taspr-Commit-Id trailers (test group assignment)\n   - **emptyStack** - Test empty state handling\n\n## Scenario Usage\nThe `bun run scenario` command spawns a shell in a temp git repo with `taspr` in PATH. The agent should:\n1. Run `bun run build` \n2. Tell the user: \"Run `bun run scenario` and select **multiCommitStack** to test the TUI\"\n\nAfter testing, type `exit` to clean up the temp repo.\n\n## New Scenarios Needed\nAdd to `src/scenario/definitions.ts`:\n- **withGroups** - Stack with existing group trailers (Taspr-Group-Start/End/Title) for testing group editing\n- **singleCommitStack** - Single commit on feature branch for edge case testing","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-01T22:47:20.422051-05:00","updated_at":"2026-01-02T10:19:10.556857-05:00","closed_at":"2026-01-02T10:19:10.556857-05:00","close_reason":"Closed","dependencies":[{"issue_id":"taspr-mpr","depends_on_id":"taspr-7mu","type":"parent-child","created_at":"2026-01-01T22:48:51.367927-05:00","created_by":"daemon"},{"issue_id":"taspr-mpr","depends_on_id":"taspr-5u7","type":"blocks","created_at":"2026-01-01T22:48:56.67974-05:00","created_by":"daemon"},{"issue_id":"taspr-mpr","depends_on_id":"taspr-d55","type":"blocks","created_at":"2026-01-01T22:48:56.959636-05:00","created_by":"daemon"}]}
{"id":"taspr-n47","title":"Group edit command","description":"## Goal\nImplement `taspr group edit` to modify an existing group's range or title.\n\n## Implementation\n\n```typescript\ngroupCommand\n  .command('edit')\n  .description(\"Edit an existing group's range or title\")\n  .action(async () =\u003e {\n    const result = await parseStack();\n    // ... validation\n    \n    // Find existing groups\n    const groups = result.units.filter(u =\u003e u.type === 'group');\n    if (groups.length === 0) {\n      console.log('No groups in current stack');\n      return;\n    }\n    \n    // Select group to edit\n    const group = await select({\n      message: 'Select group to edit',\n      choices: groups.map(g =\u003e ({\n        name: \\`\\${g.title} (\\${g.id}, \\${g.commits.length} commits)\\`,\n        value: g,\n      })),\n    });\n    \n    // What to change\n    const change = await select({\n      message: 'What would you like to change?',\n      choices: [\n        { name: 'Change title', value: 'title' },\n        { name: 'Change commit range', value: 'range' },\n        { name: 'Both', value: 'both' },\n      ],\n    });\n    \n    if (change === 'title' || change === 'both') {\n      const newTitle = await input({ \n        message: 'New title:', \n        default: group.title \n      });\n      await updateGroupTitle(group.id, newTitle);\n    }\n    \n    if (change === 'range' || change === 'both') {\n      const newRange = await selectCommits(result.units, group);\n      await moveGroupBoundaries(group.id, newRange);\n    }\n  });\n```\n\n### Moving Group Boundaries\n```typescript\nasync function moveGroupBoundaries(\n  groupId: string,\n  newRange: CommitInfo[]\n): Promise\u003cvoid\u003e {\n  // 1. Remove old Start/End trailers\n  // 2. Add new Start/End trailers\n  // 3. This requires rebase\n}\n```\n\n## Testing\n- Edit title only\n- Edit range only\n- Edit both\n- Validate new range doesn't overlap\n\n## Files to Modify\n- src/cli/commands/group.ts\n- src/core/group.ts\n\n## Acceptance Criteria\n- [ ] Lists existing groups\n- [ ] Allows editing title\n- [ ] Allows editing commit range\n- [ ] Moves trailers correctly\n- [ ] Validates no overlap with other groups","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-25T14:35:06.986405-05:00","updated_at":"2026-01-01T22:45:42.991139-05:00","closed_at":"2026-01-01T22:45:42.991139-05:00","close_reason":"Replaced by unified group TUI - see taspr-7mu for revised plan","dependencies":[{"issue_id":"taspr-n47","depends_on_id":"taspr-7mu","type":"parent-child","created_at":"2025-12-25T14:35:11.643065-05:00","created_by":"daemon"},{"issue_id":"taspr-n47","depends_on_id":"taspr-37l","type":"blocks","created_at":"2025-12-25T14:35:11.919004-05:00","created_by":"daemon"},{"issue_id":"taspr-n47","depends_on_id":"taspr-37l","type":"depends-on","created_at":"2025-12-25T14:35:11.919004-05:00","created_by":"daemon"}]}
{"id":"taspr-n48","title":"Branch creation and push","description":"## Goal\nPush commits to remote branches for each PRUnit.\n\n## Background\nEach PRUnit needs a branch on GitHub. The branch points to the HEAD commit of that PRUnit:\n- For singles: the single commit\n- For groups: the last commit in the group\n\n## Implementation\n\n```typescript\n// src/github/branches.ts\n\nasync function pushBranch(\n  commitHash: string, \n  branchName: string,\n  force: boolean = false\n): Promise\u003cvoid\u003e {\n  const forceFlag = force ? '--force' : '';\n  await $\\`git push ${forceFlag} origin ${commitHash}:refs/heads/${branchName}\\`;\n}\n\nasync function pushPRUnitBranch(unit: PRUnit, config: BranchNameConfig): Promise\u003cstring\u003e {\n  const branchName = getBranchName(unit.id, config);\n  const commitHash = unit.commits[unit.commits.length - 1]; // Last commit in unit\n  \n  await pushBranch(commitHash, branchName);\n  \n  return branchName;\n}\n```\n\n### Remote Branch Management\n```bash\n# Push specific commit to branch\ngit push origin abc123:refs/heads/taspr/msims/a1b2c3d4\n\n# Force push (needed after rebase)\ngit push --force origin abc123:refs/heads/taspr/msims/a1b2c3d4\n\n# Delete branch\ngit push origin --delete taspr/msims/a1b2c3d4\n```\n\n### Stack Ordering\nPush branches bottom-to-top so parent branches exist before creating child PRs:\n\n```typescript\nasync function pushAllBranches(units: PRUnit[]): Promise\u003cMap\u003cstring, string\u003e\u003e {\n  const config = await getBranchNameConfig();\n  const branches = new Map\u003cstring, string\u003e(); // prId -\u003e branchName\n  \n  // Push in order (oldest first = bottom of stack)\n  for (const unit of units) {\n    const branch = await pushPRUnitBranch(unit, config);\n    branches.set(unit.id, branch);\n  }\n  \n  return branches;\n}\n```\n\n## Edge Cases\n1. **Branch already exists**: Push still works (updates branch)\n2. **Permission denied**: Clear error about repo access\n3. **No remote**: Error about missing origin\n\n## Testing\n- Push creates branch on remote\n- Push updates existing branch\n- Force push works after rebase\n\n## Files to Modify\n- src/github/branches.ts\n\n## Acceptance Criteria\n- [ ] Pushes commits to correctly named branches\n- [ ] Updates existing branches\n- [ ] Force push supported for rebased commits\n- [ ] Clear errors on push failures","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T14:27:19.196006-05:00","updated_at":"2025-12-26T23:29:21.518681-05:00","closed_at":"2025-12-26T23:29:21.518681-05:00","close_reason":"Implemented and tested","dependencies":[{"issue_id":"taspr-n48","depends_on_id":"taspr-osw","type":"parent-child","created_at":"2025-12-25T14:27:22.733887-05:00","created_by":"daemon"},{"issue_id":"taspr-n48","depends_on_id":"taspr-i41","type":"blocks","created_at":"2025-12-25T14:27:23.014297-05:00","created_by":"daemon"},{"issue_id":"taspr-n48","depends_on_id":"taspr-i41","type":"depends-on","created_at":"2025-12-25T14:27:23.014297-05:00","created_by":"daemon"}]}
{"id":"taspr-nh3","title":"Sync command (ID injection only)","description":"## Goal\nImplement the `taspr sync` command for Epic 2 scope: adding IDs to commits.\n\n## Background\nAt this stage, sync does one thing: ensure all commits have Taspr-Commit-Id trailers.\n\nLater epics will extend sync to:\n- Push branches to GitHub (Epic 3)\n- Update PR branches (Epic 4)\n- Rebase onto main (Epic 8)\n\n## Command Implementation\n\n```typescript\n// src/cli/commands/sync.ts\nimport { Command } from 'commander';\n\nexport const syncCommand = new Command('sync')\n  .description('Sync stack state (add IDs, push PRs)')\n  .action(async () =\u003e {\n    // Check working tree\n    await requireCleanWorkingTree();\n    \n    // Parse current stack\n    const result = await parseStack();\n    if (!result.ok) {\n      console.error(formatValidationError(result));\n      process.exit(1);\n    }\n    \n    // Find commits without IDs\n    const needsId = result.units\n      .flatMap(u =\u003e u.commits)\n      .filter(c =\u003e !c.trailers['Taspr-Commit-Id']);\n    \n    if (needsId.length === 0) {\n      console.log('âœ“ All commits have IDs');\n      return;\n    }\n    \n    // Add IDs via rebase\n    console.log(`Adding IDs to ${needsId.length} commit(s)...`);\n    await injectMissingIds();\n    \n    console.log('âœ“ Added Taspr-Commit-Id to commits');\n  });\n```\n\n## Output\n\n### When IDs added\n```\n$ taspr sync\n\nAdding IDs to 3 commit(s)...\nâœ“ Added Taspr-Commit-Id to 3 commits:\n  â€¢ a1b2c3d4 Add user model\n  â€¢ b2c3d4e5 Add login endpoint\n  â€¢ c3d4e5f6 Add validation\n```\n\n### When already up to date\n```\n$ taspr sync\n\nâœ“ All commits have Taspr-Commit-Id\n```\n\n### When dirty\n```\n$ taspr sync\n\nâœ— Error: Cannot sync with uncommitted changes\n  ...\n```\n\n## Integration with View\nAfter sync, `taspr view` will show the new IDs:\n\n```\n$ taspr view\n\nStack: feature/auth (3 commits, 3 PRs)\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  â—‹ Add user model\n    â””â”€ a1b2c3d4\n...\n```\n\n## Testing\n1. Stack with no IDs â†’ adds IDs, reports count\n2. Stack with all IDs â†’ no-op, reports up to date\n3. Dirty working tree â†’ blocks with error\n4. Integration: sync then view shows IDs\n\n## Files to Create/Modify\n- src/cli/commands/sync.ts (create)\n- src/cli/index.ts (modify) - Register sync command\n\n## Acceptance Criteria\n- [ ] Adds IDs to commits without them\n- [ ] Reports how many commits were modified\n- [ ] No-op if all commits have IDs\n- [ ] Blocks on dirty working tree\n- [ ] Has integration tests","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T14:26:05.806801-05:00","updated_at":"2025-12-26T21:32:31.055581-05:00","closed_at":"2025-12-26T21:32:31.055581-05:00","close_reason":"Implemented taspr sync command with 5 integration tests","dependencies":[{"issue_id":"taspr-nh3","depends_on_id":"taspr-7tr","type":"parent-child","created_at":"2025-12-25T14:26:09.683543-05:00","created_by":"daemon"},{"issue_id":"taspr-nh3","depends_on_id":"taspr-7h3","type":"blocks","created_at":"2025-12-25T14:26:09.957219-05:00","created_by":"daemon"},{"issue_id":"taspr-nh3","depends_on_id":"taspr-7h3","type":"depends-on","created_at":"2025-12-25T14:26:09.957219-05:00","created_by":"daemon"},{"issue_id":"taspr-nh3","depends_on_id":"taspr-4b6","type":"blocks","created_at":"2025-12-25T14:26:10.230538-05:00","created_by":"daemon"},{"issue_id":"taspr-nh3","depends_on_id":"taspr-4b6","type":"depends-on","created_at":"2025-12-25T14:26:10.230538-05:00","created_by":"daemon"}]}
{"id":"taspr-osw","title":"Epic 3: Push Stack to GitHub as PRs","description":"## Goal\nCreate GitHub PRs for each PRUnit, with correct stacking (each PR based on the one below it).\n\n## Background\n\n### Stacked PRs Model\nIn a stack of 3 PRUnits (A, B, C from bottom to top):\n- PR for A: base = main, head = branch for A\n- PR for B: base = branch for A, head = branch for B\n- PR for C: base = branch for B, head = branch for C\n\nThis creates a review chain where reviewers see only the changes in each PR, not accumulated changes.\n\n### Branch Naming Convention\n```\n\u003cprefix\u003e/\u003cusername\u003e/\u003cpr-id\u003e\n```\n\nExample: `taspr/msims/a1b2c3d4`\n\nWhere:\n- `prefix`: Configurable via `git config taspr.branchPrefix` (default: \"taspr\")\n- `username`: GitHub username from `gh api user`\n- `pr-id`: The PRUnit's id (commit-id for singles, group-id for groups)\n\nThis naming:\n- Is stable (ID survives rebases)\n- Identifies the owner\n- Groups all taspr branches with a common prefix\n\n### No PR Metadata Storage\nAt this stage, we don't store PR numbers anywhere. We discover them by:\n1. Looking up PRs by branch name\n2. GitHub API: `gh pr list --head \u003cbranch\u003e`\n\nThis keeps the design simpleâ€”git trailers remain the single source of truth.\n\n## Workflow\n\n1. User runs `taspr sync --open`\n2. For each PRUnit without an existing PR:\n   - Create/update branch: `git push origin \u003ccommit\u003e:refs/heads/\u003cbranch-name\u003e`\n   - Create PR: `gh pr create --head \u003cbranch\u003e --base \u003cparent-branch\u003e`\n3. Report created PRs\n\n## Deliverable\nRunning `taspr sync --open` creates branches and PRs on GitHub. Each PR's base is the branch of the PR below it (or main for the bottom).\n\n## Dependencies\n- Epic 2 must be complete (commits have IDs)\n\n## Key Technical Decisions\n- Use `gh` CLI for all GitHub operations (leverages user's existing auth)\n- Branch per PRUnit, named by pr-id\n- PRs discovered by branch lookup, not stored in trailers\n\n## Testable Outcome\nPRs appear on GitHub, correctly stacked, with titles from commit/group.","status":"closed","priority":1,"issue_type":"epic","created_at":"2025-12-25T14:26:32.393192-05:00","updated_at":"2025-12-26T23:29:29.43508-05:00","closed_at":"2025-12-26T23:29:29.43508-05:00","close_reason":"All child tasks implemented and tested","dependencies":[{"issue_id":"taspr-osw","depends_on_id":"taspr-7tr","type":"blocks","created_at":"2025-12-25T14:26:36.107535-05:00","created_by":"daemon"},{"issue_id":"taspr-osw","depends_on_id":"taspr-7tr","type":"depends-on","created_at":"2025-12-25T14:26:36.107535-05:00","created_by":"daemon"}]}
{"id":"taspr-pla","title":"Interactive group repair mode for --fix","description":"The current `taspr group --fix` just removes all group trailers, which is a destructive 'nuclear option'. Instead, it should launch an interactive TUI that:\n\n1. Shows the detected error (unclosed group, overlapping groups, orphan end)\n2. Visualizes the problematic commits and their current group trailers\n3. Offers repair options:\n   - For unclosed groups: select which commit should be the group end\n   - For overlapping groups: choose which group to keep, or adjust boundaries\n   - For orphan ends: select which commit should be the group start, or remove the orphan\n4. Allows dissolving as a last resort (current behavior)\n\nThe TUI should reuse the existing group-editor infrastructure where possible.\n\n## Acceptance Criteria\n- [ ] Interactive mode shows the specific error clearly\n- [ ] User can select repair action (not just dissolve)\n- [ ] For unclosed groups: can pick the end commit\n- [ ] For overlapping groups: can adjust which commits belong to which group\n- [ ] For orphan ends: can pick the start commit or remove\n- [ ] Non-interactive fallback with `--fix=dissolve` preserves current behavior","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-02T11:23:37.164774-05:00","updated_at":"2026-01-02T11:55:37.693697-05:00","closed_at":"2026-01-02T11:55:37.693697-05:00","close_reason":"Closed"}
{"id":"taspr-q9i","title":"Interactive commit selection UI","description":"## Goal\nCreate a checkbox-style UI for selecting commits.\n\n## Implementation Options\n\n### Option 1: @inquirer/prompts (recommended)\n```typescript\nimport { checkbox } from '@inquirer/prompts';\n\nconst selected = await checkbox({\n  message: 'Select commits to group',\n  choices: commits.map((c, i) =\u003e ({\n    name: \\`\\${c.hash.slice(0, 8)} \\${c.subject}\\`,\n    value: i,\n    checked: false,\n  })),\n});\n```\n\n### Option 2: @clack/prompts\n```typescript\nimport { multiselect } from '@clack/prompts';\n\nconst selected = await multiselect({\n  message: 'Select commits to group',\n  options: commits.map((c, i) =\u003e ({\n    label: \\`\\${c.hash.slice(0, 8)} \\${c.subject}\\`,\n    value: i,\n  })),\n});\n```\n\n### Option 3: Custom with keypress\nFor full control, handle stdin directly:\n```typescript\nimport { emitKeypressEvents } from 'readline';\n// Custom implementation\n```\n\n## Validation\n- Selection must be contiguous\n- At least 2 commits for a group\n- Cannot overlap existing groups\n\n```typescript\nfunction validateSelection(indices: number[], commits: CommitInfo[]): ValidationResult {\n  // Check contiguous\n  const sorted = [...indices].sort((a, b) =\u003e a - b);\n  for (let i = 1; i \u003c sorted.length; i++) {\n    if (sorted[i] !== sorted[i - 1] + 1) {\n      return { ok: false, error: 'Selection must be contiguous' };\n    }\n  }\n  \n  // Check not overlapping existing groups\n  // ...\n  \n  return { ok: true };\n}\n```\n\n## Testing\n- Mock stdin for automated tests\n- Manual testing for UX\n\n## Files to Create\n- src/cli/prompts.ts\n\n## Acceptance Criteria\n- [ ] Checkbox selection works\n- [ ] Validates contiguous selection\n- [ ] Shows existing group status\n- [ ] Works in terminal environments","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-25T14:33:58.215597-05:00","updated_at":"2026-01-01T22:45:50.811341-05:00","closed_at":"2026-01-01T22:45:50.811341-05:00","close_reason":"Replaced by unified group TUI - see taspr-7mu for revised plan","dependencies":[{"issue_id":"taspr-q9i","depends_on_id":"taspr-7mu","type":"parent-child","created_at":"2025-12-25T14:34:01.994481-05:00","created_by":"daemon"}]}
{"id":"taspr-sjh","title":"Clean command for orphaned branches and PRs","description":"## Goal\nCreate a `taspr clean` command that finds and removes orphaned branches and PRs that are no longer needed.\n\n## Background\nAfter PRs are merged (either via `taspr land` or GitHub UI), there may be orphaned:\n- Remote branches matching our naming pattern (e.g., `taspr/\u003cusername\u003e/\u003ccommit-id\u003e`)\n- Closed/merged PRs whose branches still exist\n\nThe `sync` command now handles cleanup for PRs that are in the local stack, but there may be orphaned branches from:\n- PRs merged on other machines\n- Branches pushed but never turned into PRs\n- Old stacks that were abandoned\n\n## Implementation\n\n### Branch Pattern\nTaspr branches follow the pattern: `taspr/\u003cusername\u003e/\u003c8-char-id\u003e`\n\n### Detection Logic\n1. List all remote branches matching `taspr/*` pattern\n2. For each branch:\n   - Check if the branch's HEAD commit is reachable from the default branch (merged)\n   - If merged, the branch is orphaned and can be deleted\n3. Optionally also find and close any open PRs for those branches\n\n### Command Interface\n```\ntaspr clean [--dry-run] [--include-prs]\n\nOptions:\n  --dry-run      Show what would be cleaned without actually deleting\n  --include-prs  Also close any open PRs for orphaned branches (default: only delete branches)\n```\n\n### Output\n```\n$ taspr clean --dry-run\n\nFound 3 orphaned branches:\n  taspr/user/a1b2c3d4 (merged to main)\n  taspr/user/e5f6g7h8 (merged to main)\n  taspr/user/i9j0k1l2 (merged to main)\n\nRun without --dry-run to delete these branches.\n\n$ taspr clean\n\nâœ“ Deleted 3 orphaned branches:\n  taspr/user/a1b2c3d4\n  taspr/user/e5f6g7h8\n  taspr/user/i9j0k1l2\n```\n\n## Testing\nWrite integration tests that:\n1. Create branches and PRs\n2. Merge PRs via GitHub API (simulating GitHub UI merge without branch deletion)\n3. Run `taspr clean` and verify orphaned branches are detected/deleted\n4. Use the existing `github-fixture.ts` pattern for GitHub integration tests\n\n## Files to Create/Modify\n- src/cli/commands/clean.ts (new)\n- src/cli/index.ts (add command)\n- tests/integration/clean.test.ts (new)\n\n## Acceptance Criteria\n- [ ] Detects orphaned branches matching taspr pattern\n- [ ] Correctly identifies merged branches (commit reachable from default branch)\n- [ ] --dry-run shows what would be deleted without deleting\n- [ ] Deletes orphaned branches when run without --dry-run\n- [ ] Integration test covers the full workflow","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-31T00:37:02.656048-05:00","updated_at":"2025-12-31T13:47:36.955276-05:00","closed_at":"2025-12-31T13:47:36.955276-05:00","close_reason":"Implementation already complete with all acceptance criteria met: clean command in src/cli/commands/clean.ts, registered in CLI, and comprehensive integration tests in tests/integration/clean.test.ts"}
{"id":"taspr-tiz","title":"Behind detection (stack vs main)","description":"## Goal\nDetect when the stack is behind origin/main and needs rebasing.\n\n## Implementation\n\n```typescript\n// src/git/rebase.ts\n\nasync function isStackBehindMain(): Promise\u003cboolean\u003e {\n  const defaultBranch = await getDefaultBranch();\n  \n  // Fetch latest\n  await $\\`git fetch origin \\${defaultBranch}\\`;\n  \n  // Get merge-base\n  const mergeBase = await $\\`git merge-base HEAD origin/\\${defaultBranch}\\`.text();\n  \n  // Get current main tip\n  const mainTip = await $\\`git rev-parse origin/\\${defaultBranch}\\`.text();\n  \n  // If merge-base != main tip, we're behind\n  return mergeBase.trim() !== mainTip.trim();\n}\n\nasync function getCommitsBehind(): Promise\u003cnumber\u003e {\n  const defaultBranch = await getDefaultBranch();\n  const result = await $\\`git rev-list HEAD..origin/\\${defaultBranch} --count\\`.text();\n  return parseInt(result.trim(), 10);\n}\n```\n\n## Usage in Sync\n```typescript\nasync function sync() {\n  const behind = await isStackBehindMain();\n  \n  if (behind) {\n    const count = await getCommitsBehind();\n    console.log(\\`Stack is \\${count} commit(s) behind origin/main\\`);\n    \n    // Proceed with rebase...\n  }\n}\n```\n\n## Testing\n- Stack is up to date\n- Stack is behind by N commits\n- Stack has diverged (both ahead and behind)\n\n## Files to Create\n- src/git/rebase.ts\n\n## Acceptance Criteria\n- [ ] Detects when stack is behind\n- [ ] Reports number of commits behind\n- [ ] Fetches latest before checking","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-25T14:36:13.294509-05:00","updated_at":"2025-12-31T13:59:29.327102-05:00","closed_at":"2025-12-31T13:59:29.327102-05:00","close_reason":"Implemented src/git/behind.ts with isStackBehindMain() and getCommitsBehind() functions. All 6 unit tests passing.","dependencies":[{"issue_id":"taspr-tiz","depends_on_id":"taspr-a64","type":"parent-child","created_at":"2025-12-25T14:36:17.346843-05:00","created_by":"daemon"}]}
{"id":"taspr-v0c","title":"Epic 6: View PR Status from GitHub","description":"## Goal\nShow rich status information from GitHub in `taspr view`.\n\n## Background\nAfter the MVP (Epics 1-5), taspr can create and land PRs. This epic enhances feedback by showing:\n- CI check status\n- Review approval status\n- Comment thread resolution\n\nThis helps users know at a glance whether PRs are ready to land.\n\n## Enhanced View Output\n\n```\n$ taspr view\n\nStack: feature/auth (4 commits, 3 PRs)\n\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  âœ“ #142 Add user model\n    â””â”€ a1b2c3d4\n    https://github.com/org/repo/pull/142\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  â— #143 Authentication feature            ğŸ’¬ 3/5  â³ checks\n    â”œâ”€ b2c3d4e5 Add login endpoint\n    â”œâ”€ c3d4e5f6 Add password validation  \n    â””â”€ d4e5f6a7 Add 2FA support\n    https://github.com/org/repo/pull/143\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  â— #144 Add admin dashboard               ğŸ‘€ review\n    â””â”€ e5f6a7b8\n    https://github.com/org/repo/pull/144\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  â†“ origin/main\n```\n\n### Status Indicators\n- `âœ“` Merged\n- `â—` Open\n- `â—‹` No PR yet\n- `âœ—` Closed (not merged)\n- `!` Conflict or error state\n\n### Blocking Indicators\n- `ğŸ’¬ 3/5` â€” 3 of 5 comment threads resolved\n- `â³ checks` â€” CI checks still running\n- `âœ— checks` â€” CI checks failed\n- `ğŸ‘€ review` â€” Awaiting review approval\n\n## Deliverable\n`taspr view` shows check status, review status, and comment resolution for each PR.\n\n## Dependencies\n- Epic 4 must be complete (view command with basic PR info)\n\n## Priority\nP2 - Enhancement after MVP is complete.","status":"closed","priority":2,"issue_type":"epic","created_at":"2025-12-25T14:32:11.233973-05:00","updated_at":"2025-12-31T14:40:45.00116-05:00","closed_at":"2025-12-31T14:40:45.00116-05:00","close_reason":"All children completed","dependencies":[{"issue_id":"taspr-v0c","depends_on_id":"taspr-1ni","type":"blocks","created_at":"2025-12-25T14:32:14.956989-05:00","created_by":"daemon"},{"issue_id":"taspr-v0c","depends_on_id":"taspr-1ni","type":"depends-on","created_at":"2025-12-25T14:32:14.956989-05:00","created_by":"daemon"}]}
{"id":"taspr-vpx","title":"Add command field to TasprResult interface","description":"Read the parent epic taspr-ww0 for full context.\n\n## Task\nExtend the TasprResult interface in tests/integration/helpers.ts to include the exact command that was executed.\n\n## Changes\n\n1. Rename TasprResult to CommandResult (or keep both with CommandResult extending TasprResult)\n\n2. Add command field to the interface\n\n3. Update runTaspr() to build and return the command string by constructing it from the command and args parameters\n\n4. The convenience wrappers (runSync, runView, runLand, runClean) already call runTaspr so they will automatically return the new type.\n\n## Files\n- tests/integration/helpers.ts\n\n## Acceptance\n- All existing tests still pass\n- CommandResult includes the command field with the exact CLI invocation","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T00:33:02.064802-05:00","updated_at":"2026-01-05T00:33:02.064802-05:00","dependencies":[{"issue_id":"taspr-vpx","depends_on_id":"taspr-ww0","type":"parent-child","created_at":"2026-01-05T00:33:43.80368-05:00","created_by":"dondenton"}]}
{"id":"taspr-vua","title":"Add taspr group --fix command to repair invalid group trailers","description":"After resolving rebase conflicts (especially when commits at group boundaries are removed), group trailers can become invalid. Add a --fix flag to taspr group that:\n\n1. Detects invalid group trailer states:\n   - Taspr-Group-Start without matching Taspr-Group-End\n   - Taspr-Group-End without matching Taspr-Group-Start\n   - Orphaned Taspr-Group-Title trailers\n   \n2. Offers repair options:\n   - Remove all group trailers from affected commits (reset to ungrouped)\n   - Attempt to repair by finding the closest valid group boundary\n   \n3. Can run non-interactively with --fix=remove or --fix=repair\n\nThis helps users recover after conflict resolution without needing to manually edit commit messages.","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-02T10:18:12.109801-05:00","updated_at":"2026-01-02T11:19:48.724327-05:00","closed_at":"2026-01-02T11:19:48.724327-05:00","close_reason":"Implemented taspr group --fix command: detects invalid groups (unclosed, overlapping, orphan ends) and removes all group trailers to repair. Added 5 integration tests."}
{"id":"taspr-w8i","title":"Update sync message to show only changed branches count","description":"Currently sync shows 'Pushing N branch(es)...' where N is the total number of PR units. It should instead show only the count of branches that actually have changes to push, not branches that are already up-to-date.","status":"open","priority":3,"issue_type":"feature","created_at":"2025-12-29T20:42:51.590536-05:00","updated_at":"2025-12-29T20:42:56.146797-05:00"}
{"id":"taspr-ww0","title":"Story test logging for integration tests","description":"Create narrative markdown files during integration test runs that tell the story of each test scenario in plain English, followed by the CLI output. This enables UI state review and potential documentation generation.\n\n## Design Decisions\n- **File structure**: One MD file per test file (e.g., `test-logs/sync.md`)\n- **Color handling**: Generate both `.md` (clean) and `.ansi` (colored) versions\n- **Activation**: Opt-in via `TASPR_STORY_TEST_LOGGING=1` environment variable\n- **Narrative source**: Manual annotations in test code using a story API\n- **Context style**: Describe scenarios contextually (\"If you are on a feature branch...\") not mechanically (\"Create a feature branch\")\n\n## Technical Approach\n\n### 1. Enhance Run Helpers (`tests/integration/helpers.ts`)\nExtend `TasprResult` to `CommandResult` which includes the exact command string:\n\n```typescript\nexport interface CommandResult {\n  command: string;  // e.g., \"taspr sync --open\"\n  stdout: string;\n  stderr: string;\n  exitCode: number;\n}\n```\n\nThe `runTaspr()` function builds and returns the command string, eliminating sync issues between what's logged and what's run.\n\n### 2. Story API (`tests/helpers/story.ts`)\n\n```typescript\nexport interface Story {\n  begin(testName: string): void;\n  narrate(text: string): void;\n  log(result: CommandResult): void;\n  end(): void;\n  flush(): Promise\u003cvoid\u003e;\n}\n```\n\nInternally uses interleaved entries:\n```typescript\ntype StoryEntry =\n  | { type: \"narrate\"; text: string }\n  | { type: \"command\"; result: CommandResult };\n```\n\n### 3. Output Format Example\n\n**test-logs/sync.md**:\n```markdown\n# Sync Command Stories\n\n---\n\n## skips PR creation for WIP commits\n\nIf you have a commit prefixed with 'WIP:', taspr will skip creating a PR for it.\n\n### `taspr sync --open`\n\n\\`\\`\\`\nSkipped PR for 1 temporary commit\n  - WIP: work in progress\n\\`\\`\\`\n\n---\n```\n\n### 4. Test Integration Example\n\n```typescript\nimport { createStory } from \"../helpers/story.ts\";\n\ndescribe(\"sync command\", () =\u003e {\n  const story = createStory(\"sync.test.ts\");\n\n  afterAll(async () =\u003e {\n    await story.flush();\n  });\n\n  test(\"skips PR creation for WIP commits\", async () =\u003e {\n    story.begin(\"skips PR creation for WIP commits\");\n    story.narrate(\"If you have a commit prefixed with 'WIP:', taspr will skip creating a PR for it.\");\n\n    const repo = await repos.clone({ testName: \"wip-skip\" });\n    await repo.branch(\"feature/wip-test\");\n    await repo.commit({ message: \"WIP: work in progress\" });\n\n    const result = await runSync(repo.path, { open: true });\n    story.log(result);\n    story.end();\n\n    expect(result.exitCode).toBe(0);\n  });\n});\n```\n\n## Key Principles\n- Stories focus on what's being demonstrated, not mechanical setup steps\n- Err on the side of showing less; add git output only if it adds clarity for a specific test\n- No generic `runGit()` wrapper needed; tests continue using existing git interaction patterns","status":"open","priority":2,"issue_type":"epic","created_at":"2026-01-05T00:32:39.570413-05:00","updated_at":"2026-01-05T00:32:39.570413-05:00"}
{"id":"taspr-xtq","title":"VCR-style testing for GitHub API calls","description":"## Goal\nImplement VCR-style (record/replay) testing infrastructure for testing code that calls the GitHub API via the `gh` CLI.\n\n## Background\nThe sync command with `--open` flag makes calls to:\n- `gh api user --jq .login` (get username)\n- `gh pr list --head \u003cbranch\u003e` (find existing PRs)  \n- `gh pr create` (create new PRs)\n\nThese calls can't be tested in CI without real GitHub auth. VCR-style testing records real CLI outputs and replays them in tests.\n\n## Approach: Shell Executor Abstraction\n\nAfter researching HTTP-level options (nock, MSW), we determined CLI-level recording is the right approach because:\n- The code shells out to `gh` CLI, not HTTP directly\n- HTTP mocking would require proxying subprocess traffic (complex)\n- CLI-level captures real responses with simpler implementation\n- No battle-tested CLI VCR library exists, so we build our own\n\n## Architecture\n\n### Key Interfaces\n\n```typescript\ninterface ShellResult {\n  stdout: Buffer;\n  stderr: Buffer;\n  exitCode: number;\n}\n\ninterface ShellExecutor {\n  exec(command: string, args: string[]): Promise\u003cShellResult\u003e;\n}\n\ninterface Cassette {\n  name: string;\n  entries: FixtureEntry[];  // {command, args, stdout, stderr, exitCode}\n  recordedAt: string;\n}\n```\n\n### Three Executor Implementations\n\n1. **RealExecutor** - Runs actual commands via Bun's `$`\n2. **RecordingExecutor** - Wraps RealExecutor, saves responses to cassette file\n3. **ReplayExecutor** - Reads from cassette file, matches command+args exactly\n\n### Cassette Format (JSON)\n```json\n{\n  \"name\": \"github-auth\",\n  \"entries\": [\n    {\n      \"command\": \"gh\",\n      \"args\": [\"api\", \"user\", \"--jq\", \".login\"],\n      \"stdout\": \"base64-encoded-output\",\n      \"stderr\": \"\",\n      \"exitCode\": 0\n    }\n  ],\n  \"recordedAt\": \"2024-12-27T20:00:00.000Z\"\n}\n```\n\n## File Structure\n\n```\nsrc/testing/vcr/\n  types.ts          # ShellResult, ShellExecutor, Cassette interfaces\n  executor.ts       # RealExecutor, RecordingExecutor, ReplayExecutor\n  index.ts          # Public exports\n  executor.test.ts  # Self-tests using echo/sh commands (not gh!)\n\ntests/\n  fixtures/cassettes/     # JSON cassette files\n  helpers/vcr-fixture.ts  # withVCR() test helper\n```\n\n## Implementation Phases\n\n### Phase 1: Core VCR Library (test with echo/sh, not gh)\n1. Create `src/testing/vcr/types.ts` - interfaces\n2. Create `src/testing/vcr/executor.ts` - three executor implementations\n3. Create `src/testing/vcr/index.ts` - exports\n4. Create `src/testing/vcr/executor.test.ts` - self-tests\n\n### Phase 2: Test Helper\n1. Create `tests/fixtures/cassettes/` directory\n2. Create `tests/helpers/vcr-fixture.ts` with `withVCR()` helper\n\n### Phase 3: Refactor GitHub Module\nAdd optional `executor` parameter (backward compatible):\n1. `src/github/api.ts` - getGitHubUsername(), getDefaultBranch()\n2. `src/github/pr.ts` - findPRByBranch(), createPR()\n3. `src/github/branches.ts` - getBranchNameConfig()\n\n### Phase 4: Record Fixtures \u0026 Add Tests\n1. Run in record mode against real GitHub to create cassettes\n2. Add VCR tests for `--open` flag in `sync.test.ts`\n\n## Files to Modify\n- src/github/api.ts - add executor injection\n- src/github/pr.ts - add executor injection\n- src/github/branches.ts - add executor injection\n- src/cli/commands/sync.test.ts - add --open tests (has TODO comment)\n\n## Files to Create\n- src/testing/vcr/types.ts\n- src/testing/vcr/executor.ts\n- src/testing/vcr/index.ts\n- src/testing/vcr/executor.test.ts\n- tests/helpers/vcr-fixture.ts\n- tests/fixtures/cassettes/*.json\n\n## Testing Strategy for VCR Library Itself\nThe VCR library must be tested without circular dependencies. Use predictable shell commands:\n- `echo hello` â†’ captures stdout\n- `sh -c 'exit 42'` â†’ captures exit codes\n- `sh -c 'echo error \u003e\u00262'` â†’ captures stderr\n\n## Acceptance Criteria\n- [ ] VCR library has passing self-tests (executor.test.ts)\n- [ ] GitHub functions accept optional executor parameter\n- [ ] Recording mode captures real gh responses to cassettes\n- [ ] Replay mode uses recorded fixtures (no network)\n- [ ] sync --open has comprehensive tests using VCR","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-26T23:41:07.092299-05:00","updated_at":"2025-12-27T20:45:04.334294-05:00"}
{"id":"taspr-y3n","title":"Install and configure oxlint","description":"Install oxlint (Oxc's fast JavaScript/TypeScript linter) and configure it for the project. This includes adding the package, creating configuration files, and setting up npm scripts.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-26T01:04:38.694306-05:00","updated_at":"2025-12-26T01:24:31.975995-05:00","closed_at":"2025-12-26T01:24:31.975995-05:00","close_reason":"Installed oxlint v1.35.0 and configured with default rules. Added lint script to package.json."}
{"id":"taspr-ybr","title":"Conflict recovery (continue after manual fix)","description":"## Goal\nHandle the workflow after user manually resolves conflicts.\n\n## Background\nWhen sync hits a conflict:\n1. User manually resolves\n2. User runs `git add` + `git rebase --continue`\n3. User runs `taspr sync` again\n\ntaspr needs to:\n- Detect if we're mid-rebase\n- Continue or restart as appropriate\n\n## Implementation\n\n```typescript\n// src/cli/commands/sync.ts\n\nasync function sync() {\n  // Check for ongoing rebase\n  const conflict = await getConflictInfo();\n  \n  if (conflict) {\n    console.log('Detected ongoing rebase conflict.');\n    console.log('');\n    console.log(formatConflictError(conflict));\n    process.exit(1);\n  }\n  \n  // Normal sync flow...\n}\n```\n\n### Post-Rebase Flow\nAfter user completes `git rebase --continue`:\n1. Stack is rebased onto new main\n2. All commit hashes have changed\n3. Running `taspr sync` should:\n   - Update all branches with new hashes\n   - Report which PRs were updated\n\n```typescript\nasync function sync() {\n  // ... conflict check ...\n  \n  // After successful rebase or no rebase needed\n  const statuses = await getAllSyncStatuses(units);\n  \n  const updated = [];\n  for (const [id, status] of statuses) {\n    if (status.needsUpdate) {\n      await forcePushBranch(status.localCommit, status.branchName);\n      updated.push(status.branchName);\n    }\n  }\n  \n  if (updated.length \u003e 0) {\n    console.log(\\`âœ“ Updated \\${updated.length} PR branch(es)\\`);\n  }\n}\n```\n\n## Testing\n- Sync detects mid-rebase state\n- Sync after rebase --continue updates branches\n- All PRs reflect new commits\n\n## Files to Modify\n- src/cli/commands/sync.ts\n- src/git/rebase.ts\n\n## Acceptance Criteria\n- [ ] Detects ongoing conflict and exits with instructions\n- [ ] After manual resolution, sync updates all branches\n- [ ] Clear feedback on what was updated","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-25T14:37:00.272928-05:00","updated_at":"2025-12-31T14:15:52.361656-05:00","closed_at":"2025-12-31T14:15:52.361656-05:00","close_reason":"Closed","dependencies":[{"issue_id":"taspr-ybr","depends_on_id":"taspr-a64","type":"parent-child","created_at":"2025-12-25T14:37:04.660065-05:00","created_by":"daemon"},{"issue_id":"taspr-ybr","depends_on_id":"taspr-d6b","type":"blocks","created_at":"2025-12-25T14:37:04.935834-05:00","created_by":"daemon"},{"issue_id":"taspr-ybr","depends_on_id":"taspr-d6b","type":"depends-on","created_at":"2025-12-25T14:37:04.935834-05:00","created_by":"daemon"}]}
{"id":"taspr-ycg","title":"Create Story API and logger","description":"Read the parent epic taspr-ww0 for full context.\n\n## Task\nCreate the Story API in tests/helpers/story.ts that allows tests to log narratives and command outputs.\n\n## Interface\n\n```\ninterface Story {\n  begin(testName: string): void;\n  narrate(text: string): void;\n  log(result: CommandResult): void;\n  end(): void;\n  flush(): Promise\u003cvoid\u003e;\n}\n```\n\n## Implementation\n\nStoryLogger class that:\n- Checks TASPR_STORY_TEST_LOGGING=1 env var to enable/disable\n- Buffers entries as interleaved narrate/command entries\n- On flush(), writes both .md (ANSI stripped) and .ansi (colors preserved) to test-logs/\n- Uses stripAnsi regex: /\\x1b\\[[0-9;]*m/g\n\n## Output Format\n\nEach story section in the markdown:\n```\n---\n\n## {testName}\n\n{narrative text}\n\n### `{command}`\n\n```\n{stdout}\n```\n\n---\n```\n\n## Files\n- tests/helpers/story.ts (new file)\n\n## Acceptance\n- Story API works when env var is set\n- No-ops silently when env var is not set\n- Generates readable markdown output","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-05T00:33:10.602497-05:00","updated_at":"2026-01-05T00:33:10.602497-05:00","dependencies":[{"issue_id":"taspr-ycg","depends_on_id":"taspr-ww0","type":"parent-child","created_at":"2026-01-05T00:33:43.849223-05:00","created_by":"dondenton"},{"issue_id":"taspr-ycg","depends_on_id":"taspr-vpx","type":"blocks","created_at":"2026-01-05T00:33:48.112626-05:00","created_by":"dondenton"}]}
{"id":"taspr-z6z","title":"Add documentation for temp commit prefixes","description":"Document the taspr.tempCommitPrefixes git config option in the GitHub wiki/README. Explain:\n- Default prefixes (WIP, fixup!, amend!, squash!)\n- How to customize: git config taspr.tempCommitPrefixes \"WIP,DRAFT\"\n- How to disable: git config taspr.tempCommitPrefixes \"\"\n- Behavior: branches still pushed for stacking, but PRs not created\n- Escape hatch: grouping allows PR creation\n\nAlso: Update TEMP_COMMITS_DOC_URL placeholder in src/cli/commands/sync.ts with the real URL.","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-03T13:43:16.051082-05:00","updated_at":"2026-01-03T14:04:47.296143-05:00","closed_at":"2026-01-03T14:04:47.296143-05:00","close_reason":"Added documentation to README.md under Configuration \u003e Temporary Commits section. Includes config examples, default prefixes, behavior description, and fixup! workflow example. Updated TEMP_COMMITS_DOC_URL placeholder with actual GitHub link."}
{"id":"taspr-z8e","title":"README and documentation","description":"## Goal\nCreate comprehensive README and documentation for users to understand and use taspr.\n\n## README.md Structure\n\n```markdown\n# taspr\n\nStacked PR management for GitHub. Each commit becomes a PR, properly stacked.\n\n## What is taspr?\n\ntaspr manages \"stacked PRs\" - a workflow where you create a chain of dependent pull requests, each building on the one before it. This enables:\n\n- **Incremental reviews**: Small, focused PRs are easier to review\n- **Logical commits**: Keep your local history clean and meaningful\n- **Fast iteration**: Land PRs as they\\'re approved without waiting for the whole stack\n\n## Quick Start\n\n\\`\\`\\`bash\n# Install\ncurl -fsSL https://raw.githubusercontent.com/OWNER/taspr/main/install.sh | bash\n\n# In your repo, create some commits\ngit commit -m \"Add user model\"\ngit commit -m \"Add user API endpoints\"\ngit commit -m \"Add user UI components\"\n\n# View your stack\ntaspr view\n\n# Push to GitHub as stacked PRs\ntaspr sync\n\n# After bottom PR is approved, land it\ntaspr land\n\\`\\`\\`\n\n## Prerequisites\n\n- **git** - You probably have this\n- **gh** - GitHub CLI for authentication ([install](https://cli.github.com))\n\n## Installation\n\n### Quick Install (recommended)\n\\`\\`\\`bash\ncurl -fsSL https://raw.githubusercontent.com/OWNER/taspr/main/install.sh | bash\n\\`\\`\\`\n\n### Manual Download\nDownload the appropriate binary from [Releases](https://github.com/OWNER/taspr/releases):\n- macOS Intel: `taspr-darwin-x64`\n- macOS Apple Silicon: `taspr-darwin-arm64`\n- Linux x64: `taspr-linux-x64`\n- Linux ARM64: `taspr-linux-arm64`\n\n## How It Works\n\n### The Stack Model\n\nBy default, each commit in your branch becomes its own PR:\n\n\\`\\`\\`\nmain\n  â”‚\n  â”œâ”€â”€ Commit A  â†’  PR #1 (base: main)\n  â”‚     â”‚\n  â”‚     â””â”€â”€ Commit B  â†’  PR #2 (base: PR #1\\'s branch)\n  â”‚           â”‚\n  â”‚           â””â”€â”€ Commit C  â†’  PR #3 (base: PR #2\\'s branch)\n\\`\\`\\`\n\nWhen PR #1 merges, GitHub automatically retargets PR #2 to main.\n\n### Commit Tracking\n\ntaspr adds a trailer to each commit to track it across rebases:\n\\`\\`\\`\nfeat: add user authentication\n\nTaspr-Commit-Id: a1b2c3d4\n\\`\\`\\`\n\n### Groups (Optional)\n\nGroup multiple commits into a single PR:\n\\`\\`\\`bash\ntaspr group create\n# Select commits interactively\n\\`\\`\\`\n\n## Commands\n\n### `taspr view`\nShow your current stack structure and PR status.\n\n\\`\\`\\`bash\ntaspr view          # Current branch\ntaspr view --all    # All branches with stacks\n\\`\\`\\`\n\n### `taspr sync`\nPush your stack to GitHub, creating or updating PRs.\n\n\\`\\`\\`bash\ntaspr sync          # Push and create PRs\ntaspr sync --open   # Also open new PRs in browser\n\\`\\`\\`\n\n### `taspr land`\nMerge the bottom PR to main.\n\n\\`\\`\\`bash\ntaspr land          # Land bottom ready PR\ntaspr land --all    # Land all consecutive ready PRs\n\\`\\`\\`\n\n### `taspr group`\nManage commit groups.\n\n\\`\\`\\`bash\ntaspr group create    # Create a new group\ntaspr group edit      # Edit existing group\ntaspr group dissolve  # Remove a group\n\\`\\`\\`\n\n## Configuration\n\ntaspr uses git config for settings:\n\n\\`\\`\\`bash\n# Branch prefix (default: taspr)\ngit config taspr.prefix mystacks\n\n# Default base branch (default: detected from origin)\ngit config taspr.baseBranch main\n\\`\\`\\`\n\n## Tips\n\n### Amending Commits\nAfter amending a commit, run `taspr sync` to update the corresponding PR.\n\n### Rebasing\nWhen you rebase, commit IDs are preserved (they\\'re in trailers, not hashes). Just `taspr sync` after rebasing.\n\n### Inserting Commits\nAdd a commit anywhere in your stack, then `taspr sync`. New commits automatically get their own PRs.\n\n## Troubleshooting\n\n### \"gh not authenticated\"\nRun `gh auth login` to authenticate with GitHub.\n\n### \"Cannot sync - uncommitted changes\"\nCommit or stash your changes before running sync.\n\n### PRs showing wrong diff\nThis usually means your stack got out of sync. Run `taspr sync` to update all PR branches.\n\n## License\n\nMIT\n\\`\\`\\`\n\n## Additional Documentation\n\n### CLAUDE.md (for AI-assisted development)\n```markdown\n# taspr\n\nBun-powered stacked PR CLI for GitHub.\n\n## Commands\n\\`\\`\\`bash\nbun run dev          # Watch mode\nbun run build        # Build all platform binaries\nbun run test         # Run tests\nbun run typecheck    # Type validation\n\\`\\`\\`\n\n## Structure\n- src/cli/ - Command implementations\n- src/core/ - Business logic\n- src/git/ - Git operations\n- src/github/ - GitHub API via gh CLI\n- src/types.ts - TypeScript interfaces\n\n## Conventions\n- Strict TypeScript\n- Bun Shell ($\\`\\`) for git commands\n- Tests mirror src/ structure\n- gh CLI for all GitHub operations\n\\`\\`\\`\n\n## Acceptance Criteria\n- [ ] README explains what taspr is and why to use it\n- [ ] Quick start gets users going in \u003c2 minutes\n- [ ] All commands documented with examples\n- [ ] Troubleshooting covers common issues\n- [ ] Installation instructions for all platforms\n- [ ] CLAUDE.md helps AI-assisted development\n- [ ] Configuration options documented","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-25T15:01:25.505428-05:00","updated_at":"2025-12-25T15:01:25.505428-05:00","dependencies":[{"issue_id":"taspr-z8e","depends_on_id":"taspr-8iv","type":"parent-child","created_at":"2025-12-25T15:01:37.920096-05:00","created_by":"daemon"}]}
{"id":"taspr-zqh","title":"Git config options","description":"## Goal\nSupport configuration via git config for branch prefix and default branch.\n\n## Configuration Options\n\n### taspr.branchPrefix\nCustom prefix for branch names (default: \"taspr\"):\n```bash\ngit config taspr.branchPrefix jaspr\n# Produces: jaspr/msims/a1b2c3d4 instead of taspr/msims/a1b2c3d4\n```\n\n### taspr.defaultBranch\nDefault branch to stack on (default: auto-detect from origin):\n```bash\ngit config taspr.defaultBranch main\n```\n\n## Implementation\n\n```typescript\n// src/git/config.ts\n\ninterface TasprConfig {\n  branchPrefix: string;\n  defaultBranch: string;\n}\n\nasync function getTasprConfig(): Promise\u003cTasprConfig\u003e {\n  const [prefixResult, defaultResult] = await Promise.all([\n    $\\`git config --get taspr.branchPrefix\\`.nothrow(),\n    $\\`git config --get taspr.defaultBranch\\`.nothrow(),\n  ]);\n  \n  const prefix = prefixResult.exitCode === 0 \n    ? prefixResult.stdout.toString().trim() \n    : 'taspr';\n    \n  let defaultBranch: string;\n  if (defaultResult.exitCode === 0) {\n    defaultBranch = defaultResult.stdout.toString().trim();\n  } else {\n    // Auto-detect from origin\n    defaultBranch = await detectDefaultBranch();\n  }\n  \n  return { branchPrefix: prefix, defaultBranch };\n}\n\nasync function detectDefaultBranch(): Promise\u003cstring\u003e {\n  // Method 1: Check remote HEAD\n  const result = await $\\`git symbolic-ref refs/remotes/origin/HEAD\\`.nothrow();\n  if (result.exitCode === 0) {\n    const ref = result.stdout.toString().trim();\n    return ref.replace('refs/remotes/origin/', '');\n  }\n  \n  // Method 2: Common defaults\n  for (const branch of ['main', 'master']) {\n    const exists = await $\\`git rev-parse --verify origin/\\${branch}\\`.nothrow();\n    if (exists.exitCode === 0) return branch;\n  }\n  \n  throw new Error('Could not detect default branch. Set it with: git config taspr.defaultBranch \u003cbranch\u003e');\n}\n```\n\n### Usage\n```typescript\nconst config = await getTasprConfig();\nconst branchName = \\`\\${config.branchPrefix}/\\${username}/\\${prId}\\`;\nconst baseBranch = config.defaultBranch;\n```\n\n## Testing\n- Default prefix â†’ \"taspr\"\n- Custom prefix â†’ uses custom value\n- Default branch auto-detection\n- Custom default branch\n\n## Files to Create/Modify\n- src/git/config.ts (may already exist)\n\n## Acceptance Criteria\n- [ ] Reads branchPrefix from git config\n- [ ] Falls back to \"taspr\" if not set\n- [ ] Reads defaultBranch from git config\n- [ ] Auto-detects default branch from origin if not set\n- [ ] Clear error if can't detect default branch","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T14:30:16.504099-05:00","updated_at":"2025-12-29T20:59:08.647802-05:00","closed_at":"2025-12-29T20:59:08.647802-05:00","close_reason":"Implemented git config options for branchPrefix and defaultBranch. Created src/git/config.ts with getTasprConfig(), detectDefaultBranch(), and getDefaultBranchRef() functions. Updated commands.ts to use configurable default branch instead of hardcoded origin/main. Updated output.ts to display the configured default branch. All 86 tests pass.","dependencies":[{"issue_id":"taspr-zqh","depends_on_id":"taspr-1ni","type":"parent-child","created_at":"2025-12-25T14:30:20.288564-05:00","created_by":"daemon"}]}

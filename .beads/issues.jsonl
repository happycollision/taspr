{"id":"taspr-0du","title":"Land command (single PR)","description":"## Goal\nImplement `taspr land` to merge the bottom ready PR.\n\n## Implementation\n\n```typescript\n// src/cli/commands/land.ts\n\nexport const landCommand = new Command('land')\n  .description('Merge the bottom ready PR in the stack')\n  .option('--all', 'Merge all consecutive ready PRs')\n  .action(async (options) =\u003e {\n    // Parse stack and get PR info\n    const result = await parseStack();\n    if (!result.ok) {\n      console.error(formatValidationError(result));\n      process.exit(1);\n    }\n    \n    const config = await getBranchNameConfig();\n    const enrichedUnits = await enrichWithPRInfo(result.units, config);\n    \n    // Find bottom unmerged PR\n    const unmerged = enrichedUnits.filter(u =\u003e u.pr?.state === 'open');\n    if (unmerged.length === 0) {\n      console.log('No unmerged PRs in stack');\n      return;\n    }\n    \n    const bottom = unmerged[0];\n    \n    // Check if ready\n    const status = await getPRMergeStatus(bottom.pr!.number);\n    if (!status.mergeable) {\n      console.error(\\`âœ— PR #\\${bottom.pr!.number} is not ready:\\\\n\\`);\n      if (status.checksStatus === 'failing') {\n        console.error('  â€¢ CI checks failing');\n      }\n      if (status.reviewDecision !== 'approved') {\n        console.error('  â€¢ Needs approval');\n      }\n      process.exit(1);\n    }\n    \n    // Merge\n    console.log(\\`Merging PR #\\${bottom.pr!.number} (\\${bottom.title})...\\`);\n    const result = await mergePR(bottom.pr!.number);\n    console.log(\\`âœ“ Merged PR #\\${bottom.pr!.number} to main\\`);\n  });\n```\n\n## Output\n\n### Success\n```\n$ taspr land\n\nMerging PR #142 (Add user model)...\nâœ“ Merged PR #142 to main\n```\n\n### Not Ready\n```\n$ taspr land\n\nâœ— PR #142 is not ready:\n  â€¢ CI checks failing\n\nRun 'taspr view' to see status.\n```\n\n### No PRs\n```\n$ taspr land\n\nNo unmerged PRs in stack\n```\n\n## Testing\n- Land ready PR â†’ success\n- Land non-ready PR â†’ error with reason\n- Empty stack â†’ appropriate message\n\n## Files to Create\n- src/cli/commands/land.ts\n\n## Acceptance Criteria\n- [ ] Merges bottom open PR when ready\n- [ ] Clear error when PR not ready\n- [ ] Reports success with PR number\n- [ ] Handles empty stack","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-25T14:31:28.590491-05:00","updated_at":"2025-12-25T14:31:28.590491-05:00","dependencies":[{"issue_id":"taspr-0du","depends_on_id":"taspr-6le","type":"parent-child","created_at":"2025-12-25T14:31:32.341642-05:00","created_by":"daemon"},{"issue_id":"taspr-0du","depends_on_id":"taspr-bwi","type":"blocks","created_at":"2025-12-25T14:31:32.613862-05:00","created_by":"daemon"},{"issue_id":"taspr-0du","depends_on_id":"taspr-bwi","type":"depends-on","created_at":"2025-12-25T14:31:32.613862-05:00","created_by":"daemon"}]}
{"id":"taspr-0lj","title":"Project scaffolding and CLI setup","description":"## Goal\nSet up the Bun project structure, dependencies, and basic CLI scaffolding.\n\n## Tasks\n\n### 1. Initialize Bun project\n- Update package.json with proper metadata\n- Add dependencies: commander\n- Add devDependencies: @types/bun (already present)\n- Configure bun build for CLI compilation\n\n### 2. Create directory structure\n```\nsrc/\nâ”œâ”€â”€ cli/\nâ”‚   â”œâ”€â”€ index.ts          # Entry point\nâ”‚   â””â”€â”€ commands/         # Command implementations\nâ”œâ”€â”€ core/                 # Business logic\nâ”œâ”€â”€ git/                  # Git operations\nâ””â”€â”€ types.ts              # Shared types\ntests/\nâ”œâ”€â”€ helpers/              # Test utilities\nâ””â”€â”€ ...                   # Test files\n```\n\n### 3. Set up CLI with Commander\n- Create main entry point at src/cli/index.ts\n- Configure program name, version, description\n- Add placeholder commands: view, sync, land, group\n- Ensure `bun run src/cli/index.ts` works\n\n### 4. Configure TypeScript\n- Strict mode enabled (already in tsconfig.json)\n- Path aliases if needed\n- Ensure types work with Bun\n\n### 5. Set up test infrastructure\n- Configure bun:test\n- Create test helper for creating temporary git repositories\n- Add test scripts to package.json\n\n### 6. Add build script\n- `bun build --compile` for standalone binary\n- Cross-platform target support\n\n## Acceptance Criteria\n- [ ] Running `bun run src/cli/index.ts --help` shows help\n- [ ] Running `bun run src/cli/index.ts view` shows placeholder message\n- [ ] Running `bun test` executes a sample test\n- [ ] TypeScript compiles without errors\n\n## Files to Create/Modify\n- package.json (modify)\n- src/cli/index.ts (create)\n- src/cli/commands/view.ts (create - placeholder)\n- src/types.ts (create - empty or with basic interfaces)\n- tests/helpers/git-fixture.ts (create)\n- tests/sample.test.ts (create - simple test)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T14:22:10.925801-05:00","updated_at":"2025-12-25T23:42:42.674094-05:00","closed_at":"2025-12-25T23:42:42.674094-05:00","close_reason":"Closed","dependencies":[{"issue_id":"taspr-0lj","depends_on_id":"taspr-h87","type":"parent-child","created_at":"2025-12-25T14:22:18.35922-05:00","created_by":"daemon"}]}
{"id":"taspr-1en","title":"Fetch PR review status","description":"## Goal\nGet review approval status for PRs.\n\n## Implementation\n\n```typescript\n// src/github/pr.ts\n\ntype ReviewStatus = 'approved' | 'changes_requested' | 'pending';\n\nasync function getPRReviewStatus(prNumber: number): Promise\u003cReviewStatus\u003e {\n  const result = await $\\`gh pr view \\${prNumber} --json reviewDecision\\`;\n  const data = JSON.parse(result.stdout.toString());\n  \n  switch (data.reviewDecision) {\n    case 'APPROVED': return 'approved';\n    case 'CHANGES_REQUESTED': return 'changes_requested';\n    default: return 'pending';\n  }\n}\n```\n\n## Review Decision Values\n- `APPROVED` - Required reviewers approved\n- `CHANGES_REQUESTED` - Reviewer requested changes\n- `REVIEW_REQUIRED` - Waiting for reviews\n- `null` - No reviews required\n\n## Testing\n- PR with approved reviews\n- PR with changes requested\n- PR awaiting review\n- PR with no review requirements\n\n## Files to Modify\n- src/github/pr.ts\n\n## Acceptance Criteria\n- [ ] Returns correct review status\n- [ ] Handles PRs without review requirements\n- [ ] Handles multiple reviewers","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-25T14:32:34.466183-05:00","updated_at":"2025-12-25T14:32:34.466183-05:00","dependencies":[{"issue_id":"taspr-1en","depends_on_id":"taspr-v0c","type":"parent-child","created_at":"2025-12-25T14:32:38.0954-05:00","created_by":"daemon"}]}
{"id":"taspr-1es","title":"ID generation","description":"## Goal\nGenerate unique 8-character hex IDs for commits.\n\n## Implementation\n\n```typescript\n// src/core/id.ts\nimport { randomBytes } from 'crypto';\n\nexport function generateCommitId(): string {\n  return randomBytes(4).toString('hex');\n}\n```\n\n### Properties\n- 8 hex characters = 32 bits = 4 billion possibilities\n- Collision risk negligible for active stacks (typically \u003c 50 commits)\n- Once PRs merge, their IDs leave the active set\n\n### Usage Contexts\n1. `Taspr-Commit-Id` - Assigned to every commit\n2. `Taspr-Group-Start` / `Taspr-Group-End` - Marks group boundaries\n\nSame generation function, different semantic use.\n\n## Testing\n- Generate many IDs, verify format (8 hex chars)\n- Verify uniqueness over reasonable sample size\n\n## Files to Create\n- src/core/id.ts\n\n## Acceptance Criteria\n- [ ] Generates 8-character hex strings\n- [ ] Uses crypto for randomness\n- [ ] Has basic tests","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T14:24:45.726897-05:00","updated_at":"2025-12-26T21:03:50.523511-05:00","closed_at":"2025-12-26T21:03:50.523511-05:00","close_reason":"Implemented generateCommitId() in src/core/id.ts with tests","dependencies":[{"issue_id":"taspr-1es","depends_on_id":"taspr-7tr","type":"parent-child","created_at":"2025-12-25T14:24:49.603638-05:00","created_by":"daemon"}]}
{"id":"taspr-1ni","title":"Epic 4: Update PRs After Local Changes","description":"## Goal\nWhen commits change (amend, rebase), update the corresponding GitHub branches to keep PRs in sync.\n\n## Background\n\n### The Update Problem\nAfter commits are amended or rebased:\n- Commit hashes change\n- Local branch diverges from remote\n- PRs show stale code\n\ntaspr needs to detect these changes and force-push updated branches.\n\n### How Changes Are Detected\nCompare local commit hash to remote branch tip:\n```bash\ngit rev-parse taspr/user/a1b2c3d4  # Remote branch tip\ngit rev-parse HEAD~2               # Local commit for that PRUnit\n```\n\nIf they differ, the branch needs updating.\n\n## Workflow\n\n1. User amends a commit or rebases\n2. User runs `taspr sync`\n3. For each PRUnit:\n   - Compare local commit to remote branch\n   - If different, force-push the branch\n4. Report updated branches/PRs\n\n## Implementation Approach\n\n### Change Detection\n```typescript\nasync function getBranchCommit(branchName: string): Promise\u003cstring | null\u003e {\n  const result = await $\\`git rev-parse origin/${branchName}\\`.nothrow();\n  return result.exitCode === 0 ? result.stdout.toString().trim() : null;\n}\n\nasync function needsUpdate(unit: PRUnit, branchName: string): Promise\u003cboolean\u003e {\n  const remote = await getBranchCommit(branchName);\n  const local = unit.commits[unit.commits.length - 1];\n  return remote !== local;\n}\n```\n\n### Force Push\n```typescript\nasync function updateBranch(commitHash: string, branchName: string): Promise\u003cvoid\u003e {\n  await $\\`git push --force origin ${commitHash}:refs/heads/${branchName}\\`;\n}\n```\n\n## Deliverable\nRunning `taspr sync` force-pushes branches where commit hashes changed, keeping PRs in sync with local state.\n\n## Dependencies\n- Epic 3 must be complete (branches and PRs exist)\n\n## MVP Note\nAfter Epic 4, you have a working MVP:\n- Create commits with IDs\n- Push as stacked PRs\n- Update PRs when local commits change\n\n## Testable Outcome\nAmending a commit and running sync updates the PR on GitHub.","status":"open","priority":1,"issue_type":"epic","created_at":"2025-12-25T14:29:07.59809-05:00","updated_at":"2025-12-25T14:29:07.59809-05:00","dependencies":[{"issue_id":"taspr-1ni","depends_on_id":"taspr-osw","type":"blocks","created_at":"2025-12-25T14:29:12.092882-05:00","created_by":"daemon"},{"issue_id":"taspr-1ni","depends_on_id":"taspr-osw","type":"depends-on","created_at":"2025-12-25T14:29:12.092882-05:00","created_by":"daemon"}]}
{"id":"taspr-1zp","title":"Land --all flag","description":"## Goal\nImplement `taspr land --all` to merge all consecutive ready PRs.\n\n## Behavior\nMerge PRs from the bottom up, stopping at the first non-ready PR.\n\n```\nStack: [#142 ready] â†’ [#143 ready] â†’ [#144 not ready] â†’ [#145 ready]\n\ntaspr land --all merges #142 and #143, then stops at #144.\n```\n\n## Implementation\n\n```typescript\nasync function landAll() {\n  const units = await getEnrichedPRUnits();\n  \n  let merged = 0;\n  \n  for (const unit of units) {\n    if (unit.pr?.state !== 'open') continue;\n    \n    const status = await getPRMergeStatus(unit.pr.number);\n    \n    if (!status.mergeable) {\n      if (merged \u003e 0) {\n        console.log(\\`\\\\nStopping at PR #\\${unit.pr.number} (not ready)\\`);\n      }\n      break;\n    }\n    \n    console.log(\\`Merging PR #\\${unit.pr.number} (\\${unit.title})...\\`);\n    await mergePR(unit.pr.number);\n    console.log(\\`âœ“ Merged PR #\\${unit.pr.number} to main\\\\n\\`);\n    merged++;\n    \n    // Brief pause for GitHub to update\n    await sleep(1000);\n  }\n  \n  if (merged === 0) {\n    console.log('No ready PRs to merge');\n  } else {\n    console.log(\\`\\\\nâœ“ Merged \\${merged} PR(s)\\`);\n  }\n}\n```\n\n## Output\n```\n$ taspr land --all\n\nMerging PR #142 (Add user model)...\nâœ“ Merged PR #142 to main\n\nMerging PR #143 (Add authentication)...\nâœ“ Merged PR #143 to main\n\nStopping at PR #144 (not ready: CI failing)\n\nâœ“ Merged 2 PR(s)\n```\n\n## Testing\n- All ready â†’ merges all\n- Some ready â†’ merges until non-ready\n- None ready â†’ reports nothing to merge\n\n## Files to Modify\n- src/cli/commands/land.ts\n\n## Acceptance Criteria\n- [ ] Merges consecutive ready PRs\n- [ ] Stops at first non-ready PR\n- [ ] Reports total merged\n- [ ] Pauses between merges for GitHub sync","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-25T14:31:44.165633-05:00","updated_at":"2025-12-25T14:31:44.165633-05:00","dependencies":[{"issue_id":"taspr-1zp","depends_on_id":"taspr-6le","type":"parent-child","created_at":"2025-12-25T14:31:51.536244-05:00","created_by":"daemon"},{"issue_id":"taspr-1zp","depends_on_id":"taspr-0du","type":"blocks","created_at":"2025-12-25T14:31:51.81248-05:00","created_by":"daemon"},{"issue_id":"taspr-1zp","depends_on_id":"taspr-0du","type":"depends-on","created_at":"2025-12-25T14:31:51.81248-05:00","created_by":"daemon"}]}
{"id":"taspr-2m1","title":"Enhanced view formatting with status indicators","description":"## Goal\nUpdate view output to show blocking indicators for each PR.\n\n## Implementation\n\n```typescript\n// src/cli/output.ts\n\ninterface PRStatusInfo {\n  checks: 'pending' | 'passing' | 'failing';\n  review: 'approved' | 'changes_requested' | 'pending';\n  comments: { total: number; resolved: number };\n}\n\nfunction formatBlockingIndicators(status: PRStatusInfo): string {\n  const indicators: string[] = [];\n  \n  // Comment threads\n  if (status.comments.total \u003e 0 \u0026\u0026 status.comments.resolved \u003c status.comments.total) {\n    indicators.push(\\`ğŸ’¬ \\${status.comments.resolved}/\\${status.comments.total}\\`);\n  }\n  \n  // CI checks\n  if (status.checks === 'pending') {\n    indicators.push('â³ checks');\n  } else if (status.checks === 'failing') {\n    indicators.push('âœ— checks');\n  }\n  \n  // Review status\n  if (status.review === 'pending') {\n    indicators.push('ğŸ‘€ review');\n  } else if (status.review === 'changes_requested') {\n    indicators.push('âœ— review');\n  }\n  \n  return indicators.join('  ');\n}\n```\n\n## Output Format\n```\n  â— #143 Authentication feature            ğŸ’¬ 3/5  â³ checks\n```\n\nThe indicators are right-aligned after the title.\n\n## Testing\n- PR with multiple blocking indicators\n- PR with single indicator\n- PR with no blockers (shows nothing extra)\n\n## Files to Modify\n- src/cli/output.ts\n- src/cli/commands/view.ts\n\n## Acceptance Criteria\n- [ ] Shows comment thread status\n- [ ] Shows CI check status\n- [ ] Shows review status\n- [ ] Clean formatting with proper alignment","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-25T14:32:59.785483-05:00","updated_at":"2025-12-25T14:32:59.785483-05:00","dependencies":[{"issue_id":"taspr-2m1","depends_on_id":"taspr-v0c","type":"parent-child","created_at":"2025-12-25T14:33:04.509152-05:00","created_by":"daemon"},{"issue_id":"taspr-2m1","depends_on_id":"taspr-d6u","type":"blocks","created_at":"2025-12-25T14:33:04.785797-05:00","created_by":"daemon"},{"issue_id":"taspr-2m1","depends_on_id":"taspr-d6u","type":"depends-on","created_at":"2025-12-25T14:33:04.785797-05:00","created_by":"daemon"},{"issue_id":"taspr-2m1","depends_on_id":"taspr-1en","type":"blocks","created_at":"2025-12-25T14:33:05.057758-05:00","created_by":"daemon"},{"issue_id":"taspr-2m1","depends_on_id":"taspr-1en","type":"depends-on","created_at":"2025-12-25T14:33:05.057758-05:00","created_by":"daemon"},{"issue_id":"taspr-2m1","depends_on_id":"taspr-e6f","type":"blocks","created_at":"2025-12-25T14:33:05.327966-05:00","created_by":"daemon"},{"issue_id":"taspr-2m1","depends_on_id":"taspr-e6f","type":"depends-on","created_at":"2025-12-25T14:33:05.327966-05:00","created_by":"daemon"}]}
{"id":"taspr-37l","title":"Group create command","description":"## Goal\nImplement `taspr group create` to bundle commits into a single PR.\n\n## Implementation\n\n```typescript\n// src/cli/commands/group.ts\n\nexport const groupCommand = new Command('group')\n  .description('Manage commit groups');\n\ngroupCommand\n  .command('create')\n  .description('Create a new group from selected commits')\n  .action(async () =\u003e {\n    // Get current stack\n    const result = await parseStack();\n    if (!result.ok) {\n      console.error(formatValidationError(result));\n      process.exit(1);\n    }\n    \n    // Show commit selection\n    const selected = await selectCommits(result.units);\n    \n    // Validate selection\n    const validation = validateGroupSelection(selected, result.units);\n    if (!validation.ok) {\n      console.error(validation.error);\n      process.exit(1);\n    }\n    \n    // Get PR title\n    const title = await input({ message: 'PR title:' });\n    \n    // Warn about existing PRs\n    await warnAboutExistingPRs(selected);\n    \n    // Confirm\n    const proceed = await confirm({ message: 'Proceed?' });\n    if (!proceed) return;\n    \n    // Add group trailers\n    const groupId = generateId();\n    await addGroupTrailers(selected, groupId, title);\n    \n    console.log(\\`âœ“ Created group \\${groupId}\\`);\n    console.log(\\`  Title: \"\\${title}\"\\`);\n    console.log(\\`  Run \\`taspr sync --open\\` to create the PR.\\`);\n  });\n```\n\n### Adding Group Trailers\n```typescript\nasync function addGroupTrailers(\n  commits: CommitInfo[],\n  groupId: string,\n  title: string\n): Promise\u003cvoid\u003e {\n  const first = commits[0];\n  const last = commits[commits.length - 1];\n  \n  // Add Start and Title to first commit\n  await addTrailersToCommit(first.hash, {\n    'Taspr-Group-Start': groupId,\n    'Taspr-Group-Title': title,\n  });\n  \n  // Add End to last commit (if different from first)\n  if (last.hash !== first.hash) {\n    await addTrailersToCommit(last.hash, {\n      'Taspr-Group-End': groupId,\n    });\n  }\n}\n```\n\n## Warnings\nIf selected commits have existing PRs:\n```\nâš  Warning: Commit b2c3d4e5 has open PR #145. \n  Grouping it will close PR #145 when you sync.\n```\n\n## Testing\n- Create group from 2 commits\n- Create group from all commits\n- Validate contiguous requirement\n- Warn about existing PRs\n\n## Files to Create\n- src/cli/commands/group.ts\n- src/core/group.ts\n\n## Acceptance Criteria\n- [ ] Interactive commit selection\n- [ ] Validates contiguous selection\n- [ ] Adds correct trailers to correct commits\n- [ ] Warns about existing PRs\n- [ ] Confirms before making changes","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-25T14:34:15.681194-05:00","updated_at":"2025-12-25T14:34:15.681194-05:00","dependencies":[{"issue_id":"taspr-37l","depends_on_id":"taspr-7mu","type":"parent-child","created_at":"2025-12-25T14:34:19.387363-05:00","created_by":"daemon"},{"issue_id":"taspr-37l","depends_on_id":"taspr-q9i","type":"blocks","created_at":"2025-12-25T14:34:19.666321-05:00","created_by":"daemon"},{"issue_id":"taspr-37l","depends_on_id":"taspr-q9i","type":"depends-on","created_at":"2025-12-25T14:34:19.666321-05:00","created_by":"daemon"}]}
{"id":"taspr-3lr","title":"Force push updated branches","description":"## Goal\nForce-push branches that have changed after local commit amendments.\n\n## Implementation\n\n```typescript\n// src/github/branches.ts\n\nasync function forcePushBranch(commitHash: string, branchName: string): Promise\u003cvoid\u003e {\n  await $\\`git push --force origin ${commitHash}:refs/heads/${branchName}\\`;\n}\n\nasync function updateChangedBranches(\n  units: PRUnit[],\n  statuses: Map\u003cstring, SyncStatus\u003e,\n  config: BranchNameConfig\n): Promise\u003cstring[]\u003e {\n  const updated: string[] = [];\n  \n  for (const unit of units) {\n    const status = statuses.get(unit.id)!;\n    \n    if (status.needsUpdate) {\n      await forcePushBranch(status.localCommit, status.branchName);\n      updated.push(status.branchName);\n    }\n  }\n  \n  return updated;\n}\n```\n\n### Safety Considerations\n- Force push is destructiveâ€”overwrites remote branch\n- Fine for taspr branches (single owner)\n- GitHub retains old commits briefly via reflog\n\n### Reporting\n```\n$ taspr sync\n\nâœ“ Updated 2 branch(es):\n  â€¢ taspr/msims/a1b2c3d4 (b2c3d4e5 â†’ new-hash)\n  â€¢ taspr/msims/f7e8d9c0 (c3d4e5f6 â†’ new-hash)\n```\n\n## Integration with Sync Command\nThe sync command now:\n1. Injects missing IDs (Epic 2)\n2. For each unit:\n   - If no remote branch: push + create PR (Epic 3)\n   - If remote differs: force push (this task)\n   - If up to date: skip\n\n## Testing\n- Force push succeeds\n- Old commit is replaced\n- PR reflects new code\n\n## Files to Modify\n- src/github/branches.ts\n\n## Acceptance Criteria\n- [ ] Force pushes changed branches\n- [ ] Reports which branches were updated\n- [ ] Handles push failures gracefully","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-25T14:29:39.346235-05:00","updated_at":"2025-12-25T14:29:39.346235-05:00","dependencies":[{"issue_id":"taspr-3lr","depends_on_id":"taspr-1ni","type":"parent-child","created_at":"2025-12-25T14:29:42.942259-05:00","created_by":"daemon"},{"issue_id":"taspr-3lr","depends_on_id":"taspr-eik","type":"blocks","created_at":"2025-12-25T14:29:43.214548-05:00","created_by":"daemon"},{"issue_id":"taspr-3lr","depends_on_id":"taspr-eik","type":"depends-on","created_at":"2025-12-25T14:29:43.214548-05:00","created_by":"daemon"}]}
{"id":"taspr-41a","title":"View command with PR info","description":"## Goal\nEnhance `taspr view` to show PR numbers and basic status for each PRUnit.\n\n## Current State (from Epic 1)\nView shows local stack structure:\n```\n  â—‹ Add user model\n    â””â”€ a1b2c3d4\n```\n\n## Enhanced Output\nWith PR info from GitHub:\n```\n  â— #142 Add user model\n    â””â”€ a1b2c3d4\n    https://github.com/org/repo/pull/142\n```\n\n### Status Indicators\n- `âœ“` Merged\n- `â—` Open\n- `â—‹` No PR yet\n- `âœ—` Closed (not merged)\n\n## Implementation\n\n```typescript\n// src/cli/commands/view.ts\n\nasync function viewCommand() {\n  const result = await parseStack();\n  if (!result.ok) { /* handle error */ }\n  \n  // Get branch config for lookups\n  const config = await getBranchNameConfig();\n  \n  // Enrich units with PR info\n  const enrichedUnits = await Promise.all(\n    result.units.map(async unit =\u003e {\n      const branch = getBranchName(unit.id, config);\n      const pr = await findPRByBranch(branch);\n      return { ...unit, pr };\n    })\n  );\n  \n  // Format and display\n  console.log(formatStackView(enrichedUnits));\n}\n```\n\n### Updated Formatting\n```typescript\nfunction formatPRUnit(unit: EnrichedPRUnit): string {\n  const status = getPRStatusIcon(unit.pr);\n  const prNum = unit.pr ? \\`#\\${unit.pr.number} \\` : '';\n  const title = unit.title;\n  \n  let output = \\`  \\${status} \\${prNum}\\${title}\\\\n\\`;\n  \n  // Commits\n  for (const commit of unit.commits) {\n    output += \\`    â””â”€ \\${commit.slice(0, 8)}\\\\n\\`;\n  }\n  \n  // PR URL\n  if (unit.pr) {\n    output += \\`    \\${unit.pr.url}\\\\n\\`;\n  }\n  \n  return output;\n}\n\nfunction getPRStatusIcon(pr: PRInfo | null): string {\n  if (!pr) return 'â—‹';\n  switch (pr.state) {\n    case 'open': return 'â—';\n    case 'merged': return 'âœ“';\n    case 'closed': return 'âœ—';\n    default: return 'â—‹';\n  }\n}\n```\n\n## Caching for Performance\nPR lookups are slow. Consider caching:\n- Within a single view command\n- Optional: `.git/taspr/cache.json` with TTL\n\nFor now, just parallelize lookups within view.\n\n## Testing\n- View with no PRs â†’ all â—‹\n- View with open PRs â†’ shows â— and URLs\n- View with mixed states\n\n## Files to Modify\n- src/cli/commands/view.ts\n- src/cli/output.ts\n\n## Acceptance Criteria\n- [ ] Shows PR numbers when PRs exist\n- [ ] Shows correct status icons\n- [ ] Shows PR URLs\n- [ ] Handles units without PRs gracefully","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-25T14:29:59.545059-05:00","updated_at":"2025-12-25T14:29:59.545059-05:00","dependencies":[{"issue_id":"taspr-41a","depends_on_id":"taspr-1ni","type":"parent-child","created_at":"2025-12-25T14:30:03.44579-05:00","created_by":"daemon"},{"issue_id":"taspr-41a","depends_on_id":"taspr-5i6","type":"blocks","created_at":"2025-12-25T14:30:03.718564-05:00","created_by":"daemon"},{"issue_id":"taspr-41a","depends_on_id":"taspr-5i6","type":"depends-on","created_at":"2025-12-25T14:30:03.718564-05:00","created_by":"daemon"}]}
{"id":"taspr-4b6","title":"Dirty state detection","description":"## Goal\nBlock sync operations when there are uncommitted changes.\n\n## Background\nRebasing with uncommitted changes can cause problems:\n- Changes get lost\n- Conflicts are harder to resolve\n- State becomes confusing\n\ntaspr should detect and block this upfront with a clear message.\n\n## Implementation\n\n```typescript\n// src/git/status.ts\n\ninterface WorkingTreeStatus {\n  isDirty: boolean;\n  hasUnstagedChanges: boolean;\n  hasStagedChanges: boolean;\n  hasUntrackedFiles: boolean;\n}\n\nasync function getWorkingTreeStatus(): Promise\u003cWorkingTreeStatus\u003e {\n  // Check for any changes\n  const status = await $`git status --porcelain`.text();\n  \n  const lines = status.trim().split('\\n').filter(Boolean);\n  \n  return {\n    isDirty: lines.length \u003e 0,\n    hasUnstagedChanges: lines.some(l =\u003e l[1] !== ' '),\n    hasStagedChanges: lines.some(l =\u003e l[0] !== ' ' \u0026\u0026 l[0] !== '?'),\n    hasUntrackedFiles: lines.some(l =\u003e l.startsWith('??')),\n  };\n}\n\nasync function requireCleanWorkingTree(): Promise\u003cvoid\u003e {\n  const status = await getWorkingTreeStatus();\n  \n  if (status.hasStagedChanges || status.hasUnstagedChanges) {\n    throw new DirtyWorkingTreeError(status);\n  }\n  \n  // Note: Untracked files are okayâ€”they don't affect rebase\n}\n```\n\n### Error Message\n```\nâœ— Error: Cannot sync with uncommitted changes\n\n  You have:\n    â€¢ 2 staged changes\n    â€¢ 3 unstaged changes\n\n  Please commit or stash your changes first:\n    git stash        # Temporarily save changes\n    taspr sync       # Run sync\n    git stash pop    # Restore changes\n```\n\n## Usage in Sync\n\n```typescript\nasync function sync(options: SyncOptions) {\n  // First check: working tree must be clean\n  await requireCleanWorkingTree();\n  \n  // Now safe to proceed with rebase operations\n  ...\n}\n```\n\n## Testing\n1. Clean working tree â†’ passes\n2. Staged changes â†’ blocks\n3. Unstaged changes â†’ blocks\n4. Only untracked files â†’ passes (untracked don't affect rebase)\n\n## Files to Create\n- src/git/status.ts\n\n## Acceptance Criteria\n- [ ] Detects staged changes\n- [ ] Detects unstaged changes\n- [ ] Allows untracked files\n- [ ] Provides clear error message\n- [ ] Suggests git stash as workaround","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T14:25:46.906529-05:00","updated_at":"2025-12-26T21:12:09.239717-05:00","closed_at":"2025-12-26T21:12:09.239717-05:00","close_reason":"Implemented getWorkingTreeStatus and requireCleanWorkingTree in src/git/status.ts","dependencies":[{"issue_id":"taspr-4b6","depends_on_id":"taspr-7tr","type":"parent-child","created_at":"2025-12-25T14:25:50.62641-05:00","created_by":"daemon"}]}
{"id":"taspr-4xr","title":"Post-rebase sync (update all branches)","description":"## Goal\nAfter rebasing, update all affected PR branches.\n\n## Background\nAfter a rebase:\n- All commit hashes in the stack have changed\n- All remote branches point to old hashes\n- All branches need force-pushing\n\n## Implementation\n\n```typescript\n// src/core/sync.ts\n\nasync function syncAfterRebase(units: PRUnit[]): Promise\u003cvoid\u003e {\n  const config = await getBranchNameConfig();\n  \n  console.log('Updating PR branches...');\n  \n  let updated = 0;\n  \n  for (const unit of units) {\n    const branch = getBranchName(unit.id, config);\n    const localCommit = unit.commits[unit.commits.length - 1];\n    \n    // Force push regardless of whether we think it changed\n    // After rebase, everything has changed\n    await forcePushBranch(localCommit, branch);\n    updated++;\n    \n    console.log(\\`  âœ“ \\${branch}\\`);\n  }\n  \n  console.log(\\`\\\\nâœ“ Updated \\${updated} PR branch(es)\\`);\n}\n```\n\n### Full Sync Flow\n```typescript\nasync function sync(options: { open?: boolean }) {\n  // 1. Check for dirty state\n  await requireCleanWorkingTree();\n  \n  // 2. Check for ongoing conflict\n  if (await getConflictInfo()) {\n    // Exit with instructions\n  }\n  \n  // 3. Inject missing IDs\n  await injectMissingIds();\n  \n  // 4. Parse stack\n  const result = await parseStack();\n  \n  // 5. Rebase if behind\n  if (await isStackBehindMain()) {\n    const rebaseResult = await rebaseOntoMain();\n    if (!rebaseResult.success) {\n      // Conflict - exit\n    }\n    \n    // Re-parse after rebase (hashes changed)\n    result = await parseStack();\n  }\n  \n  // 6. Update branches\n  await syncAfterRebase(result.units);\n  \n  // 7. Create PRs if --open\n  if (options.open) {\n    await createMissingPRs(result.units);\n  }\n}\n```\n\n## Testing\n- After rebase, all branches updated\n- PR commits match local stack\n- Force push succeeds\n\n## Files to Modify\n- src/core/sync.ts\n- src/cli/commands/sync.ts\n\n## Acceptance Criteria\n- [ ] Updates all branches after rebase\n- [ ] Force pushes to overwrite old commits\n- [ ] Reports each updated branch\n- [ ] Handles partial failures gracefully","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-25T14:37:18.394819-05:00","updated_at":"2025-12-25T14:37:18.394819-05:00","dependencies":[{"issue_id":"taspr-4xr","depends_on_id":"taspr-a64","type":"parent-child","created_at":"2025-12-25T14:37:23.410645-05:00","created_by":"daemon"},{"issue_id":"taspr-4xr","depends_on_id":"taspr-ybr","type":"blocks","created_at":"2025-12-25T14:37:23.676459-05:00","created_by":"daemon"},{"issue_id":"taspr-4xr","depends_on_id":"taspr-ybr","type":"depends-on","created_at":"2025-12-25T14:37:23.676459-05:00","created_by":"daemon"}]}
{"id":"taspr-53z","title":"Install and configure oxformat","description":"Install oxformat (Oxc's fast JavaScript/TypeScript formatter) and configure it for the project. This includes adding the package, creating configuration files, and setting up npm scripts.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-26T01:04:41.62418-05:00","updated_at":"2025-12-26T01:37:47.487903-05:00","closed_at":"2025-12-26T01:37:47.487903-05:00","close_reason":"Installed oxfmt v0.20.0 and configured with default settings. Added format script to package.json."}
{"id":"taspr-57g","title":"View command (local only)","description":"## Goal\nImplement the `taspr view` command to display stack structure in the terminal.\n\n## Background\nThis is the first user-facing command. It shows the current stack state based purely on local git dataâ€”no GitHub integration yet.\n\n## Output Format\n\n```\n$ taspr view\n\nStack: feature/auth (4 commits, 3 PRs)\n\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  â—‹ Add user model\n    â””â”€ a1b2c3d4\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  â—‹ Authentication feature [f7e8d9c0]\n    â”œâ”€ b2c3d4e5 Add login endpoint\n    â”œâ”€ c3d4e5f6 Add password validation  \n    â””â”€ d4e5f6a7 Add 2FA support\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  â—‹ Add admin dashboard\n    â””â”€ e5f6a7b8\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  â†“ origin/main\n```\n\n### Elements\n- **Header**: Branch name, commit count, PR count (PRUnits)\n- **Separator**: Horizontal line between PRUnits\n- **Status indicator**: `â—‹` for local-only (no PR). Later: `âœ“` merged, `â—` open, etc.\n- **Title**: Commit subject (single) or Group-Title (group)\n- **Group indicator**: `[group-id]` after title for groups\n- **Commits**: Tree structure showing commit IDs and subjects\n- **Footer**: Shows origin/main as the base\n\n## Implementation\n\n### Command Registration\n```typescript\n// src/cli/commands/view.ts\nimport { Command } from 'commander';\nimport { parseStack } from '../../core/stack';\nimport { formatStackView } from '../output';\n\nexport const viewCommand = new Command('view')\n  .description('Display status of current stack')\n  .action(async () =\u003e {\n    const result = await parseStack();\n    \n    if (!result.ok) {\n      // Show validation error\n      console.error(formatValidationError(result));\n      process.exit(1);\n    }\n    \n    console.log(formatStackView(result.units));\n  });\n```\n\n### Output Formatting\n```typescript\n// src/cli/output.ts\nexport function formatStackView(units: PRUnit[]): string {\n  // Build formatted output string\n}\n\nexport function formatValidationError(error: StackParseError): string {\n  // Format error with actionable message\n}\n```\n\n## Validation Error Display\n\nWhen groups are malformed, show helpful errors:\n\n```\n$ taspr view\n\nâœ— Error: Unclosed group starting at commit b2c3d4e5\n\n  Group f7e8d9c0 (\"Auth feature\") has Taspr-Group-Start but no \n  matching Taspr-Group-End was found in subsequent commits.\n  \n  To fix, either:\n    1. Run `taspr group edit` to set the end boundary\n    2. Run `taspr group dissolve` to remove the incomplete group\n```\n\n## Edge Cases\n1. **Empty stack**: \"No commits ahead of origin/main\"\n2. **No origin/main**: Error with setup instructions\n3. **All commits in one group**: Show single PRUnit\n4. **Commits without IDs**: Show hash only, indicate sync needed\n\n## Testing Strategy\n1. Mock stack data and verify output formatting\n2. Test error formatting for various validation errors\n3. Integration test with real git repo\n\n## Files to Create/Modify\n- src/cli/commands/view.ts (create)\n- src/cli/output.ts (create) - Output formatting utilities\n- src/cli/index.ts (modify) - Register view command\n\n## Acceptance Criteria\n- [ ] Shows stack with all PRUnits\n- [ ] Correctly formats singles and groups\n- [ ] Shows validation errors clearly\n- [ ] Handles empty stack gracefully\n- [ ] Tree structure for group commits\n- [ ] Exit code 0 on success, 1 on validation error","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T14:23:56.483682-05:00","updated_at":"2025-12-26T01:28:05.134007-05:00","closed_at":"2025-12-26T01:28:05.134007-05:00","close_reason":"Implemented view command with formatStackView, formatValidationError, and getStackCommitsWithTrailers","dependencies":[{"issue_id":"taspr-57g","depends_on_id":"taspr-h87","type":"parent-child","created_at":"2025-12-25T14:24:00.129571-05:00","created_by":"daemon"},{"issue_id":"taspr-57g","depends_on_id":"taspr-b7d","type":"blocks","created_at":"2025-12-25T14:24:00.407869-05:00","created_by":"daemon"},{"issue_id":"taspr-57g","depends_on_id":"taspr-b7d","type":"depends-on","created_at":"2025-12-25T14:24:00.407869-05:00","created_by":"daemon"}]}
{"id":"taspr-5i6","title":"PR lookup by branch","description":"## Goal\nFind existing PRs for branches to avoid creating duplicates.\n\n## Implementation\n\n```typescript\n// src/github/pr.ts\n\ninterface PRInfo {\n  number: number;\n  url: string;\n  state: 'open' | 'closed' | 'merged';\n  title: string;\n}\n\nasync function findPRByBranch(branchName: string): Promise\u003cPRInfo | null\u003e {\n  const result = await $\\`gh pr list --head ${branchName} --json number,url,state,title\\`.nothrow();\n  \n  if (result.exitCode !== 0) {\n    return null;\n  }\n  \n  const prs = JSON.parse(result.stdout.toString());\n  \n  // Return first open PR (should only be one)\n  const openPR = prs.find((pr: PRInfo) =\u003e pr.state === 'open');\n  return openPR || null;\n}\n```\n\n### Usage in Sync\nBefore creating a PR, check if one exists:\n\n```typescript\nasync function ensurePRExists(unit: PRUnit, headBranch: string, baseBranch: string): Promise\u003cPRInfo\u003e {\n  // Check for existing PR\n  const existing = await findPRByBranch(headBranch);\n  if (existing) {\n    return existing;\n  }\n  \n  // Create new PR\n  return await createPR({\n    title: unit.title,\n    head: headBranch,\n    base: baseBranch,\n  });\n}\n```\n\n### Enriching PRUnits\nAfter sync, enrich PRUnits with PR info:\n\n```typescript\ninterface EnrichedPRUnit extends PRUnit {\n  prNumber?: number;\n  prUrl?: string;\n  prState?: 'open' | 'closed' | 'merged';\n}\n\nasync function enrichPRUnitsWithPRInfo(\n  units: PRUnit[], \n  branches: Map\u003cstring, string\u003e\n): Promise\u003cEnrichedPRUnit[]\u003e {\n  return Promise.all(units.map(async unit =\u003e {\n    const branch = branches.get(unit.id);\n    if (!branch) return unit;\n    \n    const pr = await findPRByBranch(branch);\n    return {\n      ...unit,\n      prNumber: pr?.number,\n      prUrl: pr?.url,\n      prState: pr?.state,\n    };\n  }));\n}\n```\n\n## Edge Cases\n1. **No PR for branch**: Return null\n2. **Closed PR for branch**: Return it (may want to reopen or create new)\n3. **Multiple PRs for branch**: Return first open one\n\n## Testing\n- Branch with open PR â†’ returns PR info\n- Branch with closed PR â†’ returns closed PR info\n- Branch with no PR â†’ returns null\n\n## Files to Modify\n- src/github/pr.ts\n\n## Acceptance Criteria\n- [ ] Finds open PRs by branch name\n- [ ] Returns null for branches without PRs\n- [ ] Returns PR info including state\n- [ ] Handles closed/merged PRs","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-25T14:27:54.485452-05:00","updated_at":"2025-12-25T14:27:54.485452-05:00","dependencies":[{"issue_id":"taspr-5i6","depends_on_id":"taspr-osw","type":"parent-child","created_at":"2025-12-25T14:27:58.424193-05:00","created_by":"daemon"},{"issue_id":"taspr-5i6","depends_on_id":"taspr-bvy","type":"blocks","created_at":"2025-12-25T14:27:58.701-05:00","created_by":"daemon"},{"issue_id":"taspr-5i6","depends_on_id":"taspr-bvy","type":"depends-on","created_at":"2025-12-25T14:27:58.701-05:00","created_by":"daemon"}]}
{"id":"taspr-6le","title":"Epic 5: Land PRs (Merge to Main)","description":"## Goal\nMerge the bottom PR to main, completing the PR lifecycle.\n\n## Background\n\n### Landing Strategy\nWhen a PR is ready (approved, CI passing), land it by merging to main. The merge strategy depends on repo settings:\n- Fast-forward (if possible)\n- Squash merge\n- Merge commit\n\ntaspr uses GitHub's merge API, which respects repo settings.\n\n### Stack Behavior After Landing\nWhen the bottom PR merges:\n1. GitHub automatically retargets child PRs to new base (main)\n2. No action needed from taspr for retargeting\n3. Next `taspr sync` will clean up merged PR from local tracking\n\n### What \"Ready\" Means\nA PR is ready to land when:\n- Approved by required reviewers\n- CI checks passing\n- No merge conflicts\n\n## Workflow\n\n1. User runs `taspr land`\n2. Find bottom unmerged PR\n3. Check if it's ready (API call)\n4. Merge via GitHub API\n5. Report success\n\n## Deliverable\nRunning `taspr land` merges the bottom PR. GitHub handles retargeting child PRs.\n\n## Dependencies\n- Epic 4 must be complete (PRs exist and are synced)\n\n## Commands\n\n### taspr land\nMerge the bottom ready PR:\n```\n$ taspr land\n\nMerging PR #142 (Add user model)...\nâœ“ Merged PR #142 to main\n```\n\n### taspr land --all\nMerge all consecutive ready PRs:\n```\n$ taspr land --all\n\nMerging PR #142 (Add user model)...\nâœ“ Merged PR #142 to main\n\nMerging PR #143 (Add auth)...\nâœ“ Merged PR #143 to main\n\nStopping at PR #144 (not ready: CI failing)\n```\n\n## Testable Outcome\nLanding a PR merges it to main. GitHub retargets child PRs automatically.","status":"open","priority":1,"issue_type":"epic","created_at":"2025-12-25T14:30:38.632223-05:00","updated_at":"2025-12-25T14:30:38.632223-05:00","dependencies":[{"issue_id":"taspr-6le","depends_on_id":"taspr-1ni","type":"blocks","created_at":"2025-12-25T14:30:43.99553-05:00","created_by":"daemon"},{"issue_id":"taspr-6le","depends_on_id":"taspr-1ni","type":"depends-on","created_at":"2025-12-25T14:30:43.99553-05:00","created_by":"daemon"}]}
{"id":"taspr-6nw","title":"Git log parsing","description":"## Goal\nRead commits between HEAD and the merge-base with origin/main, extracting all relevant information.\n\n## Background\ntaspr needs to understand the stack of commits that will become PRs. The stack is:\n- All commits from HEAD back to (but not including) the merge-base with origin/main\n- Ordered from oldest to newest (bottom of stack = first to merge)\n\n## Implementation\n\n### Git Commands Needed\n```bash\n# Find merge-base\ngit merge-base HEAD origin/main\n\n# Get commits in stack (oldest first)\ngit log --reverse --format=\"%H%x00%s%x00%B\" \u003cmerge-base\u003e..HEAD\n```\n\n### Output Format\nUse null-byte separators for reliable parsing:\n- `%H` - commit hash\n- `%s` - subject line\n- `%B` - full body (includes subject)\n\n### Function Signature\n```typescript\ninterface CommitInfo {\n  hash: string;\n  subject: string;\n  body: string;\n}\n\nasync function getStackCommits(): Promise\u003cCommitInfo[]\u003e\n```\n\n### Edge Cases\n1. **No commits ahead of main**: Return empty array\n2. **No origin/main**: Error with helpful message\n3. **Detached HEAD**: Should still work\n4. **Merge commits in stack**: Include them (user's choice to have them)\n\n## Bun Shell Usage\n```typescript\nimport { $ } from \"bun\";\n\nconst mergeBase = await $`git merge-base HEAD origin/main`.text();\nconst log = await $`git log --reverse --format=\"%H%x00%s%x00%B%x00\" ${mergeBase.trim()}..HEAD`.text();\n```\n\n## Testing Strategy\nCreate a temporary git repository with known commits and verify parsing:\n1. Create temp dir\n2. git init\n3. Add commits with known subjects/bodies\n4. Call getStackCommits()\n5. Assert on results\n\n## Files to Create/Modify\n- src/git/commands.ts (create) - Git command wrapper with getStackCommits()\n\n## Acceptance Criteria\n- [ ] Returns commits in oldest-to-newest order\n- [ ] Correctly parses hash, subject, body\n- [ ] Handles empty stack (no commits ahead)\n- [ ] Handles repos without origin/main with clear error\n- [ ] Has tests with real git repos in temp directories","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T14:22:32.243959-05:00","updated_at":"2025-12-26T00:42:13.283588-05:00","closed_at":"2025-12-26T00:42:13.283588-05:00","close_reason":"Closed","dependencies":[{"issue_id":"taspr-6nw","depends_on_id":"taspr-h87","type":"parent-child","created_at":"2025-12-25T14:22:35.916747-05:00","created_by":"daemon"},{"issue_id":"taspr-6nw","depends_on_id":"taspr-0lj","type":"blocks","created_at":"2025-12-25T14:22:36.196173-05:00","created_by":"daemon"},{"issue_id":"taspr-6nw","depends_on_id":"taspr-0lj","type":"depends-on","created_at":"2025-12-25T14:22:36.196173-05:00","created_by":"daemon"}]}
{"id":"taspr-71a","title":"Sync command with PR creation (--open flag)","description":"## Goal\nExtend the sync command to create PRs with the --open flag.\n\n## Current State (from Epic 2)\n`taspr sync` currently:\n- Checks for dirty working tree\n- Adds Taspr-Commit-Id to commits without them\n\n## New Behavior\n`taspr sync --open` also:\n- Pushes branches for all PRUnits\n- Creates PRs for units that don't have them\n- Reports created/existing PRs\n\n## Implementation\n\n```typescript\n// src/cli/commands/sync.ts\n\nexport const syncCommand = new Command('sync')\n  .description('Sync stack state with GitHub')\n  .option('--open', 'Create PRs for units without them')\n  .action(async (options) =\u003e {\n    await requireCleanWorkingTree();\n    \n    // Parse and validate stack\n    const result = await parseStack();\n    if (!result.ok) {\n      console.error(formatValidationError(result));\n      process.exit(1);\n    }\n    \n    // Inject missing IDs\n    const idResult = await injectMissingIds();\n    if (idResult.modifiedCommits.length \u003e 0) {\n      console.log(\\`âœ“ Added IDs to \\${idResult.modifiedCommits.length} commit(s)\\`);\n      // Re-parse after rebase\n      result = await parseStack();\n    }\n    \n    if (!options.open) {\n      console.log('âœ“ Stack synced (use --open to create PRs)');\n      return;\n    }\n    \n    // Push branches and create PRs\n    const config = await getBranchNameConfig();\n    const defaultBranch = await getDefaultBranch();\n    \n    let baseBranch = defaultBranch;\n    const created: PRInfo[] = [];\n    const existing: PRInfo[] = [];\n    \n    for (const unit of result.units) {\n      const headBranch = getBranchName(unit.id, config);\n      \n      // Push branch\n      await pushBranch(unit.commits[unit.commits.length - 1], headBranch);\n      \n      // Check for existing PR\n      const existingPR = await findPRByBranch(headBranch);\n      \n      if (existingPR) {\n        existing.push(existingPR);\n      } else {\n        const pr = await createPR({\n          title: unit.title,\n          head: headBranch,\n          base: baseBranch,\n        });\n        created.push(pr);\n      }\n      \n      baseBranch = headBranch;\n    }\n    \n    // Report results\n    if (created.length \u003e 0) {\n      console.log(\\`\\\\nâœ“ Created \\${created.length} PR(s):\\`);\n      for (const pr of created) {\n        console.log(\\`  #\\${pr.number} \\${pr.url}\\`);\n      }\n    }\n    \n    if (existing.length \u003e 0) {\n      console.log(\\`\\\\nâœ“ \\${existing.length} PR(s) already exist\\`);\n    }\n  });\n```\n\n## Output\n\n### First sync with --open\n```\n$ taspr sync --open\n\nâœ“ Added IDs to 3 commit(s)\nâœ“ Pushed 3 branch(es)\n\nâœ“ Created 3 PR(s):\n  #142 https://github.com/org/repo/pull/142\n  #143 https://github.com/org/repo/pull/143\n  #144 https://github.com/org/repo/pull/144\n```\n\n### Subsequent sync with --open (PRs exist)\n```\n$ taspr sync --open\n\nâœ“ All commits have IDs\nâœ“ Pushed 3 branch(es)\nâœ“ 3 PR(s) already exist\n```\n\n### Sync without --open\n```\n$ taspr sync\n\nâœ“ All commits have IDs\nâœ“ Stack synced (use --open to create PRs)\n```\n\n## Testing\n1. Sync --open creates PRs\n2. Sync --open with existing PRs doesn't duplicate\n3. Sync without --open doesn't touch GitHub\n4. Integration test with real GitHub (or mocked)\n\n## Files to Modify\n- src/cli/commands/sync.ts\n\n## Acceptance Criteria\n- [ ] --open flag creates PRs for units without them\n- [ ] Doesn't create duplicate PRs\n- [ ] Reports created vs existing PRs\n- [ ] Without --open, no GitHub interaction\n- [ ] PRs form correct stack structure","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-25T14:28:34.89184-05:00","updated_at":"2025-12-25T14:28:34.89184-05:00","dependencies":[{"issue_id":"taspr-71a","depends_on_id":"taspr-osw","type":"parent-child","created_at":"2025-12-25T14:28:38.862039-05:00","created_by":"daemon"},{"issue_id":"taspr-71a","depends_on_id":"taspr-de7","type":"blocks","created_at":"2025-12-25T14:28:39.14537-05:00","created_by":"daemon"},{"issue_id":"taspr-71a","depends_on_id":"taspr-de7","type":"depends-on","created_at":"2025-12-25T14:28:39.14537-05:00","created_by":"daemon"},{"issue_id":"taspr-71a","depends_on_id":"taspr-5i6","type":"blocks","created_at":"2025-12-25T14:28:39.430517-05:00","created_by":"daemon"},{"issue_id":"taspr-71a","depends_on_id":"taspr-5i6","type":"depends-on","created_at":"2025-12-25T14:28:39.430517-05:00","created_by":"daemon"}]}
{"id":"taspr-77v","title":"gh CLI dependency checks","description":"## Goal\nDetect when `gh` CLI is missing or not authenticated, and provide clear guidance to users.\n\n## Why gh CLI\ntaspr delegates all GitHub API operations to the `gh` CLI rather than implementing OAuth or token management. This:\n- Leverages existing user authentication\n- Avoids storing tokens\n- Uses well-tested GitHub API wrapper\n- Simplifies taspr\\'s scope\n\n## Checks Required\n\n### 1. gh Installation Check\n```typescript\nasync function checkGhInstalled(): Promise\u003cboolean\u003e {\n  try {\n    const result = await $`gh --version`.quiet();\n    return result.exitCode === 0;\n  } catch {\n    return false;\n  }\n}\n```\n\n**Error when missing:**\n```\nError: GitHub CLI (gh) is required but not installed\n\ntaspr uses the GitHub CLI for all GitHub operations.\n\nTo install:\n  macOS:   brew install gh\n  Linux:   https://github.com/cli/cli/blob/trunk/docs/install_linux.md\n  Windows: winget install GitHub.cli\n\nAfter installing, authenticate with: gh auth login\n```\n\n### 2. gh Authentication Check\n```typescript\nasync function checkGhAuthenticated(): Promise\u003cboolean\u003e {\n  try {\n    const result = await $`gh auth status`.quiet();\n    return result.exitCode === 0;\n  } catch {\n    return false;\n  }\n}\n```\n\n**Error when not authenticated:**\n```\nError: Not authenticated with GitHub\n\ntaspr requires GitHub authentication via the gh CLI.\n\nTo authenticate:\n  gh auth login\n\nThen follow the prompts to complete authentication.\n```\n\n### 3. Repository Access Check\n```typescript\nasync function checkRepoAccess(): Promise\u003cboolean\u003e {\n  try {\n    // Try to get repo info - will fail if no access\n    const result = await $`gh repo view --json name`.quiet();\n    return result.exitCode === 0;\n  } catch {\n    return false;\n  }\n}\n```\n\n**Error when no access:**\n```\nError: Cannot access this repository via GitHub\n\nThis could mean:\n  - The repository doesn\\'t have a GitHub remote\n  - You don\\'t have access to this repository\n  - The repository doesn\\'t exist on GitHub\n\nCheck your git remote: git remote -v\n```\n\n## When to Check\n\n### On Every Command That Needs GitHub\n- `taspr sync` (when creating/updating PRs)\n- `taspr land`\n- `taspr view` (when fetching PR status)\n\n### Check Order\n1. gh installed?\n2. gh authenticated?\n3. Repository accessible?\n\nStop at first failure with appropriate message.\n\n## Implementation\n\n### Lazy Checking\n```typescript\n// src/github/api.ts\nlet ghChecked = false;\n\nexport async function ensureGhReady(): Promise\u003cvoid\u003e {\n  if (ghChecked) return;\n  \n  if (!await checkGhInstalled()) {\n    throw new TasprError(\n      'GitHub CLI (gh) is required but not installed',\n      'Install from https://cli.github.com then run: gh auth login'\n    );\n  }\n  \n  if (!await checkGhAuthenticated()) {\n    throw new TasprError(\n      'Not authenticated with GitHub',\n      'Run: gh auth login'\n    );\n  }\n  \n  ghChecked = true;\n}\n```\n\n### Call Before GitHub Operations\n```typescript\n// In any command using GitHub\nawait ensureGhReady();\nconst pr = await createPR(...);\n```\n\n## Testing\n- Test with gh not in PATH\n- Test with gh installed but not authenticated (`gh auth logout`)\n- Test with authenticated but no repo access\n- Verify error messages are helpful\n\n## Acceptance Criteria\n- [ ] Checks run before any GitHub API call\n- [ ] Clear error when gh not installed\n- [ ] Clear error when gh not authenticated\n- [ ] Clear error when repo not accessible\n- [ ] Checks are cached (don\\'t repeat every call)\n- [ ] Installation instructions cover macOS, Linux, Windows","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-25T14:49:31.737179-05:00","updated_at":"2025-12-25T14:49:31.737179-05:00","dependencies":[{"issue_id":"taspr-77v","depends_on_id":"taspr-8iv","type":"parent-child","created_at":"2025-12-25T15:01:36.787108-05:00","created_by":"daemon"}]}
{"id":"taspr-7h3","title":"Rebase orchestration for ID injection","description":"## Goal\nImplement the rebase logic to add Taspr-Commit-Id trailers to multiple commits in a stack.\n\n## Background\nWhen commits don't have IDs, we need to add them via rebase. This is non-trivial because:\n- Multiple commits may need IDs\n- We want to preserve existing IDs\n- We need to handle the rebase cleanly\n\n## Approach: GIT_SEQUENCE_EDITOR + exec\n\n### Option 1: Rebase with --exec\n```bash\ngit rebase -i --exec './add-id-if-missing.sh' \u003cmerge-base\u003e\n```\n\nThe script checks each commit and adds ID only if missing:\n```bash\n#!/bin/bash\nif ! git log -1 --format=%B | grep -q \"^Taspr-Commit-Id:\"; then\n  # Add ID\n  NEW_MSG=$(git log -1 --format=%B | git interpret-trailers --trailer \"Taspr-Commit-Id: $(openssl rand -hex 4)\")\n  git commit --amend --no-edit -m \"$NEW_MSG\"\nfi\n```\n\n### Option 2: Programmatic Rebase\nMore control but more complex:\n1. Generate todo list manually\n2. For each commit needing ID, mark as \"edit\"\n3. Use GIT_SEQUENCE_EDITOR to inject todo\n4. Handle each \"edit\" stop to add trailer\n\n### Recommended: Option 1\nSimpler and handles edge cases well. The --exec runs after each pick.\n\n## Implementation\n\n```typescript\n// src/core/sync.ts\n\nasync function injectMissingIds(): Promise\u003c{ modifiedCommits: string[] }\u003e {\n  const commits = await getStackCommits();\n  \n  // Find commits without IDs\n  const needsId = commits.filter(c =\u003e !c.trailers['Taspr-Commit-Id']);\n  \n  if (needsId.length === 0) {\n    return { modifiedCommits: [] };\n  }\n  \n  // Create temp script for --exec\n  const script = createIdInjectionScript();\n  await writeFile(scriptPath, script);\n  await chmod(scriptPath, '755');\n  \n  // Run rebase\n  const mergeBase = await getMergeBase();\n  await $`git rebase -i --exec ${scriptPath} ${mergeBase}`;\n  \n  // Clean up\n  await unlink(scriptPath);\n  \n  return { modifiedCommits: needsId.map(c =\u003e c.hash) };\n}\n```\n\n## Challenges\n\n### Non-interactive rebase\nWe want this to run without user intervention. Using `--exec` with a script achieves thisâ€”no editor opens.\n\n### Preserving existing IDs\nThe script only adds ID if missing, so existing IDs are preserved.\n\n### Rebase conflicts\nIf there's a conflict, the rebase stops. This is handled by a separate task in Epic 8.\n\n## Testing\n1. Stack with no IDs â†’ all get IDs\n2. Stack with some IDs â†’ only missing ones get IDs\n3. Stack with all IDs â†’ no rebase happens (no-op)\n4. Verify IDs survive subsequent rebases\n\n## Files to Create/Modify\n- src/core/sync.ts (create)\n- src/git/rebase.ts (create) - Rebase utilities\n\n## Acceptance Criteria\n- [ ] Adds IDs to commits missing them\n- [ ] Preserves existing IDs\n- [ ] No-op if all commits have IDs\n- [ ] Works without user interaction\n- [ ] Has integration tests with real git repos","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-25T14:25:29.162547-05:00","updated_at":"2025-12-25T14:25:29.162547-05:00","dependencies":[{"issue_id":"taspr-7h3","depends_on_id":"taspr-7tr","type":"parent-child","created_at":"2025-12-25T14:25:33.539927-05:00","created_by":"daemon"},{"issue_id":"taspr-7h3","depends_on_id":"taspr-fwm","type":"blocks","created_at":"2025-12-25T14:25:33.82023-05:00","created_by":"daemon"},{"issue_id":"taspr-7h3","depends_on_id":"taspr-fwm","type":"depends-on","created_at":"2025-12-25T14:25:33.82023-05:00","created_by":"daemon"}]}
{"id":"taspr-7mu","title":"Epic 7: Group Management","description":"## Goal\nInteractive creation and management of commit groups (multi-commit PRs).\n\n## Background\n\n### Groups\nBy default, each commit becomes its own PR. Groups let you bundle multiple commits into a single PR.\n\nGroups are defined by trailers:\n- `Taspr-Group-Start: \u003cgroup-id\u003e` on first commit\n- `Taspr-Group-Title: \u003ctitle\u003e` on first commit (PR title)\n- `Taspr-Group-End: \u003cgroup-id\u003e` on last commit\n\n### Use Cases\n- Related changes that should be reviewed together\n- Work-in-progress commits that will be squashed\n- Logical feature that spans multiple commits\n\n## Commands\n\n### taspr group create\nInteractive selection of commits to group:\n```\n$ taspr group create\n\nCurrent stack (4 commits):\n  1. [â—‹] a1b2c3d4 Add user model\n  2. [â—‹] b2c3d4e5 Add login endpoint  \n  3. [â—‹] c3d4e5f6 Add password validation\n  4. [â—‹] d4e5f6a7 Add 2FA support\n\nSelect commits to group (space to toggle, enter to confirm):\n  [ ] 1. a1b2c3d4 Add user model\n  [x] 2. b2c3d4e5 Add login endpoint  \n  [x] 3. c3d4e5f6 Add password validation\n  [x] 4. d4e5f6a7 Add 2FA support\n\nPR title: Authentication feature\n\nâœ“ Created group f7e8d9c0\n  Run `taspr sync --open` to create the PR.\n```\n\n### taspr group edit\nModify an existing group's range or title.\n\n### taspr group dissolve\nBreak a group back into individual commits.\n\n## Deliverable\n`taspr group create/edit/dissolve` commands for managing multi-commit PRs.\n\n## Dependencies\n- Epic 2 must be complete (commits have IDs)\n\n## Validation\nGroups must not overlap and must be closed (Start has matching End).\n\n## Priority\nP2 - Enhancement after basic workflow is complete.","status":"open","priority":2,"issue_type":"epic","created_at":"2025-12-25T14:33:41.928419-05:00","updated_at":"2025-12-25T14:33:41.928419-05:00","dependencies":[{"issue_id":"taspr-7mu","depends_on_id":"taspr-7tr","type":"blocks","created_at":"2025-12-25T14:33:46.040656-05:00","created_by":"daemon"},{"issue_id":"taspr-7mu","depends_on_id":"taspr-7tr","type":"depends-on","created_at":"2025-12-25T14:33:46.040656-05:00","created_by":"daemon"}]}
{"id":"taspr-7tr","title":"Epic 2: Initialize Commits for Tracking","description":"## Goal\nAdd `Taspr-Commit-Id` trailers to commits that don't have them, enabling stable tracking across rebases.\n\n## Background\n\n### The Tracking Problem\nGit commit hashes change whenever a commit is rebased, amended, or cherry-picked. taspr needs a stable identifier that survives these operations.\n\n### The Solution: Commit ID Trailers\nEvery commit gets a `Taspr-Commit-Id` trailerâ€”an 8-character hex string that becomes part of the commit message:\n\n```\nfeat: add user authentication\n\nImplements login flow.\n\nTaspr-Commit-Id: a1b2c3d4\n```\n\nThis ID:\n- Survives rebases (message is preserved)\n- Links commits to branches and PRs\n- Enables tracking across history rewrites\n\n### ID Format\n- 8 hexadecimal characters (32 bits)\n- Generated via crypto.randomBytes(4).toString('hex')\n- Example: `a1b2c3d4`, `f7e8d9c0`\n\nWith 8 hex chars, collision probability is negligible for a typical stack (\u003c 50 commits). Once PRs merge, their commits leave the active tracking set.\n\n## Workflow\n\n1. User has commits without IDs\n2. Run `taspr sync`\n3. taspr identifies commits missing `Taspr-Commit-Id`\n4. taspr performs a rebase to add trailers to those commits\n5. Existing IDs are preserved; only missing ones are added\n\n## Implementation Approach\n\n### Interactive Rebase with exec\n```bash\ngit rebase -i --exec 'git commit --amend --no-edit -m \"$(git log -1 --format=%B | git interpret-trailers --trailer \"Taspr-Commit-Id: $(openssl rand -hex 4)\")\"' \u003cmerge-base\u003e\n```\n\nOr, more cleanly with a custom script that:\n1. Checks if commit already has Taspr-Commit-Id\n2. Only adds if missing\n3. Preserves all existing trailers\n\n### Sequence\n1. Check for dirty working tree (block if dirty)\n2. Find commits without Taspr-Commit-Id\n3. If none, no-op\n4. Rebase from merge-base, adding IDs to commits that need them\n5. Report which commits got IDs\n\n## Deliverable\nRunning `taspr sync` adds stable IDs to all commits in the stack via rebase, making them trackable.\n\n## Dependencies\n- Epic 1 must be complete (stack reading, trailer parsing)\n\n## Files to Create/Modify\n- src/core/sync.ts (create) - Sync orchestration\n- src/git/trailers.ts (modify) - Add trailer writing\n- src/cli/commands/sync.ts (create) - Sync command\n\n## Testable Outcome\n- New commits get IDs\n- Existing IDs are preserved through rebase\n- Dirty working tree blocks sync with clear message","status":"open","priority":1,"issue_type":"epic","created_at":"2025-12-25T14:24:34.266966-05:00","updated_at":"2025-12-25T14:24:34.266966-05:00","dependencies":[{"issue_id":"taspr-7tr","depends_on_id":"taspr-h87","type":"blocks","created_at":"2025-12-25T14:24:37.974238-05:00","created_by":"daemon"},{"issue_id":"taspr-7tr","depends_on_id":"taspr-h87","type":"depends-on","created_at":"2025-12-25T14:24:37.974238-05:00","created_by":"daemon"}]}
{"id":"taspr-7vt","title":"Error messages - clear, actionable errors throughout","description":"## Goal\nEnsure all error conditions produce clear, actionable error messages that help users understand what went wrong and how to fix it.\n\n## Error Categories to Handle\n\n### Git Errors\n- **Not a git repository**: 'Not in a git repository. Run this command from within a git project.'\n- **No commits**: 'No commits found between HEAD and origin/main. Create some commits first.'\n- **Dirty working tree**: 'You have uncommitted changes. Commit or stash them before running sync.'\n- **Detached HEAD**: 'You are in detached HEAD state. Check out a branch first.'\n- **Rebase in progress**: 'A rebase is in progress. Complete or abort it before continuing.'\n\n### GitHub Errors\n- **gh not installed**: 'The GitHub CLI (gh) is required but not installed. Install it from https://cli.github.com'\n- **gh not authenticated**: 'Not authenticated with GitHub. Run: gh auth login'\n- **No push access**: 'You don\\'t have push access to this repository.'\n- **PR creation failed**: Include the GitHub error message, suggest checking permissions\n- **Rate limited**: 'GitHub API rate limit exceeded. Try again in X minutes.'\n- **Network errors**: 'Could not connect to GitHub. Check your internet connection.'\n\n### Stack/Group Errors\n- **Overlapping groups**: 'Groups cannot overlap. Commits X and Y belong to multiple groups.'\n- **Unclosed group**: 'Group \"X\" started at commit Y but was never closed.'\n- **Invalid group range**: 'Group end marker found before start marker.'\n- **Empty stack**: 'No commits in current stack. Create commits on this branch first.'\n\n### Command Errors\n- **Invalid arguments**: Use Commander\\'s built-in validation with helpful messages\n- **Missing required options**: Commander handles this, but customize messages\n- **Invalid PR number**: 'PR #X not found. Check the PR number and try again.'\n\n## Implementation Guidelines\n\n### Error Message Format\n```\nError: \u003cbrief description\u003e\n\n\u003cdetailed explanation if needed\u003e\n\n\u003csuggested fix or next step\u003e\n```\n\n### Example Good Error\n```\nError: Cannot sync - uncommitted changes detected\n\nYou have 3 modified files that would be lost during rebase.\n\nTo fix:\n  git stash        # Save changes temporarily\n  taspr sync       # Run sync\n  git stash pop    # Restore changes\n```\n\n### Code Pattern\n```typescript\n// src/errors.ts\nexport class TasprError extends Error {\n  constructor(\n    message: string,\n    public readonly suggestion?: string,\n    public readonly details?: string\n  ) {\n    super(message);\n    this.name = 'TasprError';\n  }\n}\n\nexport function formatError(error: TasprError): string {\n  let output = `Error: ${error.message}`;\n  if (error.details) output += `\\n\\n${error.details}`;\n  if (error.suggestion) output += `\\n\\nTo fix:\\n  ${error.suggestion}`;\n  return output;\n}\n```\n\n### Audit All Commands\n- Review each command for error paths\n- Ensure consistent error formatting\n- Test error messages are helpful\n\n## Acceptance Criteria\n- [ ] All errors use consistent format\n- [ ] Errors include actionable suggestions where possible\n- [ ] No raw exception messages leak to users\n- [ ] Network/API errors are user-friendly\n- [ ] Exit codes are meaningful (0=success, 1=user error, 2=system error)","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-25T14:49:11.790611-05:00","updated_at":"2025-12-25T14:49:11.790611-05:00","dependencies":[{"issue_id":"taspr-7vt","depends_on_id":"taspr-8iv","type":"parent-child","created_at":"2025-12-25T15:01:36.509681-05:00","created_by":"daemon"}]}
{"id":"taspr-868","title":"Stack structure detection (PRUnit parsing)","description":"## Goal\nBuild a PRUnit[] array from commits, identifying which commits are singles and which belong to groups.\n\n## Background\nAfter parsing commits and their trailers, we need to understand the stack structure:\n- Commits without group trailers become individual PRUnits (type: 'single')\n- Commits between Taspr-Group-Start and Taspr-Group-End become one PRUnit (type: 'group')\n\n## Data Structures\n\n```typescript\ninterface PRUnit {\n  type: 'single' | 'group';\n  id: string;           // Taspr-Commit-Id (single) or group-id (group)\n  title: string;        // Commit subject (single) or Taspr-Group-Title (group)\n  commitIds: string[];  // All Taspr-Commit-Id values in this unit\n  commits: string[];    // Current git hashes\n}\n\ninterface CommitInfo {\n  hash: string;\n  subject: string;\n  body: string;\n  trailers: CommitTrailers;\n}\n```\n\n## Algorithm\n\n```typescript\nfunction detectPRUnits(commits: CommitInfo[]): PRUnit[] {\n  const units: PRUnit[] = [];\n  let currentGroup: Partial\u003cPRUnit\u003e | null = null;\n  \n  for (const commit of commits) {\n    const commitId = commit.trailers['Taspr-Commit-Id'];\n    const startId = commit.trailers['Taspr-Group-Start'];\n    const endId = commit.trailers['Taspr-Group-End'];\n    \n    if (startId \u0026\u0026 !currentGroup) {\n      // Start a new group\n      currentGroup = {\n        type: 'group',\n        id: startId,\n        title: commit.trailers['Taspr-Group-Title'] || commit.subject,\n        commitIds: [commitId],\n        commits: [commit.hash],\n      };\n    } else if (currentGroup) {\n      // Add to current group\n      currentGroup.commitIds!.push(commitId);\n      currentGroup.commits!.push(commit.hash);\n      \n      if (endId === currentGroup.id) {\n        // End of group\n        units.push(currentGroup as PRUnit);\n        currentGroup = null;\n      }\n    } else {\n      // Single commit\n      units.push({\n        type: 'single',\n        id: commitId,\n        title: commit.subject,\n        commitIds: [commitId],\n        commits: [commit.hash],\n      });\n    }\n  }\n  \n  // Handle unclosed group (validation error - covered in next task)\n  return units;\n}\n```\n\n## Edge Cases\n1. **Empty stack**: Return empty array\n2. **All singles**: Each commit becomes a PRUnit\n3. **All in one group**: One PRUnit with all commits\n4. **Mixed**: Singles and groups interspersed\n5. **Commit without Taspr-Commit-Id**: Still include (ID will be undefined, handled by sync later)\n\n## Testing Strategy\nTest with various commit arrangements:\n1. Three singles\n2. Three commits in one group\n3. Single, group of 2, single\n4. Group of 3, group of 2\n\n## Files to Create/Modify\n- src/core/stack.ts (create)\n\n## Acceptance Criteria\n- [ ] Correctly identifies single commits\n- [ ] Correctly identifies group boundaries\n- [ ] Preserves commit order (oldest first)\n- [ ] Handles commits without IDs gracefully\n- [ ] Has comprehensive tests for various scenarios","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T14:23:08.166742-05:00","updated_at":"2025-12-26T01:10:10.855841-05:00","closed_at":"2025-12-26T01:10:10.855841-05:00","close_reason":"Implemented detectPRUnits() in src/core/stack.ts with 10 passing tests","dependencies":[{"issue_id":"taspr-868","depends_on_id":"taspr-h87","type":"parent-child","created_at":"2025-12-25T14:23:12.019736-05:00","created_by":"daemon"},{"issue_id":"taspr-868","depends_on_id":"taspr-8i9","type":"blocks","created_at":"2025-12-25T14:23:12.300646-05:00","created_by":"daemon"},{"issue_id":"taspr-868","depends_on_id":"taspr-8i9","type":"depends-on","created_at":"2025-12-25T14:23:12.300646-05:00","created_by":"daemon"}]}
{"id":"taspr-8i9","title":"Trailer parsing","description":"## Goal\nExtract taspr-specific trailers from commit messages.\n\n## Background\nGit trailers are key-value pairs at the end of commit messages, following a specific format:\n```\nfeat: add user authentication\n\nImplements login flow with session management.\n\nTaspr-Commit-Id: a1b2c3d4\nTaspr-Group-Start: f7e8d9c0\nTaspr-Group-Title: Authentication feature\n```\n\ntaspr uses these trailers:\n- `Taspr-Commit-Id`: 8 hex chars, unique ID for each commit (survives rebases)\n- `Taspr-Group-Start`: 8 hex chars, marks the first commit of a group\n- `Taspr-Group-Title`: String, PR title for the group\n- `Taspr-Group-End`: 8 hex chars (same as Group-Start), marks the last commit of a group\n\n## Implementation\n\n### Using git interpret-trailers\n```bash\ngit interpret-trailers --parse \u003c\u003c\u003c \"commit message body\"\n```\n\nThis outputs:\n```\nTaspr-Commit-Id: a1b2c3d4\nTaspr-Group-Start: f7e8d9c0\n```\n\n### Function Signatures\n```typescript\ninterface CommitTrailers {\n  'Taspr-Commit-Id'?: string;\n  'Taspr-Group-Start'?: string;\n  'Taspr-Group-Title'?: string;\n  'Taspr-Group-End'?: string;\n  [key: string]: string | undefined;  // Allow other trailers\n}\n\nasync function parseTrailers(commitBody: string): Promise\u003cCommitTrailers\u003e\n\n// Convenience function to get trailers for a commit\nasync function getCommitTrailers(commitHash: string): Promise\u003cCommitTrailers\u003e\n```\n\n### Edge Cases\n1. **No trailers**: Return empty object\n2. **Non-taspr trailers**: Include them (e.g., Co-authored-by)\n3. **Malformed trailers**: Let git interpret-trailers handle\n4. **Multiple values for same key**: Use last value (git's behavior)\n\n## Testing Strategy\nTest with various commit message formats:\n1. No trailers\n2. Single trailer\n3. Multiple trailers\n4. Mixed taspr and other trailers\n5. Trailers with special characters in values\n\n## Files to Create/Modify\n- src/git/trailers.ts (create)\n\n## Acceptance Criteria\n- [ ] Correctly parses all taspr trailer types\n- [ ] Handles commits without trailers\n- [ ] Uses git interpret-trailers for correct parsing\n- [ ] Has unit tests for various message formats","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T14:22:49.259548-05:00","updated_at":"2025-12-26T01:07:19.162812-05:00","closed_at":"2025-12-26T01:07:19.162812-05:00","close_reason":"Implemented parseTrailers() and getCommitTrailers() in src/git/trailers.ts with 13 passing tests","dependencies":[{"issue_id":"taspr-8i9","depends_on_id":"taspr-h87","type":"parent-child","created_at":"2025-12-25T14:22:53.156159-05:00","created_by":"daemon"},{"issue_id":"taspr-8i9","depends_on_id":"taspr-6nw","type":"blocks","created_at":"2025-12-25T14:22:53.429839-05:00","created_by":"daemon"},{"issue_id":"taspr-8i9","depends_on_id":"taspr-6nw","type":"depends-on","created_at":"2025-12-25T14:22:53.429839-05:00","created_by":"daemon"}]}
{"id":"taspr-8iv","title":"Epic 9: Polish and Distribution","description":"## Goal\nProduction-ready CLI with good error handling and installation.\n\n## Background\nAfter all features are implemented, this epic focuses on:\n- Consistent, helpful error messages\n- Dependency checks (gh CLI)\n- Cross-platform builds\n- Easy installation\n- Documentation\n\n## Deliverable\ntaspr can be installed and used on a fresh machine without friction.\n\n## Dependencies\n- All previous epics should be complete\n\n## Priority\nP3 - Release prep after features are stable.\n\n## Key Areas\n\n### Error Messages\nEvery error should:\n- Explain what went wrong\n- Suggest how to fix it\n- Include relevant context (commit hashes, PR numbers)\n\n### gh CLI Dependency\ntaspr requires gh CLI for GitHub operations:\n- Check for installation\n- Check for authentication\n- Clear messages if missing\n\n### Cross-Platform\nSupport:\n- macOS (Intel and Apple Silicon)\n- Linux (x64 and ARM64)\n- (Optional) Windows\n\n### Installation\n- `curl | bash` installer for Unix\n- npm package fallback\n- Direct binary download from releases\n\n### Documentation\n- README with quick start\n- Command reference\n- Troubleshooting guide\n- Update CLAUDE.md with real commands","status":"open","priority":3,"issue_type":"epic","created_at":"2025-12-25T14:47:40.093629-05:00","updated_at":"2025-12-25T14:47:40.093629-05:00"}
{"id":"taspr-8ja","title":"View --all flag for all stacks","description":"## Goal\nShow all known stacks across branches with `taspr view --all`.\n\n## Implementation\n\n```typescript\n// src/cli/commands/view.ts\n\nasync function viewAll() {\n  // Find all branches with taspr prefix\n  const config = await getBranchNameConfig();\n  const prefix = config.branchPrefix;\n  \n  const result = await $\\`git branch -r --list 'origin/\\${prefix}/*'\\`;\n  const branches = result.stdout.toString().trim().split('\\n')\n    .map(b =\u003e b.trim().replace('origin/', ''));\n  \n  // Group by user\n  const byUser = groupBy(branches, b =\u003e b.split('/')[1]);\n  \n  // Display each stack\n  for (const [user, userBranches] of Object.entries(byUser)) {\n    console.log(\\`\\\\n### \\${user}'s stacks\\\\n\\`);\n    \n    // Group by local branch (if we can determine it)\n    // For now, just list all PRs\n    for (const branch of userBranches) {\n      const pr = await findPRByBranch(branch);\n      if (pr) {\n        console.log(\\`  \\${getPRStatusIcon(pr)} #\\${pr.number} \\${pr.title}\\`);\n      }\n    }\n  }\n}\n```\n\n## Output\n```\n$ taspr view --all\n\n### msims's stacks\n\nfeature/auth (3 PRs)\n  âœ“ #142 Add user model\n  â— #143 Authentication feature\n  â— #144 Add admin dashboard\n\nfeature/api (2 PRs)\n  â— #145 Add REST endpoints\n  â—‹ Add GraphQL\n\n### other-user's stacks\n...\n```\n\n## Challenges\n- Determining which branches belong to which \"stack\"\n- May require local state to track stack groupings\n\n## Simpler Alternative\nJust list all PRs owned by current user:\n```typescript\nasync function viewAll() {\n  const username = await getGitHubUsername();\n  const result = await $\\`gh pr list --author \\${username} --json number,title,state,headRefName\\`;\n  // Display all user's PRs\n}\n```\n\n## Files to Modify\n- src/cli/commands/view.ts\n\n## Acceptance Criteria\n- [ ] Lists all stacks/PRs with --all flag\n- [ ] Groups by user or branch\n- [ ] Shows status for each","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-25T14:33:18.747309-05:00","updated_at":"2025-12-25T14:33:18.747309-05:00","dependencies":[{"issue_id":"taspr-8ja","depends_on_id":"taspr-v0c","type":"parent-child","created_at":"2025-12-25T14:33:23.016339-05:00","created_by":"daemon"},{"issue_id":"taspr-8ja","depends_on_id":"taspr-2m1","type":"blocks","created_at":"2025-12-25T14:33:23.289568-05:00","created_by":"daemon"},{"issue_id":"taspr-8ja","depends_on_id":"taspr-2m1","type":"depends-on","created_at":"2025-12-25T14:33:23.289568-05:00","created_by":"daemon"}]}
{"id":"taspr-8mh","title":"Build for all platforms - macOS and Linux binaries","description":"## Goal\nBuild standalone taspr binaries for macOS and Linux using Bun\\'s `bun build --compile` feature.\n\n## Target Platforms\n\n| Platform | Architecture | Target Flag | Binary Name |\n|----------|-------------|-------------|-------------|\n| macOS Intel | x64 | `--target=bun-darwin-x64` | taspr-darwin-x64 |\n| macOS Apple Silicon | ARM64 | `--target=bun-darwin-arm64` | taspr-darwin-arm64 |\n| Linux | x64 | `--target=bun-linux-x64` | taspr-linux-x64 |\n| Linux | ARM64 | `--target=bun-linux-arm64` | taspr-linux-arm64 |\n\nWindows support deferred - most stacked PR workflows are macOS/Linux.\n\n## Bun Compile Basics\n\n```bash\n# Single platform (current)\nbun build --compile src/cli/index.ts --outfile taspr\n\n# Cross-compile for specific target\nbun build --compile --target=bun-darwin-arm64 src/cli/index.ts --outfile taspr-darwin-arm64\n\n# With bytecode for faster startup (experimental)\nbun build --compile --bytecode src/cli/index.ts --outfile taspr\n```\n\n## Binary Size Expectations\n- macOS: ~51MB (includes Bun runtime)\n- Linux: ~50MB\n- These are larger than Go binaries but acceptable for dev tools\n\n## Build Script\n\n```typescript\n// scripts/build.ts\nimport { $ } from 'bun';\n\nconst targets = [\n  { name: 'darwin-x64', target: 'bun-darwin-x64' },\n  { name: 'darwin-arm64', target: 'bun-darwin-arm64' },\n  { name: 'linux-x64', target: 'bun-linux-x64' },\n  { name: 'linux-arm64', target: 'bun-linux-arm64' },\n];\n\nconst entrypoint = 'src/cli/index.ts';\nconst outdir = 'dist';\n\nawait $`mkdir -p ${outdir}`;\n\nfor (const { name, target } of targets) {\n  console.log(`Building for ${name}...`);\n  await $`bun build --compile --target=${target} ${entrypoint} --outfile ${outdir}/taspr-${name}`;\n  console.log(`  âœ“ dist/taspr-${name}`);\n}\n\nconsole.log('\\nAll builds complete\\!');\n```\n\n## package.json Scripts\n\n```json\n{\n  \"scripts\": {\n    \"build\": \"bun run scripts/build.ts\",\n    \"build:local\": \"bun build --compile src/cli/index.ts --outfile dist/taspr\",\n    \"build:darwin-arm64\": \"bun build --compile --target=bun-darwin-arm64 src/cli/index.ts --outfile dist/taspr-darwin-arm64\",\n    \"build:darwin-x64\": \"bun build --compile --target=bun-darwin-x64 src/cli/index.ts --outfile dist/taspr-darwin-x64\",\n    \"build:linux-x64\": \"bun build --compile --target=bun-linux-x64 src/cli/index.ts --outfile dist/taspr-linux-x64\",\n    \"build:linux-arm64\": \"bun build --compile --target=bun-linux-arm64 src/cli/index.ts --outfile dist/taspr-linux-arm64\"\n  }\n}\n```\n\n## GitHub Actions for Releases\n\n```yaml\n# .github/workflows/release.yml\nname: Release\n\non:\n  push:\n    tags:\n      - 'v*'\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      \n      - uses: oven-sh/setup-bun@v1\n        with:\n          bun-version: latest\n      \n      - run: bun install\n      \n      - run: bun run build\n      \n      - name: Create Release\n        uses: softprops/action-gh-release@v1\n        with:\n          files: |\n            dist/taspr-darwin-x64\n            dist/taspr-darwin-arm64\n            dist/taspr-linux-x64\n            dist/taspr-linux-arm64\n```\n\n## Version Embedding\n\n```typescript\n// src/version.ts\n// This file is updated by build script\nexport const VERSION = '0.1.0';\nexport const BUILD_DATE = '2025-01-01';\nexport const COMMIT_SHA = 'abc1234';\n```\n\nBuild script can update this from git:\n```typescript\nconst version = await $`git describe --tags --always`.text();\nconst sha = await $`git rev-parse --short HEAD`.text();\n```\n\n## Testing Binaries\n\nTest each platform binary:\n```bash\n# On appropriate platform\n./dist/taspr-darwin-arm64 --version\n./dist/taspr-darwin-arm64 --help\n./dist/taspr-darwin-arm64 view\n```\n\nCross-platform testing via Docker for Linux binaries.\n\n## Acceptance Criteria\n- [ ] `bun run build` produces all 4 platform binaries\n- [ ] `bun run build:local` produces binary for current platform\n- [ ] Binaries are standalone (no external dependencies except git, gh)\n- [ ] --version shows correct version info\n- [ ] GitHub Actions workflow builds on tag push\n- [ ] Binaries are attached to GitHub releases\n- [ ] dist/ is in .gitignore","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-25T14:50:24.67684-05:00","updated_at":"2025-12-25T14:50:24.67684-05:00","dependencies":[{"issue_id":"taspr-8mh","depends_on_id":"taspr-8iv","type":"parent-child","created_at":"2025-12-25T15:01:37.342706-05:00","created_by":"daemon"}]}
{"id":"taspr-a64","title":"Epic 8: Rebase and Conflict Handling","description":"## Goal\nHandle rebasing onto updated main and conflict resolution.\n\n## Background\n\n### The Rebase Problem\nAs main advances, stacks fall behind. `taspr sync` should:\n1. Detect when stack is behind origin/main\n2. Rebase stack onto latest main\n3. Handle conflicts gracefully\n4. Update all affected PR branches\n\n### Conflict Scenarios\n1. **Automatic resolve**: Git handles the conflict automatically\n2. **Manual resolve**: User must fix conflicts\n3. **Stack cascade**: Rebasing bottom changes all commits above\n\n## Workflow\n\n### Normal Rebase\n```\n$ taspr sync\n\nâœ“ Rebased onto origin/main (4 commits)\nâœ“ Updated 3 PR branches\n```\n\n### Conflict\n```\n$ taspr sync\n\nRebasing onto origin/main...\nâœ— Conflict in src/auth.ts\n\n  Please resolve the conflict and run:\n    git add src/auth.ts\n    git rebase --continue\n    taspr sync\n```\n\n## Deliverable\n`taspr sync` rebases if behind origin/main, with clear conflict handling.\n\n## Dependencies\n- Epic 4 must be complete (branch updates)\n\n## Key Considerations\n- Preserving Taspr-Commit-Id trailers through rebase\n- Updating all affected branches after rebase\n- Clear instructions for manual conflict resolution\n\n## Priority\nP2 - Robustness feature after MVP.","status":"open","priority":2,"issue_type":"epic","created_at":"2025-12-25T14:35:58.534692-05:00","updated_at":"2025-12-25T14:35:58.534692-05:00","dependencies":[{"issue_id":"taspr-a64","depends_on_id":"taspr-1ni","type":"blocks","created_at":"2025-12-25T14:36:02.243595-05:00","created_by":"daemon"},{"issue_id":"taspr-a64","depends_on_id":"taspr-1ni","type":"depends-on","created_at":"2025-12-25T14:36:02.243595-05:00","created_by":"daemon"}]}
{"id":"taspr-b7d","title":"Group validation (overlapping and unclosed)","description":"## Goal\nDetect and report malformed groups: overlapping groups and unclosed groups.\n\n## Background\nGroups must follow strict rules:\n1. **No overlapping**: A group cannot start inside another group\n2. **Must close**: Every Taspr-Group-Start must have a matching Taspr-Group-End\n\nValidation happens during stack parsing and should return clear, actionable errors.\n\n## Error Types\n\n```typescript\ntype StackParseResult = \n  | { ok: true; units: PRUnit[] }\n  | { ok: false; error: 'unclosed-group'; groupId: string; startCommit: string; groupTitle: string }\n  | { ok: false; error: 'overlapping-groups'; \n      group1: { id: string; title: string; startCommit: string };\n      group2: { id: string; title: string; startCommit: string };\n      overlappingCommit: string }\n```\n\n## Validation Algorithm\n\n```typescript\nfunction validateAndDetectPRUnits(commits: CommitInfo[]): StackParseResult {\n  let activeGroup: { id: string; title: string; start: string } | null = null;\n  \n  for (const commit of commits) {\n    const startId = commit.trailers['Taspr-Group-Start'];\n    const endId = commit.trailers['Taspr-Group-End'];\n    \n    // Check for overlapping groups\n    if (startId \u0026\u0026 activeGroup \u0026\u0026 startId !== activeGroup.id) {\n      return {\n        ok: false,\n        error: 'overlapping-groups',\n        group1: activeGroup,\n        group2: { \n          id: startId, \n          title: commit.trailers['Taspr-Group-Title'] || commit.subject,\n          startCommit: commit.hash \n        },\n        overlappingCommit: commit.hash,\n      };\n    }\n    \n    if (startId \u0026\u0026 !activeGroup) {\n      activeGroup = { \n        id: startId, \n        title: commit.trailers['Taspr-Group-Title'] || commit.subject,\n        start: commit.hash \n      };\n    }\n    \n    if (endId \u0026\u0026 activeGroup \u0026\u0026 endId === activeGroup.id) {\n      activeGroup = null;\n    }\n  }\n  \n  // Check for unclosed group\n  if (activeGroup) {\n    return {\n      ok: false,\n      error: 'unclosed-group',\n      groupId: activeGroup.id,\n      startCommit: activeGroup.start,\n      groupTitle: activeGroup.title,\n    };\n  }\n  \n  // If validation passes, run detection\n  return { ok: true, units: detectPRUnits(commits) };\n}\n```\n\n## Error Messages (for CLI)\n\n### Unclosed Group\n```\nâœ— Error: Unclosed group starting at commit b2c3d4e5\n\n  Group f7e8d9c0 (\"Auth feature\") has Taspr-Group-Start but no \n  matching Taspr-Group-End was found in subsequent commits.\n  \n  To fix, either:\n    1. Run `taspr group edit` to set the end boundary\n    2. Run `taspr group dissolve` to remove the incomplete group\n```\n\n### Overlapping Groups\n```\nâœ— Error: Overlapping groups detected\n\n  Group \"Auth feature\" (f7e8d9c0):\n    starts at b2c3d4e5\n\n  Group \"Login flow\" (a9b8c7d6):\n    starts at c3d4e5f6 (inside \"Auth feature\")\n\n  To fix, run `taspr group edit` to adjust the ranges.\n```\n\n## Testing Strategy\n1. Valid stack with no groups\n2. Valid stack with one group\n3. Valid stack with multiple non-overlapping groups\n4. Unclosed group (Start but no End)\n5. Overlapping groups (Start inside another Start)\n6. End without Start (malformed, should be ignored or warned)\n\n## Files to Create/Modify\n- src/core/stack.ts (modify to add validation)\n\n## Acceptance Criteria\n- [ ] Detects unclosed groups with clear error\n- [ ] Detects overlapping groups with clear error\n- [ ] Returns success with PRUnits when valid\n- [ ] Error messages include commit hashes for debugging\n- [ ] Has tests for all validation scenarios","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T14:23:31.178628-05:00","updated_at":"2025-12-26T01:18:36.350318-05:00","closed_at":"2025-12-26T01:18:36.350318-05:00","close_reason":"Implemented parseStack() with validation for unclosed and overlapping groups, 7 new tests","dependencies":[{"issue_id":"taspr-b7d","depends_on_id":"taspr-h87","type":"parent-child","created_at":"2025-12-25T14:23:35.162413-05:00","created_by":"daemon"},{"issue_id":"taspr-b7d","depends_on_id":"taspr-868","type":"blocks","created_at":"2025-12-25T14:23:35.437374-05:00","created_by":"daemon"},{"issue_id":"taspr-b7d","depends_on_id":"taspr-868","type":"depends-on","created_at":"2025-12-25T14:23:35.437374-05:00","created_by":"daemon"}]}
{"id":"taspr-bg5","title":"Merged PR detection and cleanup","description":"## Goal\nIdentify merged PRs and clean them up from local tracking.\n\n## Background\nAfter a PR merges:\n1. The PR is in \"merged\" state on GitHub\n2. The branch can be deleted\n3. Local tracking should stop including it in the stack\n\n## Implementation\n\n### Detecting Merged PRs\n```typescript\nasync function getMergedPRUnits(\n  units: PRUnit[],\n  config: BranchNameConfig\n): Promise\u003cPRUnit[]\u003e {\n  const merged: PRUnit[] = [];\n  \n  for (const unit of units) {\n    const branch = getBranchName(unit.id, config);\n    const pr = await findPRByBranch(branch);\n    \n    if (pr?.state === 'merged') {\n      merged.push(unit);\n    }\n  }\n  \n  return merged;\n}\n```\n\n### Cleanup Actions\n1. **Delete remote branch** (optional):\n   ```bash\n   git push origin --delete taspr/msims/a1b2c3d4\n   ```\n\n2. **Report merged PRs**:\n   ```\n   âœ“ PR #142 merged to main\n   âœ“ Deleted branch taspr/msims/a1b2c3d4\n   ```\n\n### During Sync\n```typescript\nasync function cleanupMergedPRs(units: PRUnit[]): Promise\u003cPRUnit[]\u003e {\n  const merged = await getMergedPRUnits(units);\n  \n  if (merged.length \u003e 0) {\n    console.log(\\`âœ“ Removed \\${merged.length} merged PR(s) from tracking\\`);\n    \n    // Optionally delete remote branches\n    for (const unit of merged) {\n      await deleteRemoteBranch(getBranchName(unit.id));\n    }\n  }\n  \n  // Return remaining (non-merged) units\n  return units.filter(u =\u003e !merged.includes(u));\n}\n```\n\n## Integration with View\nAfter landing, `taspr view` shows:\n- Merged PRs with âœ“ status\n- Or excludes merged PRs entirely (after sync)\n\n## Testing\n- Detect merged state\n- Delete remote branch\n- Remaining PRs still tracked\n\n## Files to Create/Modify\n- src/core/sync.ts\n- src/github/branches.ts\n\n## Acceptance Criteria\n- [ ] Detects merged PRs via GitHub API\n- [ ] Optionally deletes remote branches\n- [ ] Reports cleanup in sync output\n- [ ] Remaining stack is correctly updated","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-25T14:31:11.906558-05:00","updated_at":"2025-12-25T14:31:11.906558-05:00","dependencies":[{"issue_id":"taspr-bg5","depends_on_id":"taspr-6le","type":"parent-child","created_at":"2025-12-25T14:31:15.902133-05:00","created_by":"daemon"},{"issue_id":"taspr-bg5","depends_on_id":"taspr-bwi","type":"blocks","created_at":"2025-12-25T14:31:16.180399-05:00","created_by":"daemon"},{"issue_id":"taspr-bg5","depends_on_id":"taspr-bwi","type":"depends-on","created_at":"2025-12-25T14:31:16.180399-05:00","created_by":"daemon"}]}
{"id":"taspr-bvy","title":"GitHub username detection","description":"## Goal\nGet the current user's GitHub username for branch naming.\n\n## Implementation\n\n```typescript\n// src/github/api.ts\n\nasync function getGitHubUsername(): Promise\u003cstring\u003e {\n  const result = await $\\`gh api user --jq .login\\`.nothrow();\n  \n  if (result.exitCode !== 0) {\n    throw new GitHubAuthError(\n      'Failed to get GitHub username. Ensure gh CLI is installed and authenticated.\\n' +\n      'Run: gh auth login'\n    );\n  }\n  \n  return result.stdout.toString().trim();\n}\n```\n\n### Error Handling\nThe `gh api user` command fails if:\n1. `gh` CLI is not installed\n2. User is not authenticated\n3. Network issues\n\nProvide clear error messages for each case.\n\n### gh CLI Dependency\ntaspr delegates all GitHub auth to `gh`. This means:\n- No token management in taspr\n- User's existing `gh` auth works automatically\n- Enterprise GitHub works if configured in `gh`\n\n### Check for gh Installation\n```typescript\nasync function ensureGhInstalled(): Promise\u003cvoid\u003e {\n  const result = await $\\`which gh\\`.nothrow();\n  if (result.exitCode !== 0) {\n    throw new DependencyError(\n      'gh CLI not found. Please install it:\\n' +\n      '  brew install gh          # macOS\\n' +\n      '  apt install gh           # Ubuntu\\n' +\n      '  https://cli.github.com   # Other'\n    );\n  }\n}\n```\n\n## Testing\n- Mock successful gh api response\n- Mock gh not installed\n- Mock gh not authenticated\n\n## Files to Create\n- src/github/api.ts\n\n## Acceptance Criteria\n- [ ] Returns GitHub username\n- [ ] Clear error if gh not installed\n- [ ] Clear error if gh not authenticated\n- [ ] Error messages include remediation steps","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-25T14:27:02.008649-05:00","updated_at":"2025-12-25T14:27:02.008649-05:00","dependencies":[{"issue_id":"taspr-bvy","depends_on_id":"taspr-osw","type":"parent-child","created_at":"2025-12-25T14:27:05.694237-05:00","created_by":"daemon"}]}
{"id":"taspr-bwi","title":"PR merge via GitHub API","description":"## Goal\nMerge a PR using the GitHub API via gh CLI.\n\n## Implementation\n\n```typescript\n// src/github/pr.ts\n\ntype MergeMethod = 'merge' | 'squash' | 'rebase';\n\ninterface MergeResult {\n  sha: string;      // Merge commit SHA\n  merged: boolean;\n}\n\nasync function mergePR(\n  prNumber: number,\n  method?: MergeMethod\n): Promise\u003cMergeResult\u003e {\n  // Use gh CLI to merge\n  const methodFlag = method ? \\`--\\${method}\\` : '';\n  \n  const result = await $\\`gh pr merge \\${prNumber} \\${methodFlag} --json sha,state\\`.nothrow();\n  \n  if (result.exitCode !== 0) {\n    const error = result.stderr.toString();\n    if (error.includes('not mergeable')) {\n      throw new PRNotMergeableError(prNumber);\n    }\n    throw new GitHubAPIError(\\`Failed to merge PR #\\${prNumber}: \\${error}\\`);\n  }\n  \n  const data = JSON.parse(result.stdout.toString());\n  return { sha: data.sha, merged: true };\n}\n```\n\n### Checking Mergeability\n```typescript\ninterface PRMergeStatus {\n  mergeable: boolean;\n  mergeableState: string;\n  checksStatus: 'pending' | 'passing' | 'failing';\n  reviewDecision: 'approved' | 'review_required' | 'changes_requested';\n}\n\nasync function getPRMergeStatus(prNumber: number): Promise\u003cPRMergeStatus\u003e {\n  const result = await $\\`gh pr view \\${prNumber} --json mergeable,mergeStateStatus,reviewDecision,statusCheckRollup\\`;\n  const data = JSON.parse(result.stdout.toString());\n  \n  return {\n    mergeable: data.mergeable === 'MERGEABLE',\n    mergeableState: data.mergeStateStatus,\n    checksStatus: getChecksStatus(data.statusCheckRollup),\n    reviewDecision: data.reviewDecision?.toLowerCase() || 'review_required',\n  };\n}\n```\n\n## Error Handling\n- PR not found â†’ clear error\n- PR not mergeable â†’ explain why (conflicts, checks, reviews)\n- Network error â†’ retry logic\n\n## Testing\n- Successful merge\n- Merge blocked by checks\n- Merge blocked by reviews\n- Merge blocked by conflicts\n\n## Files to Modify\n- src/github/pr.ts\n\n## Acceptance Criteria\n- [ ] Merges PR via gh CLI\n- [ ] Returns merge commit SHA\n- [ ] Clear errors for non-mergeable PRs\n- [ ] Respects repo's merge settings","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-25T14:30:56.060186-05:00","updated_at":"2025-12-25T14:30:56.060186-05:00","dependencies":[{"issue_id":"taspr-bwi","depends_on_id":"taspr-6le","type":"parent-child","created_at":"2025-12-25T14:30:59.702866-05:00","created_by":"daemon"}]}
{"id":"taspr-d6b","title":"Conflict detection and reporting","description":"## Goal\nDetect rebase conflicts and provide clear instructions for resolution.\n\n## Implementation\n\n```typescript\n// src/git/rebase.ts\n\ninterface ConflictInfo {\n  files: string[];\n  currentCommit: string;\n  currentSubject: string;\n}\n\nasync function getConflictInfo(): Promise\u003cConflictInfo | null\u003e {\n  // Check if we're in a rebase\n  const rebaseDir = await $\\`git rev-parse --git-path rebase-merge\\`.text();\n  const exists = await Bun.file(rebaseDir.trim()).exists();\n  \n  if (!exists) return null;\n  \n  // Get conflicting files\n  const status = await $\\`git status --porcelain\\`.text();\n  const conflicts = status\n    .split('\\n')\n    .filter(line =\u003e line.startsWith('UU ') || line.startsWith('AA '))\n    .map(line =\u003e line.slice(3));\n  \n  // Get current commit being rebased\n  const head = await $\\`git rev-parse HEAD\\`.text();\n  const subject = await $\\`git log -1 --format=%s HEAD\\`.text();\n  \n  return {\n    files: conflicts,\n    currentCommit: head.trim().slice(0, 8),\n    currentSubject: subject.trim(),\n  };\n}\n```\n\n### Error Message\n```typescript\nfunction formatConflictError(info: ConflictInfo): string {\n  return \\`\nâœ— Rebase conflict while applying commit \\${info.currentCommit}\n  \"\\${info.currentSubject}\"\n\nConflicting files:\n\\${info.files.map(f =\u003e \\`  â€¢ \\${f}\\`).join('\\n')}\n\nTo resolve:\n  1. Edit the conflicting files\n  2. git add \u003cfixed files\u003e\n  3. git rebase --continue\n  4. taspr sync\n\nTo abort:\n  git rebase --abort\n\\`.trim();\n}\n```\n\n## Testing\n- Detect conflict in progress\n- List all conflicting files\n- Clear resolution instructions\n\n## Files to Modify\n- src/git/rebase.ts\n- src/cli/output.ts\n\n## Acceptance Criteria\n- [ ] Detects ongoing rebase conflict\n- [ ] Lists conflicting files\n- [ ] Shows which commit is being applied\n- [ ] Provides clear resolution steps","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-25T14:36:43.502623-05:00","updated_at":"2025-12-25T14:36:43.502623-05:00","dependencies":[{"issue_id":"taspr-d6b","depends_on_id":"taspr-a64","type":"parent-child","created_at":"2025-12-25T14:36:47.54253-05:00","created_by":"daemon"},{"issue_id":"taspr-d6b","depends_on_id":"taspr-gs1","type":"blocks","created_at":"2025-12-25T14:36:47.822256-05:00","created_by":"daemon"},{"issue_id":"taspr-d6b","depends_on_id":"taspr-gs1","type":"depends-on","created_at":"2025-12-25T14:36:47.822256-05:00","created_by":"daemon"}]}
{"id":"taspr-d6u","title":"Fetch PR checks status","description":"## Goal\nGet CI check status for PRs.\n\n## Implementation\n\n```typescript\n// src/github/pr.ts\n\ntype ChecksStatus = 'pending' | 'passing' | 'failing';\n\nasync function getPRChecksStatus(prNumber: number): Promise\u003cChecksStatus\u003e {\n  const result = await $\\`gh pr checks \\${prNumber} --json state\\`;\n  const checks = JSON.parse(result.stdout.toString());\n  \n  const states = checks.map((c: any) =\u003e c.state);\n  \n  if (states.some((s: string) =\u003e s === 'FAILURE')) return 'failing';\n  if (states.some((s: string) =\u003e s === 'PENDING')) return 'pending';\n  return 'passing';\n}\n```\n\n## Alternative: gh pr view\n```typescript\nasync function getPRChecksStatus(prNumber: number): Promise\u003cChecksStatus\u003e {\n  const result = await $\\`gh pr view \\${prNumber} --json statusCheckRollup\\`;\n  const data = JSON.parse(result.stdout.toString());\n  \n  // statusCheckRollup contains aggregated status\n  const rollup = data.statusCheckRollup;\n  \n  if (rollup.some((c: any) =\u003e c.conclusion === 'FAILURE')) return 'failing';\n  if (rollup.some((c: any) =\u003e c.status === 'IN_PROGRESS')) return 'pending';\n  return 'passing';\n}\n```\n\n## Testing\n- PR with passing checks\n- PR with failing checks\n- PR with pending checks\n- PR with no checks configured\n\n## Files to Modify\n- src/github/pr.ts\n\n## Acceptance Criteria\n- [ ] Returns passing/failing/pending status\n- [ ] Handles PRs without checks\n- [ ] Works with various CI providers","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-25T14:32:24.225276-05:00","updated_at":"2025-12-25T14:32:24.225276-05:00","dependencies":[{"issue_id":"taspr-d6u","depends_on_id":"taspr-v0c","type":"parent-child","created_at":"2025-12-25T14:32:27.950028-05:00","created_by":"daemon"}]}
{"id":"taspr-de7","title":"PR creation via gh CLI","description":"## Goal\nCreate GitHub PRs for PRUnits using the gh CLI.\n\n## Implementation\n\n```typescript\n// src/github/pr.ts\n\ninterface CreatePROptions {\n  title: string;\n  head: string;      // Branch name for this PR\n  base: string;      // Parent branch or main\n  body?: string;\n}\n\nasync function createPR(options: CreatePROptions): Promise\u003c{ number: number; url: string }\u003e {\n  const result = await $\\`gh pr create \n    --title ${options.title}\n    --head ${options.head}\n    --base ${options.base}\n    --body ${options.body || ''}\n  \\`.json();\n  \n  return {\n    number: result.number,\n    url: result.url,\n  };\n}\n```\n\n### Stack Structure\nFor a stack [A, B, C] (bottom to top):\n```\nPR for A: base = main,     head = taspr/user/a-id\nPR for B: base = A's head, head = taspr/user/b-id\nPR for C: base = B's head, head = taspr/user/c-id\n```\n\n```typescript\nasync function createStackPRs(\n  units: PRUnit[], \n  branches: Map\u003cstring, string\u003e,\n  defaultBranch: string\n): Promise\u003cMap\u003cstring, { number: number; url: string }\u003e\u003e {\n  const prs = new Map();\n  \n  let baseBranch = defaultBranch;\n  \n  for (const unit of units) {\n    const headBranch = branches.get(unit.id)!;\n    \n    const pr = await createPR({\n      title: unit.title,\n      head: headBranch,\n      base: baseBranch,\n    });\n    \n    prs.set(unit.id, pr);\n    baseBranch = headBranch; // Next PR bases on this one\n  }\n  \n  return prs;\n}\n```\n\n### Default Branch Detection\n```typescript\nasync function getDefaultBranch(): Promise\u003cstring\u003e {\n  // Try git config first\n  const configResult = await $\\`git config --get taspr.defaultBranch\\`.nothrow();\n  if (configResult.exitCode === 0) {\n    return configResult.stdout.toString().trim();\n  }\n  \n  // Fall back to origin's default\n  const remote = await $\\`git remote show origin\\`.text();\n  const match = remote.match(/HEAD branch: (\\S+)/);\n  return match?.[1] || 'main';\n}\n```\n\n### PR Body\nFor now, minimal body. Later can add stack visualization:\n\n```typescript\nfunction generatePRBody(unit: PRUnit): string {\n  if (unit.type === 'single') {\n    return ''; // Use commit message\n  }\n  \n  // For groups, list commits\n  return `## Commits\\n${unit.commits.map(c =\u003e `- ${c}`).join('\\n')}`;\n}\n```\n\n## Edge Cases\n1. **PR already exists**: Don't create duplicate (handled by lookup task)\n2. **Base branch doesn't exist**: Error (shouldn't happen if we push in order)\n3. **Rate limiting**: Retry logic\n\n## Testing\n- Create single PR\n- Create stacked PRs with correct base/head\n- Verify titles match PRUnit titles\n\n## Files to Create\n- src/github/pr.ts\n\n## Acceptance Criteria\n- [ ] Creates PR with correct title\n- [ ] Sets correct base/head branches\n- [ ] Returns PR number and URL\n- [ ] PRs form correct stack (each bases on previous)","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-25T14:27:38.225862-05:00","updated_at":"2025-12-25T14:27:38.225862-05:00","dependencies":[{"issue_id":"taspr-de7","depends_on_id":"taspr-osw","type":"parent-child","created_at":"2025-12-25T14:27:41.917963-05:00","created_by":"daemon"},{"issue_id":"taspr-de7","depends_on_id":"taspr-n48","type":"blocks","created_at":"2025-12-25T14:27:42.19973-05:00","created_by":"daemon"},{"issue_id":"taspr-de7","depends_on_id":"taspr-n48","type":"depends-on","created_at":"2025-12-25T14:27:42.19973-05:00","created_by":"daemon"}]}
{"id":"taspr-e6f","title":"Fetch PR comment threads","description":"## Goal\nGet comment thread resolution status for PRs.\n\n## Implementation\n\n```typescript\n// src/github/pr.ts\n\ninterface CommentStatus {\n  total: number;\n  resolved: number;\n}\n\nasync function getPRCommentStatus(prNumber: number): Promise\u003cCommentStatus\u003e {\n  const result = await $\\`gh api repos/{owner}/{repo}/pulls/\\${prNumber}/comments --jq 'length'\\`;\n  const total = parseInt(result.stdout.toString().trim(), 10);\n  \n  // GraphQL needed for resolved count\n  const query = \\`\n    query {\n      repository(owner: \"{owner}\", name: \"{repo}\") {\n        pullRequest(number: \\${prNumber}) {\n          reviewThreads(first: 100) {\n            nodes {\n              isResolved\n            }\n          }\n        }\n      }\n    }\n  \\`;\n  \n  const gqlResult = await $\\`gh api graphql -f query='\\${query}'\\`;\n  const threads = JSON.parse(gqlResult.stdout.toString())\n    .data.repository.pullRequest.reviewThreads.nodes;\n  \n  const resolved = threads.filter((t: any) =\u003e t.isResolved).length;\n  \n  return { total: threads.length, resolved };\n}\n```\n\n## Display\n```\nğŸ’¬ 3/5  # 3 of 5 threads resolved\n```\n\nWhen all resolved, don't show indicator.\n\n## Testing\n- PR with unresolved threads\n- PR with all threads resolved\n- PR with no review threads\n\n## Files to Modify\n- src/github/pr.ts\n\n## Acceptance Criteria\n- [ ] Returns thread count and resolved count\n- [ ] Uses GraphQL API for resolution status\n- [ ] Handles PRs without review threads","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-25T14:32:47.011606-05:00","updated_at":"2025-12-25T14:32:47.011606-05:00","dependencies":[{"issue_id":"taspr-e6f","depends_on_id":"taspr-v0c","type":"parent-child","created_at":"2025-12-25T14:32:50.920704-05:00","created_by":"daemon"}]}
{"id":"taspr-eik","title":"Change detection (local vs remote)","description":"## Goal\nDetect when local commits have changed relative to their remote branches.\n\n## Implementation\n\n```typescript\n// src/git/remote.ts\n\nasync function getRemoteBranchCommit(branchName: string): Promise\u003cstring | null\u003e {\n  // Fetch latest (optional - can skip for performance)\n  // await $\\`git fetch origin ${branchName}\\`.nothrow();\n  \n  const result = await $\\`git rev-parse origin/${branchName}\\`.nothrow();\n  if (result.exitCode !== 0) {\n    return null; // Branch doesn't exist on remote\n  }\n  return result.stdout.toString().trim();\n}\n\ninterface SyncStatus {\n  branchName: string;\n  localCommit: string;\n  remoteCommit: string | null;\n  needsUpdate: boolean;\n  needsCreate: boolean;\n}\n\nasync function getSyncStatus(unit: PRUnit, branchName: string): Promise\u003cSyncStatus\u003e {\n  const localCommit = unit.commits[unit.commits.length - 1];\n  const remoteCommit = await getRemoteBranchCommit(branchName);\n  \n  return {\n    branchName,\n    localCommit,\n    remoteCommit,\n    needsUpdate: remoteCommit !== null \u0026\u0026 remoteCommit !== localCommit,\n    needsCreate: remoteCommit === null,\n  };\n}\n```\n\n### Batch Status Check\n```typescript\nasync function getAllSyncStatuses(\n  units: PRUnit[], \n  config: BranchNameConfig\n): Promise\u003cMap\u003cstring, SyncStatus\u003e\u003e {\n  const statuses = new Map();\n  \n  for (const unit of units) {\n    const branch = getBranchName(unit.id, config);\n    const status = await getSyncStatus(unit, branch);\n    statuses.set(unit.id, status);\n  }\n  \n  return statuses;\n}\n```\n\n## Usage in Sync\n```typescript\nconst statuses = await getAllSyncStatuses(units, config);\n\nfor (const [id, status] of statuses) {\n  if (status.needsCreate) {\n    // Push new branch, create PR\n  } else if (status.needsUpdate) {\n    // Force push updated branch\n  } else {\n    // No change needed\n  }\n}\n```\n\n## Edge Cases\n1. **Branch doesn't exist**: needsCreate = true\n2. **Branch up to date**: needsUpdate = false\n3. **Branch behind**: needsUpdate = true\n\n## Testing\n- Local matches remote â†’ no update needed\n- Local differs from remote â†’ update needed\n- Remote branch doesn't exist â†’ create needed\n\n## Files to Create\n- src/git/remote.ts\n\n## Acceptance Criteria\n- [ ] Detects when local differs from remote\n- [ ] Detects when branch doesn't exist\n- [ ] Handles fetch errors gracefully","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-25T14:29:23.93778-05:00","updated_at":"2025-12-25T14:29:23.93778-05:00","dependencies":[{"issue_id":"taspr-eik","depends_on_id":"taspr-1ni","type":"parent-child","created_at":"2025-12-25T14:29:27.510279-05:00","created_by":"daemon"}]}
{"id":"taspr-fli","title":"Installation script - curl | bash installer","description":"## Goal\nCreate a simple installation script that users can run via `curl | bash` to install taspr.\n\n## Installation Command\n\n```bash\ncurl -fsSL https://raw.githubusercontent.com/OWNER/taspr/main/install.sh | bash\n```\n\n## Installation Script\n\n```bash\n#\\!/bin/bash\n# install.sh - Install taspr CLI\n\nset -euo pipefail\n\n# Configuration\nREPO=\"OWNER/taspr\"\nINSTALL_DIR=\"${INSTALL_DIR:-$HOME/.local/bin}\"\n\n# Detect platform\nOS=\"$(uname -s | tr '[:upper:]' '[:lower:]')\"\nARCH=\"$(uname -m)\"\n\ncase \"$OS\" in\n  darwin) OS=\"darwin\" ;;\n  linux) OS=\"linux\" ;;\n  *) echo \"Error: Unsupported OS: $OS\"; exit 1 ;;\nesac\n\ncase \"$ARCH\" in\n  x86_64) ARCH=\"x64\" ;;\n  amd64) ARCH=\"x64\" ;;\n  arm64) ARCH=\"arm64\" ;;\n  aarch64) ARCH=\"arm64\" ;;\n  *) echo \"Error: Unsupported architecture: $ARCH\"; exit 1 ;;\nesac\n\nBINARY=\"taspr-${OS}-${ARCH}\"\n\n# Get latest release\necho \"Fetching latest release...\"\nLATEST_TAG=$(curl -fsSL \"https://api.github.com/repos/$REPO/releases/latest\" | grep '\"tag_name\":' | sed -E 's/.*\"([^\"]+)\".*/\\1/')\n\nif [ -z \"$LATEST_TAG\" ]; then\n  echo \"Error: Could not determine latest release\"\n  exit 1\nfi\n\necho \"Installing taspr $LATEST_TAG for $OS/$ARCH...\"\n\n# Download binary\nDOWNLOAD_URL=\"https://github.com/$REPO/releases/download/$LATEST_TAG/$BINARY\"\nTMP_FILE=\"$(mktemp)\"\n\ncurl -fsSL \"$DOWNLOAD_URL\" -o \"$TMP_FILE\"\n\n# Create install directory if needed\nmkdir -p \"$INSTALL_DIR\"\n\n# Install binary\nchmod +x \"$TMP_FILE\"\nmv \"$TMP_FILE\" \"$INSTALL_DIR/taspr\"\n\necho \"\"\necho \"âœ“ taspr installed to $INSTALL_DIR/taspr\"\necho \"\"\n\n# Check if install dir is in PATH\nif [[ \":$PATH:\" \\!= *\":$INSTALL_DIR:\"* ]]; then\n  echo \"âš  $INSTALL_DIR is not in your PATH\"\n  echo \"\"\n  echo \"Add it to your shell config:\"\n  echo \"  echo 'export PATH=\\\"$INSTALL_DIR:\\$PATH\\\"' \u003e\u003e ~/.bashrc\"\n  echo \"  # or for zsh:\"\n  echo \"  echo 'export PATH=\\\"$INSTALL_DIR:\\$PATH\\\"' \u003e\u003e ~/.zshrc\"\n  echo \"\"\nfi\n\n# Verify installation\nif command -v taspr \u0026\u003e /dev/null; then\n  echo \"Installed version:\"\n  taspr --version\nelse\n  echo \"Run 'taspr --version' to verify installation\"\nfi\n\necho \"\"\necho \"Prerequisites:\"\necho \"  - git (you probably have this)\"\necho \"  - gh CLI (https://cli.github.com)\"\necho \"\"\necho \"Quick start:\"\necho \"  cd your-repo\"\necho \"  taspr view    # See your stack\"\necho \"  taspr sync    # Push to GitHub\"\n```\n\n## Alternative: npm/bunx Installation\n\nFor users who prefer npm/bun:\n\n```json\n// package.json\n{\n  \"name\": \"taspr\",\n  \"version\": \"0.1.0\",\n  \"bin\": {\n    \"taspr\": \"./dist/taspr\"\n  },\n  \"files\": [\n    \"dist/taspr\"\n  ]\n}\n```\n\n```bash\n# Global install via npm\nnpm install -g taspr\n\n# Or run without installing\nnpx taspr view\nbunx taspr view\n```\n\n## Uninstall Script\n\n```bash\n#\\!/bin/bash\n# uninstall.sh\n\nrm -f \"${INSTALL_DIR:-$HOME/.local/bin}/taspr\"\necho \"âœ“ taspr uninstalled\"\n```\n\n## Version Check / Update\n\nThe CLI could include update checking:\n```typescript\n// Check for updates (run occasionally, not every command)\nasync function checkForUpdates() {\n  const current = VERSION;\n  const latest = await fetchLatestVersion();\n  \n  if (semver.gt(latest, current)) {\n    console.log(`Update available: ${current} â†’ ${latest}`);\n    console.log('Run: curl -fsSL https://example.com/install.sh | bash');\n  }\n}\n```\n\n## Security Considerations\n\n- Script should verify checksums if we provide them\n- Use HTTPS for all downloads\n- Consider signing binaries (future enhancement)\n\n## Acceptance Criteria\n- [ ] install.sh works on macOS (Intel and Apple Silicon)\n- [ ] install.sh works on Linux (x64 and ARM64)\n- [ ] Script detects platform automatically\n- [ ] Script downloads correct binary from GitHub releases\n- [ ] Script provides PATH guidance if needed\n- [ ] Script verifies installation with --version\n- [ ] Prerequisites (git, gh) are clearly documented\n- [ ] Uninstall instructions provided","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-25T15:00:34.84736-05:00","updated_at":"2025-12-25T15:00:34.84736-05:00","dependencies":[{"issue_id":"taspr-fli","depends_on_id":"taspr-8iv","type":"parent-child","created_at":"2025-12-25T15:01:37.614674-05:00","created_by":"daemon"}]}
{"id":"taspr-fwm","title":"Trailer writing (add/update trailers)","description":"## Goal\nAdd the ability to write trailers to commit messages, not just read them.\n\n## Background\nEpic 1 implemented trailer reading. Now we need to write trailers:\n- Add new trailers to commits\n- Preserve existing trailers\n\n## Implementation\n\n### Using git interpret-trailers\n```bash\n# Add a trailer to a message\necho \"commit message\" | git interpret-trailers --trailer \"Taspr-Commit-Id: a1b2c3d4\"\n\n# Add multiple trailers\necho \"commit message\" | git interpret-trailers \\\n  --trailer \"Taspr-Commit-Id: a1b2c3d4\" \\\n  --trailer \"Taspr-Group-Start: f7e8d9c0\"\n```\n\n### Function Signatures\n```typescript\n// src/git/trailers.ts\n\n// Add trailers to a message string\nexport function addTrailers(\n  message: string, \n  trailers: Record\u003cstring, string\u003e\n): Promise\u003cstring\u003e\n\n// Add trailers to a specific commit (amends the commit)\nexport async function addTrailersToCommit(\n  commitHash: string, \n  trailers: Record\u003cstring, string\u003e\n): Promise\u003cvoid\u003e\n```\n\n### Amending a Commit\n```typescript\nasync function addTrailersToCommit(hash: string, trailers: Record\u003cstring, string\u003e) {\n  // Get current message\n  const message = await $`git log -1 --format=%B ${hash}`.text();\n  \n  // Add trailers\n  const newMessage = await addTrailers(message, trailers);\n  \n  // Amend commit (only works for HEAD)\n  // For non-HEAD commits, use rebase\n  await $`git commit --amend --no-edit -m ${newMessage}`;\n}\n```\n\n### Edge Cases\n1. **Message already has the trailer**: Update value or skip\n2. **Message has other trailers**: Preserve them\n3. **Message has no body**: Still works (trailers after blank line)\n\n## Testing\n- Add trailer to message without trailers\n- Add trailer to message with existing trailers\n- Add multiple trailers at once\n- Preserve existing unrelated trailers\n\n## Files to Modify\n- src/git/trailers.ts\n\n## Acceptance Criteria\n- [ ] Can add single trailer to message\n- [ ] Can add multiple trailers to message\n- [ ] Preserves existing trailers\n- [ ] Uses git interpret-trailers for correctness\n- [ ] Has tests for various scenarios","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-25T14:25:02.634601-05:00","updated_at":"2025-12-25T14:25:02.634601-05:00","dependencies":[{"issue_id":"taspr-fwm","depends_on_id":"taspr-7tr","type":"parent-child","created_at":"2025-12-25T14:25:06.604931-05:00","created_by":"daemon"},{"issue_id":"taspr-fwm","depends_on_id":"taspr-1es","type":"blocks","created_at":"2025-12-25T14:25:06.875423-05:00","created_by":"daemon"},{"issue_id":"taspr-fwm","depends_on_id":"taspr-1es","type":"depends-on","created_at":"2025-12-25T14:25:06.875423-05:00","created_by":"daemon"}]}
{"id":"taspr-gp1","title":"Group validation in sync","description":"## Goal\nEnforce group validation during sync: no overlapping groups, no unclosed groups.\n\n## Background\nGroup validation was implemented in Epic 1 for the view command. This task ensures sync also validates and blocks on invalid groups.\n\n## Implementation\n\n```typescript\n// In sync command, after parsing stack\nasync function syncCommand() {\n  const result = await parseStack();\n  \n  if (!result.ok) {\n    console.error(formatValidationError(result));\n    \n    // Provide actionable guidance\n    if (result.error === 'overlapping-groups') {\n      console.error('\\\\nTo fix, run `taspr group edit` to adjust the ranges.');\n    } else if (result.error === 'unclosed-group') {\n      console.error('\\\\nTo fix, either:');\n      console.error('  1. Run `taspr group edit` to set the end boundary');\n      console.error('  2. Run `taspr group dissolve` to remove the incomplete group');\n    }\n    \n    process.exit(1);\n  }\n  \n  // Continue with sync...\n}\n```\n\n## Error Messages\n\n### Overlapping Groups\n```\nâœ— Error: Overlapping groups detected\n\n  Group \"Auth feature\" (f7e8d9c0):\n    starts at b2c3d4e5\n\n  Group \"Login flow\" (a9b8c7d6):\n    starts at c3d4e5f6 (inside \"Auth feature\")\n\n  To fix, run `taspr group edit` to adjust the ranges.\n```\n\n### Unclosed Group\n```\nâœ— Error: Unclosed group starting at commit b2c3d4e5\n\n  Group f7e8d9c0 (\"Auth feature\") has Taspr-Group-Start but no \n  matching Taspr-Group-End was found in subsequent commits.\n  \n  To fix, either:\n    1. Run `taspr group edit` to set the end boundary\n    2. Run `taspr group dissolve` to remove the incomplete group\n```\n\n## Testing\n- Sync with valid groups passes\n- Sync with overlapping groups fails\n- Sync with unclosed group fails\n- Error messages are actionable\n\n## Files to Modify\n- src/cli/commands/sync.ts\n- src/cli/output.ts\n\n## Acceptance Criteria\n- [ ] Sync blocks on overlapping groups\n- [ ] Sync blocks on unclosed groups\n- [ ] Error messages include fix instructions\n- [ ] Points to relevant group commands","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-25T14:35:38.666664-05:00","updated_at":"2025-12-25T14:35:38.666664-05:00","dependencies":[{"issue_id":"taspr-gp1","depends_on_id":"taspr-7mu","type":"parent-child","created_at":"2025-12-25T14:35:42.768837-05:00","created_by":"daemon"},{"issue_id":"taspr-gp1","depends_on_id":"taspr-n47","type":"blocks","created_at":"2025-12-25T14:35:43.043106-05:00","created_by":"daemon"},{"issue_id":"taspr-gp1","depends_on_id":"taspr-n47","type":"depends-on","created_at":"2025-12-25T14:35:43.043106-05:00","created_by":"daemon"}]}
{"id":"taspr-gs1","title":"Automated rebase onto main","description":"## Goal\nAutomatically rebase stack onto latest main when behind.\n\n## Implementation\n\n```typescript\n// src/git/rebase.ts\n\ninterface RebaseResult {\n  success: boolean;\n  commitCount: number;\n  conflictFile?: string;\n}\n\nasync function rebaseOntoMain(): Promise\u003cRebaseResult\u003e {\n  const defaultBranch = await getDefaultBranch();\n  \n  // Count commits in stack\n  const mergeBase = await $\\`git merge-base HEAD origin/\\${defaultBranch}\\`.text();\n  const commitCount = parseInt(\n    await $\\`git rev-list \\${mergeBase.trim()}..HEAD --count\\`.text(), \n    10\n  );\n  \n  // Attempt rebase\n  const result = await $\\`git rebase origin/\\${defaultBranch}\\`.nothrow();\n  \n  if (result.exitCode === 0) {\n    return { success: true, commitCount };\n  }\n  \n  // Check for conflict\n  const status = await $\\`git status --porcelain\\`.text();\n  const conflictMatch = status.match(/^UU (.+)$/m);\n  \n  if (conflictMatch) {\n    return { \n      success: false, \n      commitCount, \n      conflictFile: conflictMatch[1] \n    };\n  }\n  \n  throw new Error('Rebase failed for unknown reason');\n}\n```\n\n### Preserving Trailers\nGit rebase preserves commit messages, so Taspr trailers survive automatically.\n\n## Integration with Sync\n```typescript\nasync function sync() {\n  if (await isStackBehindMain()) {\n    console.log('Rebasing onto origin/main...');\n    \n    const result = await rebaseOntoMain();\n    \n    if (result.success) {\n      console.log(\\`âœ“ Rebased \\${result.commitCount} commit(s)\\`);\n    } else {\n      // Handle conflict...\n    }\n  }\n}\n```\n\n## Testing\n- Clean rebase succeeds\n- Rebase with conflict fails gracefully\n- Trailers preserved through rebase\n\n## Files to Modify\n- src/git/rebase.ts\n\n## Acceptance Criteria\n- [ ] Rebases stack onto main\n- [ ] Reports commit count\n- [ ] Detects conflicts\n- [ ] Preserves Taspr trailers","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-25T14:36:27.786184-05:00","updated_at":"2025-12-25T14:36:27.786184-05:00","dependencies":[{"issue_id":"taspr-gs1","depends_on_id":"taspr-a64","type":"parent-child","created_at":"2025-12-25T14:36:31.944543-05:00","created_by":"daemon"},{"issue_id":"taspr-gs1","depends_on_id":"taspr-tiz","type":"blocks","created_at":"2025-12-25T14:36:32.225243-05:00","created_by":"daemon"},{"issue_id":"taspr-gs1","depends_on_id":"taspr-tiz","type":"depends-on","created_at":"2025-12-25T14:36:32.225243-05:00","created_by":"daemon"}]}
{"id":"taspr-h87","title":"Epic 1: Read Stack from Git","description":"## Goal\nParse a local git branch into a structured representation of commits and groups.\n\n## Background\n\ntaspr is a Bun-powered CLI tool for managing stacked PRs on GitHub. The fundamental model is:\n- **Each commit = one PR** by default\n- **Groups** bundle multiple contiguous commits into a single PR\n\nThis epic establishes the foundation: reading git history and understanding the stack structure before any GitHub integration.\n\n## Core Concepts\n\n### Stack\nA linear sequence of commits on a branch between HEAD and the merge-base with origin/main. Each commit potentially maps to a PR.\n\n### Group\nA contiguous range of commits that should be treated as a single PR. Defined by trailers:\n- `Taspr-Group-Start: \u003c8-hex-id\u003e` on the first commit\n- `Taspr-Group-Title: \u003ctitle\u003e` on the first commit (PR title)\n- `Taspr-Group-End: \u003csame-8-hex-id\u003e` on the last commit\n\n### Commit Identity\nEvery commit gets a `Taspr-Commit-Id` trailer (8 hex characters) that survives rebases. This is how taspr tracks commits across history rewrites.\n\n### PRUnit\nThe logical unit that maps to a PR:\n- **Single**: One commit = one PR. ID is the Taspr-Commit-Id, title is commit subject.\n- **Group**: Multiple commits = one PR. ID is the group-id, title is Taspr-Group-Title.\n\n## Deliverable\nRunning `taspr view` outputs a tree of commits showing which belong to groups and which are standalone. No GitHub integration yetâ€”purely local git data.\n\n## Key Data Structures\n\n```typescript\ninterface CommitInfo {\n  hash: string;\n  subject: string;\n  body: string;\n  trailers: Record\u003cstring, string\u003e;\n}\n\ninterface PRUnit {\n  type: 'single' | 'group';\n  id: string;           // Taspr-Commit-Id (single) or group-id (group)\n  title: string;        // Commit subject (single) or Taspr-Group-Title (group)\n  commitIds: string[];  // All Taspr-Commit-Id values in this unit\n  commits: string[];    // Current git hashes\n}\n\ntype StackParseResult = \n  | { ok: true; units: PRUnit[] }\n  | { ok: false; error: 'unclosed-group'; groupId: string; startCommit: string }\n  | { ok: false; error: 'overlapping-groups'; group1: GroupInfo; group2: GroupInfo; overlappingCommit: string }\n```\n\n## Technical Decisions\n- **CLI Framework**: Commander (good TypeScript support, works with Bun)\n- **Runtime**: Bun (fast TypeScript execution, native test runner)\n- **Git commands**: Bun Shell ($\\`\\`) for safe command execution\n\n## Testable Outcome\n`taspr view` shows commits, identifies groups, reports validation errors for malformed groups.\n\n## File Structure for This Epic\n```\nsrc/\nâ”œâ”€â”€ cli/\nâ”‚   â”œâ”€â”€ index.ts          # Entry point with Commander\nâ”‚   â””â”€â”€ commands/\nâ”‚       â””â”€â”€ view.ts       # View command implementation\nâ”œâ”€â”€ core/\nâ”‚   â””â”€â”€ stack.ts          # Stack parsing, PRUnit detection\nâ”œâ”€â”€ git/\nâ”‚   â”œâ”€â”€ commands.ts       # Git command wrapper\nâ”‚   â””â”€â”€ trailers.ts       # Trailer parsing\nâ””â”€â”€ types.ts              # TypeScript interfaces\ntests/\nâ”œâ”€â”€ helpers/\nâ”‚   â””â”€â”€ git-fixture.ts    # Test utilities for temp repos\nâ””â”€â”€ core/\n    â””â”€â”€ stack.test.ts     # Stack parsing tests\n```","status":"closed","priority":1,"issue_type":"epic","created_at":"2025-12-25T14:21:57.996735-05:00","updated_at":"2025-12-26T01:28:13.837115-05:00","closed_at":"2025-12-26T01:28:13.837115-05:00","close_reason":"All 6 child tasks completed: project scaffolding, git log parsing, trailer parsing, PRUnit detection, group validation, view command"}
{"id":"taspr-i41","title":"Branch name generation","description":"## Goal\nGenerate stable branch names for PRUnits following the pattern `\u003cprefix\u003e/\u003cusername\u003e/\u003cpr-id\u003e`.\n\n## Implementation\n\n```typescript\n// src/github/branches.ts\n\ninterface BranchNameConfig {\n  prefix: string;      // From git config or default \"taspr\"\n  username: string;    // From GitHub API\n}\n\nasync function getBranchNameConfig(): Promise\u003cBranchNameConfig\u003e {\n  // Get prefix from git config\n  const prefixResult = await $`git config --get taspr.branchPrefix`.nothrow();\n  const prefix = prefixResult.exitCode === 0 \n    ? prefixResult.stdout.toString().trim() \n    : 'taspr';\n  \n  // Get username from GitHub\n  const username = await $`gh api user --jq .login`.text();\n  \n  return { prefix, username: username.trim() };\n}\n\nfunction getBranchName(prId: string, config: BranchNameConfig): string {\n  return `${config.prefix}/${config.username}/${prId}`;\n}\n```\n\n### Examples\n```\ntaspr/msims/a1b2c3d4     # Default prefix, single commit\ntaspr/msims/f7e8d9c0     # Default prefix, group\njaspr/msims/a1b2c3d4     # Custom prefix via git config\n```\n\n### Configuration\n```bash\n# Set custom prefix\ngit config taspr.branchPrefix jaspr\n```\n\n## Caching\nUsername lookup is slow (network call). Cache within a sync operation:\n\n```typescript\nlet cachedConfig: BranchNameConfig | null = null;\n\nasync function getBranchNameConfig(): Promise\u003cBranchNameConfig\u003e {\n  if (cachedConfig) return cachedConfig;\n  // ... fetch\n  cachedConfig = config;\n  return config;\n}\n```\n\n## Testing\n- Default prefix generation\n- Custom prefix from git config\n- Valid branch name characters (pr-ids are hex, always safe)\n\n## Files to Create\n- src/github/branches.ts\n- src/git/config.ts (may already exist from Epic 1)\n\n## Acceptance Criteria\n- [ ] Generates branch names with correct pattern\n- [ ] Reads custom prefix from git config\n- [ ] Fetches username from GitHub API\n- [ ] Caches config within operation","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-25T14:26:47.651395-05:00","updated_at":"2025-12-25T14:26:47.651395-05:00","dependencies":[{"issue_id":"taspr-i41","depends_on_id":"taspr-osw","type":"parent-child","created_at":"2025-12-25T14:26:51.374607-05:00","created_by":"daemon"},{"issue_id":"taspr-i41","depends_on_id":"taspr-bvy","type":"blocks","created_at":"2025-12-25T14:27:05.963936-05:00","created_by":"daemon"},{"issue_id":"taspr-i41","depends_on_id":"taspr-bvy","type":"depends-on","created_at":"2025-12-25T14:27:05.963936-05:00","created_by":"daemon"}]}
{"id":"taspr-lr5","title":"Help text - comprehensive --help for all commands","description":"## Goal\nProvide comprehensive, well-formatted help text for all commands using Commander\\'s built-in help system.\n\n## Commands to Document\n\n### Main Command: `taspr`\n```\ntaspr - Stacked PR management for GitHub\n\nUsage: taspr \u003ccommand\u003e [options]\n\nCommands:\n  view      Show current stack structure and PR status\n  sync      Sync local stack with GitHub (push branches, create/update PRs)\n  land      Merge the bottom PR to main\n  group     Manage commit groups (create, edit, dissolve)\n\nOptions:\n  -h, --help     Show this help message\n  -v, --version  Show version number\n\nExamples:\n  taspr view              Show stack structure\n  taspr sync              Push and create PRs\n  taspr sync --open       Push, create PRs, and open in browser\n  taspr land              Merge bottom ready PR\n  taspr group create      Create a new commit group\n\nRun 'taspr \u003ccommand\u003e --help' for detailed help on each command.\n```\n\n### `taspr view`\n```\nShow the current stack structure and PR status\n\nUsage: taspr view [options]\n\nOptions:\n  --all          Show all stacks across branches (not just current)\n  --json         Output as JSON for scripting\n  -h, --help     Show this help message\n\nThe view command shows:\n  - Commits in the current stack (between HEAD and origin/main)\n  - Which commits are grouped into multi-commit PRs\n  - PR numbers and their current status (draft, open, merged)\n  - CI status, review status, and comment threads (if PRs exist)\n\nStatus indicators:\n  âœ“  Checks passing, approved\n  â—  Checks running or pending review\n  âœ—  Checks failing or changes requested\n  â—  Draft PR\n\nExamples:\n  taspr view         Current branch stack\n  taspr view --all   All branches with stacks\n```\n\n### `taspr sync`\n```\nSync local stack with GitHub\n\nUsage: taspr sync [options]\n\nOptions:\n  --open         Open created PRs in browser\n  --dry-run      Show what would be done without doing it\n  -h, --help     Show this help message\n\nThe sync command:\n  1. Adds Taspr-Commit-Id trailers to commits that don\\'t have them\n  2. Creates branches for each PR unit (single commit or group)\n  3. Creates PRs on GitHub with correct stacking (each based on PR below)\n  4. Updates existing PRs if commits have changed\n  5. Rebases on origin/main if behind (with conflict detection)\n\nBranch naming: \u003cprefix\u003e/\u003cusername\u003e/\u003ccommit-id\u003e\n  Example: taspr/alice/a1b2c3d4\n\nEach PR\\'s base branch is the branch of the PR below it in the stack,\nor main/master for the bottom PR.\n\nExamples:\n  taspr sync             Sync stack to GitHub\n  taspr sync --open      Sync and open new PRs in browser\n  taspr sync --dry-run   Preview sync operations\n```\n\n### `taspr land`\n```\nMerge PRs to main\n\nUsage: taspr land [options]\n\nOptions:\n  --all          Land all consecutive ready PRs (not just bottom)\n  -h, --help     Show this help message\n\nThe land command merges the bottom PR in your stack to main/master.\nGitHub automatically retargets child PRs to the new base after merge.\n\nA PR is \"ready\" when:\n  - CI checks are passing\n  - Has required approvals\n  - No unresolved review threads\n  - Not a draft\n\nExamples:\n  taspr land         Merge bottom ready PR\n  taspr land --all   Merge all consecutive ready PRs\n```\n\n### `taspr group`\n```\nManage commit groups (multiple commits as one PR)\n\nUsage: taspr group \u003csubcommand\u003e [options]\n\nSubcommands:\n  create    Create a new group from selected commits\n  edit      Edit an existing group (title or range)\n  dissolve  Remove a group, making commits individual PRs\n\nBy default, each commit becomes its own PR. Groups let you bundle\nmultiple related commits into a single PR while keeping them as\nseparate commits locally.\n\nGroups use git trailers:\n  - Taspr-Group-Start: \u003cgroup-id\u003e   (on first commit)\n  - Taspr-Group-End: \u003cgroup-id\u003e     (on last commit)\n  - Taspr-Group-Title: \u003ctitle\u003e      (on first commit)\n\nExamples:\n  taspr group create     Interactive commit selection\n  taspr group edit       Edit existing group\n  taspr group dissolve   Remove group, keep commits\n```\n\n## Implementation with Commander\n\n```typescript\nimport { program } from 'commander';\n\nprogram\n  .name('taspr')\n  .description('Stacked PR management for GitHub')\n  .version('0.1.0');\n\nprogram\n  .command('view')\n  .description('Show current stack structure and PR status')\n  .option('--all', 'Show all stacks across branches')\n  .option('--json', 'Output as JSON')\n  .addHelpText('after', `\nStatus indicators:\n  âœ“  Checks passing, approved\n  â—  Checks running or pending review\n  âœ—  Checks failing or changes requested\n  â—  Draft PR\n\nExamples:\n  taspr view         Current branch stack\n  taspr view --all   All branches with stacks\n`)\n  .action(viewCommand);\n```\n\n## Acceptance Criteria\n- [ ] Main taspr --help shows all commands\n- [ ] Each command has detailed --help\n- [ ] Examples included for common use cases\n- [ ] Status indicators explained in view help\n- [ ] Group trailer format documented in group help\n- [ ] Help text fits standard terminal width (80 chars)","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-25T14:49:58.136451-05:00","updated_at":"2025-12-25T14:49:58.136451-05:00","dependencies":[{"issue_id":"taspr-lr5","depends_on_id":"taspr-8iv","type":"parent-child","created_at":"2025-12-25T15:01:37.068615-05:00","created_by":"daemon"}]}
{"id":"taspr-m80","title":"Group dissolve command","description":"## Goal\nImplement `taspr group dissolve` to break a group back into individual commits.\n\n## Implementation\n\n```typescript\ngroupCommand\n  .command('dissolve')\n  .description('Dissolve a group back into individual commits')\n  .action(async () =\u003e {\n    const result = await parseStack();\n    \n    const groups = result.units.filter(u =\u003e u.type === 'group');\n    if (groups.length === 0) {\n      console.log('No groups in current stack');\n      return;\n    }\n    \n    const group = await select({\n      message: 'Select group to dissolve',\n      choices: groups.map(g =\u003e ({\n        name: \\`\\${g.title} (\\${g.commits.length} commits)\\`,\n        value: g,\n      })),\n    });\n    \n    // Warn about PR closure\n    const pr = await findPRForGroup(group);\n    if (pr) {\n      console.log(\\`âš  Warning: This will close PR #\\${pr.number}.\\`);\n      console.log('  Each commit will become its own PR when you sync --open.');\n    }\n    \n    const proceed = await confirm({ message: 'Proceed?' });\n    if (!proceed) return;\n    \n    // Remove group trailers\n    await removeGroupTrailers(group);\n    \n    console.log(\\`âœ“ Dissolved group \"\\${group.title}\"\\`);\n    console.log('  Run \\`taspr sync --open\\` to create individual PRs.');\n  });\n```\n\n### Removing Group Trailers\n```typescript\nasync function removeGroupTrailers(group: PRUnit): Promise\u003cvoid\u003e {\n  const first = group.commits[0];\n  const last = group.commits[group.commits.length - 1];\n  \n  // Remove Start and Title from first commit\n  await removeTrailersFromCommit(first, [\n    'Taspr-Group-Start',\n    'Taspr-Group-Title',\n  ]);\n  \n  // Remove End from last commit\n  if (last !== first) {\n    await removeTrailersFromCommit(last, ['Taspr-Group-End']);\n  }\n}\n```\n\n## Testing\n- Dissolve single group\n- Dissolve with PR warning\n- Cancel dissolve\n\n## Files to Modify\n- src/cli/commands/group.ts\n- src/core/group.ts\n\n## Acceptance Criteria\n- [ ] Lists existing groups\n- [ ] Warns about PR closure\n- [ ] Removes all group trailers\n- [ ] Confirms before changes","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-25T14:35:21.688433-05:00","updated_at":"2025-12-25T14:35:21.688433-05:00","dependencies":[{"issue_id":"taspr-m80","depends_on_id":"taspr-7mu","type":"parent-child","created_at":"2025-12-25T14:35:26.08024-05:00","created_by":"daemon"},{"issue_id":"taspr-m80","depends_on_id":"taspr-37l","type":"blocks","created_at":"2025-12-25T14:35:26.356701-05:00","created_by":"daemon"},{"issue_id":"taspr-m80","depends_on_id":"taspr-37l","type":"depends-on","created_at":"2025-12-25T14:35:26.356701-05:00","created_by":"daemon"}]}
{"id":"taspr-n47","title":"Group edit command","description":"## Goal\nImplement `taspr group edit` to modify an existing group's range or title.\n\n## Implementation\n\n```typescript\ngroupCommand\n  .command('edit')\n  .description(\"Edit an existing group's range or title\")\n  .action(async () =\u003e {\n    const result = await parseStack();\n    // ... validation\n    \n    // Find existing groups\n    const groups = result.units.filter(u =\u003e u.type === 'group');\n    if (groups.length === 0) {\n      console.log('No groups in current stack');\n      return;\n    }\n    \n    // Select group to edit\n    const group = await select({\n      message: 'Select group to edit',\n      choices: groups.map(g =\u003e ({\n        name: \\`\\${g.title} (\\${g.id}, \\${g.commits.length} commits)\\`,\n        value: g,\n      })),\n    });\n    \n    // What to change\n    const change = await select({\n      message: 'What would you like to change?',\n      choices: [\n        { name: 'Change title', value: 'title' },\n        { name: 'Change commit range', value: 'range' },\n        { name: 'Both', value: 'both' },\n      ],\n    });\n    \n    if (change === 'title' || change === 'both') {\n      const newTitle = await input({ \n        message: 'New title:', \n        default: group.title \n      });\n      await updateGroupTitle(group.id, newTitle);\n    }\n    \n    if (change === 'range' || change === 'both') {\n      const newRange = await selectCommits(result.units, group);\n      await moveGroupBoundaries(group.id, newRange);\n    }\n  });\n```\n\n### Moving Group Boundaries\n```typescript\nasync function moveGroupBoundaries(\n  groupId: string,\n  newRange: CommitInfo[]\n): Promise\u003cvoid\u003e {\n  // 1. Remove old Start/End trailers\n  // 2. Add new Start/End trailers\n  // 3. This requires rebase\n}\n```\n\n## Testing\n- Edit title only\n- Edit range only\n- Edit both\n- Validate new range doesn't overlap\n\n## Files to Modify\n- src/cli/commands/group.ts\n- src/core/group.ts\n\n## Acceptance Criteria\n- [ ] Lists existing groups\n- [ ] Allows editing title\n- [ ] Allows editing commit range\n- [ ] Moves trailers correctly\n- [ ] Validates no overlap with other groups","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-25T14:35:06.986405-05:00","updated_at":"2025-12-25T14:35:06.986405-05:00","dependencies":[{"issue_id":"taspr-n47","depends_on_id":"taspr-7mu","type":"parent-child","created_at":"2025-12-25T14:35:11.643065-05:00","created_by":"daemon"},{"issue_id":"taspr-n47","depends_on_id":"taspr-37l","type":"blocks","created_at":"2025-12-25T14:35:11.919004-05:00","created_by":"daemon"},{"issue_id":"taspr-n47","depends_on_id":"taspr-37l","type":"depends-on","created_at":"2025-12-25T14:35:11.919004-05:00","created_by":"daemon"}]}
{"id":"taspr-n48","title":"Branch creation and push","description":"## Goal\nPush commits to remote branches for each PRUnit.\n\n## Background\nEach PRUnit needs a branch on GitHub. The branch points to the HEAD commit of that PRUnit:\n- For singles: the single commit\n- For groups: the last commit in the group\n\n## Implementation\n\n```typescript\n// src/github/branches.ts\n\nasync function pushBranch(\n  commitHash: string, \n  branchName: string,\n  force: boolean = false\n): Promise\u003cvoid\u003e {\n  const forceFlag = force ? '--force' : '';\n  await $\\`git push ${forceFlag} origin ${commitHash}:refs/heads/${branchName}\\`;\n}\n\nasync function pushPRUnitBranch(unit: PRUnit, config: BranchNameConfig): Promise\u003cstring\u003e {\n  const branchName = getBranchName(unit.id, config);\n  const commitHash = unit.commits[unit.commits.length - 1]; // Last commit in unit\n  \n  await pushBranch(commitHash, branchName);\n  \n  return branchName;\n}\n```\n\n### Remote Branch Management\n```bash\n# Push specific commit to branch\ngit push origin abc123:refs/heads/taspr/msims/a1b2c3d4\n\n# Force push (needed after rebase)\ngit push --force origin abc123:refs/heads/taspr/msims/a1b2c3d4\n\n# Delete branch\ngit push origin --delete taspr/msims/a1b2c3d4\n```\n\n### Stack Ordering\nPush branches bottom-to-top so parent branches exist before creating child PRs:\n\n```typescript\nasync function pushAllBranches(units: PRUnit[]): Promise\u003cMap\u003cstring, string\u003e\u003e {\n  const config = await getBranchNameConfig();\n  const branches = new Map\u003cstring, string\u003e(); // prId -\u003e branchName\n  \n  // Push in order (oldest first = bottom of stack)\n  for (const unit of units) {\n    const branch = await pushPRUnitBranch(unit, config);\n    branches.set(unit.id, branch);\n  }\n  \n  return branches;\n}\n```\n\n## Edge Cases\n1. **Branch already exists**: Push still works (updates branch)\n2. **Permission denied**: Clear error about repo access\n3. **No remote**: Error about missing origin\n\n## Testing\n- Push creates branch on remote\n- Push updates existing branch\n- Force push works after rebase\n\n## Files to Modify\n- src/github/branches.ts\n\n## Acceptance Criteria\n- [ ] Pushes commits to correctly named branches\n- [ ] Updates existing branches\n- [ ] Force push supported for rebased commits\n- [ ] Clear errors on push failures","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-25T14:27:19.196006-05:00","updated_at":"2025-12-25T14:27:19.196006-05:00","dependencies":[{"issue_id":"taspr-n48","depends_on_id":"taspr-osw","type":"parent-child","created_at":"2025-12-25T14:27:22.733887-05:00","created_by":"daemon"},{"issue_id":"taspr-n48","depends_on_id":"taspr-i41","type":"blocks","created_at":"2025-12-25T14:27:23.014297-05:00","created_by":"daemon"},{"issue_id":"taspr-n48","depends_on_id":"taspr-i41","type":"depends-on","created_at":"2025-12-25T14:27:23.014297-05:00","created_by":"daemon"}]}
{"id":"taspr-nh3","title":"Sync command (ID injection only)","description":"## Goal\nImplement the `taspr sync` command for Epic 2 scope: adding IDs to commits.\n\n## Background\nAt this stage, sync does one thing: ensure all commits have Taspr-Commit-Id trailers.\n\nLater epics will extend sync to:\n- Push branches to GitHub (Epic 3)\n- Update PR branches (Epic 4)\n- Rebase onto main (Epic 8)\n\n## Command Implementation\n\n```typescript\n// src/cli/commands/sync.ts\nimport { Command } from 'commander';\n\nexport const syncCommand = new Command('sync')\n  .description('Sync stack state (add IDs, push PRs)')\n  .action(async () =\u003e {\n    // Check working tree\n    await requireCleanWorkingTree();\n    \n    // Parse current stack\n    const result = await parseStack();\n    if (!result.ok) {\n      console.error(formatValidationError(result));\n      process.exit(1);\n    }\n    \n    // Find commits without IDs\n    const needsId = result.units\n      .flatMap(u =\u003e u.commits)\n      .filter(c =\u003e !c.trailers['Taspr-Commit-Id']);\n    \n    if (needsId.length === 0) {\n      console.log('âœ“ All commits have IDs');\n      return;\n    }\n    \n    // Add IDs via rebase\n    console.log(`Adding IDs to ${needsId.length} commit(s)...`);\n    await injectMissingIds();\n    \n    console.log('âœ“ Added Taspr-Commit-Id to commits');\n  });\n```\n\n## Output\n\n### When IDs added\n```\n$ taspr sync\n\nAdding IDs to 3 commit(s)...\nâœ“ Added Taspr-Commit-Id to 3 commits:\n  â€¢ a1b2c3d4 Add user model\n  â€¢ b2c3d4e5 Add login endpoint\n  â€¢ c3d4e5f6 Add validation\n```\n\n### When already up to date\n```\n$ taspr sync\n\nâœ“ All commits have Taspr-Commit-Id\n```\n\n### When dirty\n```\n$ taspr sync\n\nâœ— Error: Cannot sync with uncommitted changes\n  ...\n```\n\n## Integration with View\nAfter sync, `taspr view` will show the new IDs:\n\n```\n$ taspr view\n\nStack: feature/auth (3 commits, 3 PRs)\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  â—‹ Add user model\n    â””â”€ a1b2c3d4\n...\n```\n\n## Testing\n1. Stack with no IDs â†’ adds IDs, reports count\n2. Stack with all IDs â†’ no-op, reports up to date\n3. Dirty working tree â†’ blocks with error\n4. Integration: sync then view shows IDs\n\n## Files to Create/Modify\n- src/cli/commands/sync.ts (create)\n- src/cli/index.ts (modify) - Register sync command\n\n## Acceptance Criteria\n- [ ] Adds IDs to commits without them\n- [ ] Reports how many commits were modified\n- [ ] No-op if all commits have IDs\n- [ ] Blocks on dirty working tree\n- [ ] Has integration tests","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-25T14:26:05.806801-05:00","updated_at":"2025-12-25T14:26:05.806801-05:00","dependencies":[{"issue_id":"taspr-nh3","depends_on_id":"taspr-7tr","type":"parent-child","created_at":"2025-12-25T14:26:09.683543-05:00","created_by":"daemon"},{"issue_id":"taspr-nh3","depends_on_id":"taspr-7h3","type":"blocks","created_at":"2025-12-25T14:26:09.957219-05:00","created_by":"daemon"},{"issue_id":"taspr-nh3","depends_on_id":"taspr-7h3","type":"depends-on","created_at":"2025-12-25T14:26:09.957219-05:00","created_by":"daemon"},{"issue_id":"taspr-nh3","depends_on_id":"taspr-4b6","type":"blocks","created_at":"2025-12-25T14:26:10.230538-05:00","created_by":"daemon"},{"issue_id":"taspr-nh3","depends_on_id":"taspr-4b6","type":"depends-on","created_at":"2025-12-25T14:26:10.230538-05:00","created_by":"daemon"}]}
{"id":"taspr-osw","title":"Epic 3: Push Stack to GitHub as PRs","description":"## Goal\nCreate GitHub PRs for each PRUnit, with correct stacking (each PR based on the one below it).\n\n## Background\n\n### Stacked PRs Model\nIn a stack of 3 PRUnits (A, B, C from bottom to top):\n- PR for A: base = main, head = branch for A\n- PR for B: base = branch for A, head = branch for B\n- PR for C: base = branch for B, head = branch for C\n\nThis creates a review chain where reviewers see only the changes in each PR, not accumulated changes.\n\n### Branch Naming Convention\n```\n\u003cprefix\u003e/\u003cusername\u003e/\u003cpr-id\u003e\n```\n\nExample: `taspr/msims/a1b2c3d4`\n\nWhere:\n- `prefix`: Configurable via `git config taspr.branchPrefix` (default: \"taspr\")\n- `username`: GitHub username from `gh api user`\n- `pr-id`: The PRUnit's id (commit-id for singles, group-id for groups)\n\nThis naming:\n- Is stable (ID survives rebases)\n- Identifies the owner\n- Groups all taspr branches with a common prefix\n\n### No PR Metadata Storage\nAt this stage, we don't store PR numbers anywhere. We discover them by:\n1. Looking up PRs by branch name\n2. GitHub API: `gh pr list --head \u003cbranch\u003e`\n\nThis keeps the design simpleâ€”git trailers remain the single source of truth.\n\n## Workflow\n\n1. User runs `taspr sync --open`\n2. For each PRUnit without an existing PR:\n   - Create/update branch: `git push origin \u003ccommit\u003e:refs/heads/\u003cbranch-name\u003e`\n   - Create PR: `gh pr create --head \u003cbranch\u003e --base \u003cparent-branch\u003e`\n3. Report created PRs\n\n## Deliverable\nRunning `taspr sync --open` creates branches and PRs on GitHub. Each PR's base is the branch of the PR below it (or main for the bottom).\n\n## Dependencies\n- Epic 2 must be complete (commits have IDs)\n\n## Key Technical Decisions\n- Use `gh` CLI for all GitHub operations (leverages user's existing auth)\n- Branch per PRUnit, named by pr-id\n- PRs discovered by branch lookup, not stored in trailers\n\n## Testable Outcome\nPRs appear on GitHub, correctly stacked, with titles from commit/group.","status":"open","priority":1,"issue_type":"epic","created_at":"2025-12-25T14:26:32.393192-05:00","updated_at":"2025-12-25T14:26:32.393192-05:00","dependencies":[{"issue_id":"taspr-osw","depends_on_id":"taspr-7tr","type":"blocks","created_at":"2025-12-25T14:26:36.107535-05:00","created_by":"daemon"},{"issue_id":"taspr-osw","depends_on_id":"taspr-7tr","type":"depends-on","created_at":"2025-12-25T14:26:36.107535-05:00","created_by":"daemon"}]}
{"id":"taspr-q9i","title":"Interactive commit selection UI","description":"## Goal\nCreate a checkbox-style UI for selecting commits.\n\n## Implementation Options\n\n### Option 1: @inquirer/prompts (recommended)\n```typescript\nimport { checkbox } from '@inquirer/prompts';\n\nconst selected = await checkbox({\n  message: 'Select commits to group',\n  choices: commits.map((c, i) =\u003e ({\n    name: \\`\\${c.hash.slice(0, 8)} \\${c.subject}\\`,\n    value: i,\n    checked: false,\n  })),\n});\n```\n\n### Option 2: @clack/prompts\n```typescript\nimport { multiselect } from '@clack/prompts';\n\nconst selected = await multiselect({\n  message: 'Select commits to group',\n  options: commits.map((c, i) =\u003e ({\n    label: \\`\\${c.hash.slice(0, 8)} \\${c.subject}\\`,\n    value: i,\n  })),\n});\n```\n\n### Option 3: Custom with keypress\nFor full control, handle stdin directly:\n```typescript\nimport { emitKeypressEvents } from 'readline';\n// Custom implementation\n```\n\n## Validation\n- Selection must be contiguous\n- At least 2 commits for a group\n- Cannot overlap existing groups\n\n```typescript\nfunction validateSelection(indices: number[], commits: CommitInfo[]): ValidationResult {\n  // Check contiguous\n  const sorted = [...indices].sort((a, b) =\u003e a - b);\n  for (let i = 1; i \u003c sorted.length; i++) {\n    if (sorted[i] !== sorted[i - 1] + 1) {\n      return { ok: false, error: 'Selection must be contiguous' };\n    }\n  }\n  \n  // Check not overlapping existing groups\n  // ...\n  \n  return { ok: true };\n}\n```\n\n## Testing\n- Mock stdin for automated tests\n- Manual testing for UX\n\n## Files to Create\n- src/cli/prompts.ts\n\n## Acceptance Criteria\n- [ ] Checkbox selection works\n- [ ] Validates contiguous selection\n- [ ] Shows existing group status\n- [ ] Works in terminal environments","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-25T14:33:58.215597-05:00","updated_at":"2025-12-25T14:33:58.215597-05:00","dependencies":[{"issue_id":"taspr-q9i","depends_on_id":"taspr-7mu","type":"parent-child","created_at":"2025-12-25T14:34:01.994481-05:00","created_by":"daemon"}]}
{"id":"taspr-tiz","title":"Behind detection (stack vs main)","description":"## Goal\nDetect when the stack is behind origin/main and needs rebasing.\n\n## Implementation\n\n```typescript\n// src/git/rebase.ts\n\nasync function isStackBehindMain(): Promise\u003cboolean\u003e {\n  const defaultBranch = await getDefaultBranch();\n  \n  // Fetch latest\n  await $\\`git fetch origin \\${defaultBranch}\\`;\n  \n  // Get merge-base\n  const mergeBase = await $\\`git merge-base HEAD origin/\\${defaultBranch}\\`.text();\n  \n  // Get current main tip\n  const mainTip = await $\\`git rev-parse origin/\\${defaultBranch}\\`.text();\n  \n  // If merge-base != main tip, we're behind\n  return mergeBase.trim() !== mainTip.trim();\n}\n\nasync function getCommitsBehind(): Promise\u003cnumber\u003e {\n  const defaultBranch = await getDefaultBranch();\n  const result = await $\\`git rev-list HEAD..origin/\\${defaultBranch} --count\\`.text();\n  return parseInt(result.trim(), 10);\n}\n```\n\n## Usage in Sync\n```typescript\nasync function sync() {\n  const behind = await isStackBehindMain();\n  \n  if (behind) {\n    const count = await getCommitsBehind();\n    console.log(\\`Stack is \\${count} commit(s) behind origin/main\\`);\n    \n    // Proceed with rebase...\n  }\n}\n```\n\n## Testing\n- Stack is up to date\n- Stack is behind by N commits\n- Stack has diverged (both ahead and behind)\n\n## Files to Create\n- src/git/rebase.ts\n\n## Acceptance Criteria\n- [ ] Detects when stack is behind\n- [ ] Reports number of commits behind\n- [ ] Fetches latest before checking","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-25T14:36:13.294509-05:00","updated_at":"2025-12-25T14:36:13.294509-05:00","dependencies":[{"issue_id":"taspr-tiz","depends_on_id":"taspr-a64","type":"parent-child","created_at":"2025-12-25T14:36:17.346843-05:00","created_by":"daemon"}]}
{"id":"taspr-v0c","title":"Epic 6: View PR Status from GitHub","description":"## Goal\nShow rich status information from GitHub in `taspr view`.\n\n## Background\nAfter the MVP (Epics 1-5), taspr can create and land PRs. This epic enhances feedback by showing:\n- CI check status\n- Review approval status\n- Comment thread resolution\n\nThis helps users know at a glance whether PRs are ready to land.\n\n## Enhanced View Output\n\n```\n$ taspr view\n\nStack: feature/auth (4 commits, 3 PRs)\n\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  âœ“ #142 Add user model\n    â””â”€ a1b2c3d4\n    https://github.com/org/repo/pull/142\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  â— #143 Authentication feature            ğŸ’¬ 3/5  â³ checks\n    â”œâ”€ b2c3d4e5 Add login endpoint\n    â”œâ”€ c3d4e5f6 Add password validation  \n    â””â”€ d4e5f6a7 Add 2FA support\n    https://github.com/org/repo/pull/143\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  â— #144 Add admin dashboard               ğŸ‘€ review\n    â””â”€ e5f6a7b8\n    https://github.com/org/repo/pull/144\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  â†“ origin/main\n```\n\n### Status Indicators\n- `âœ“` Merged\n- `â—` Open\n- `â—‹` No PR yet\n- `âœ—` Closed (not merged)\n- `!` Conflict or error state\n\n### Blocking Indicators\n- `ğŸ’¬ 3/5` â€” 3 of 5 comment threads resolved\n- `â³ checks` â€” CI checks still running\n- `âœ— checks` â€” CI checks failed\n- `ğŸ‘€ review` â€” Awaiting review approval\n\n## Deliverable\n`taspr view` shows check status, review status, and comment resolution for each PR.\n\n## Dependencies\n- Epic 4 must be complete (view command with basic PR info)\n\n## Priority\nP2 - Enhancement after MVP is complete.","status":"open","priority":2,"issue_type":"epic","created_at":"2025-12-25T14:32:11.233973-05:00","updated_at":"2025-12-25T14:32:11.233973-05:00","dependencies":[{"issue_id":"taspr-v0c","depends_on_id":"taspr-1ni","type":"blocks","created_at":"2025-12-25T14:32:14.956989-05:00","created_by":"daemon"},{"issue_id":"taspr-v0c","depends_on_id":"taspr-1ni","type":"depends-on","created_at":"2025-12-25T14:32:14.956989-05:00","created_by":"daemon"}]}
{"id":"taspr-y3n","title":"Install and configure oxlint","description":"Install oxlint (Oxc's fast JavaScript/TypeScript linter) and configure it for the project. This includes adding the package, creating configuration files, and setting up npm scripts.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-26T01:04:38.694306-05:00","updated_at":"2025-12-26T01:24:31.975995-05:00","closed_at":"2025-12-26T01:24:31.975995-05:00","close_reason":"Installed oxlint v1.35.0 and configured with default rules. Added lint script to package.json."}
{"id":"taspr-ybr","title":"Conflict recovery (continue after manual fix)","description":"## Goal\nHandle the workflow after user manually resolves conflicts.\n\n## Background\nWhen sync hits a conflict:\n1. User manually resolves\n2. User runs `git add` + `git rebase --continue`\n3. User runs `taspr sync` again\n\ntaspr needs to:\n- Detect if we're mid-rebase\n- Continue or restart as appropriate\n\n## Implementation\n\n```typescript\n// src/cli/commands/sync.ts\n\nasync function sync() {\n  // Check for ongoing rebase\n  const conflict = await getConflictInfo();\n  \n  if (conflict) {\n    console.log('Detected ongoing rebase conflict.');\n    console.log('');\n    console.log(formatConflictError(conflict));\n    process.exit(1);\n  }\n  \n  // Normal sync flow...\n}\n```\n\n### Post-Rebase Flow\nAfter user completes `git rebase --continue`:\n1. Stack is rebased onto new main\n2. All commit hashes have changed\n3. Running `taspr sync` should:\n   - Update all branches with new hashes\n   - Report which PRs were updated\n\n```typescript\nasync function sync() {\n  // ... conflict check ...\n  \n  // After successful rebase or no rebase needed\n  const statuses = await getAllSyncStatuses(units);\n  \n  const updated = [];\n  for (const [id, status] of statuses) {\n    if (status.needsUpdate) {\n      await forcePushBranch(status.localCommit, status.branchName);\n      updated.push(status.branchName);\n    }\n  }\n  \n  if (updated.length \u003e 0) {\n    console.log(\\`âœ“ Updated \\${updated.length} PR branch(es)\\`);\n  }\n}\n```\n\n## Testing\n- Sync detects mid-rebase state\n- Sync after rebase --continue updates branches\n- All PRs reflect new commits\n\n## Files to Modify\n- src/cli/commands/sync.ts\n- src/git/rebase.ts\n\n## Acceptance Criteria\n- [ ] Detects ongoing conflict and exits with instructions\n- [ ] After manual resolution, sync updates all branches\n- [ ] Clear feedback on what was updated","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-25T14:37:00.272928-05:00","updated_at":"2025-12-25T14:37:00.272928-05:00","dependencies":[{"issue_id":"taspr-ybr","depends_on_id":"taspr-a64","type":"parent-child","created_at":"2025-12-25T14:37:04.660065-05:00","created_by":"daemon"},{"issue_id":"taspr-ybr","depends_on_id":"taspr-d6b","type":"blocks","created_at":"2025-12-25T14:37:04.935834-05:00","created_by":"daemon"},{"issue_id":"taspr-ybr","depends_on_id":"taspr-d6b","type":"depends-on","created_at":"2025-12-25T14:37:04.935834-05:00","created_by":"daemon"}]}
{"id":"taspr-z8e","title":"README and documentation","description":"## Goal\nCreate comprehensive README and documentation for users to understand and use taspr.\n\n## README.md Structure\n\n```markdown\n# taspr\n\nStacked PR management for GitHub. Each commit becomes a PR, properly stacked.\n\n## What is taspr?\n\ntaspr manages \"stacked PRs\" - a workflow where you create a chain of dependent pull requests, each building on the one before it. This enables:\n\n- **Incremental reviews**: Small, focused PRs are easier to review\n- **Logical commits**: Keep your local history clean and meaningful\n- **Fast iteration**: Land PRs as they\\'re approved without waiting for the whole stack\n\n## Quick Start\n\n\\`\\`\\`bash\n# Install\ncurl -fsSL https://raw.githubusercontent.com/OWNER/taspr/main/install.sh | bash\n\n# In your repo, create some commits\ngit commit -m \"Add user model\"\ngit commit -m \"Add user API endpoints\"\ngit commit -m \"Add user UI components\"\n\n# View your stack\ntaspr view\n\n# Push to GitHub as stacked PRs\ntaspr sync\n\n# After bottom PR is approved, land it\ntaspr land\n\\`\\`\\`\n\n## Prerequisites\n\n- **git** - You probably have this\n- **gh** - GitHub CLI for authentication ([install](https://cli.github.com))\n\n## Installation\n\n### Quick Install (recommended)\n\\`\\`\\`bash\ncurl -fsSL https://raw.githubusercontent.com/OWNER/taspr/main/install.sh | bash\n\\`\\`\\`\n\n### Manual Download\nDownload the appropriate binary from [Releases](https://github.com/OWNER/taspr/releases):\n- macOS Intel: `taspr-darwin-x64`\n- macOS Apple Silicon: `taspr-darwin-arm64`\n- Linux x64: `taspr-linux-x64`\n- Linux ARM64: `taspr-linux-arm64`\n\n## How It Works\n\n### The Stack Model\n\nBy default, each commit in your branch becomes its own PR:\n\n\\`\\`\\`\nmain\n  â”‚\n  â”œâ”€â”€ Commit A  â†’  PR #1 (base: main)\n  â”‚     â”‚\n  â”‚     â””â”€â”€ Commit B  â†’  PR #2 (base: PR #1\\'s branch)\n  â”‚           â”‚\n  â”‚           â””â”€â”€ Commit C  â†’  PR #3 (base: PR #2\\'s branch)\n\\`\\`\\`\n\nWhen PR #1 merges, GitHub automatically retargets PR #2 to main.\n\n### Commit Tracking\n\ntaspr adds a trailer to each commit to track it across rebases:\n\\`\\`\\`\nfeat: add user authentication\n\nTaspr-Commit-Id: a1b2c3d4\n\\`\\`\\`\n\n### Groups (Optional)\n\nGroup multiple commits into a single PR:\n\\`\\`\\`bash\ntaspr group create\n# Select commits interactively\n\\`\\`\\`\n\n## Commands\n\n### `taspr view`\nShow your current stack structure and PR status.\n\n\\`\\`\\`bash\ntaspr view          # Current branch\ntaspr view --all    # All branches with stacks\n\\`\\`\\`\n\n### `taspr sync`\nPush your stack to GitHub, creating or updating PRs.\n\n\\`\\`\\`bash\ntaspr sync          # Push and create PRs\ntaspr sync --open   # Also open new PRs in browser\n\\`\\`\\`\n\n### `taspr land`\nMerge the bottom PR to main.\n\n\\`\\`\\`bash\ntaspr land          # Land bottom ready PR\ntaspr land --all    # Land all consecutive ready PRs\n\\`\\`\\`\n\n### `taspr group`\nManage commit groups.\n\n\\`\\`\\`bash\ntaspr group create    # Create a new group\ntaspr group edit      # Edit existing group\ntaspr group dissolve  # Remove a group\n\\`\\`\\`\n\n## Configuration\n\ntaspr uses git config for settings:\n\n\\`\\`\\`bash\n# Branch prefix (default: taspr)\ngit config taspr.prefix mystacks\n\n# Default base branch (default: detected from origin)\ngit config taspr.baseBranch main\n\\`\\`\\`\n\n## Tips\n\n### Amending Commits\nAfter amending a commit, run `taspr sync` to update the corresponding PR.\n\n### Rebasing\nWhen you rebase, commit IDs are preserved (they\\'re in trailers, not hashes). Just `taspr sync` after rebasing.\n\n### Inserting Commits\nAdd a commit anywhere in your stack, then `taspr sync`. New commits automatically get their own PRs.\n\n## Troubleshooting\n\n### \"gh not authenticated\"\nRun `gh auth login` to authenticate with GitHub.\n\n### \"Cannot sync - uncommitted changes\"\nCommit or stash your changes before running sync.\n\n### PRs showing wrong diff\nThis usually means your stack got out of sync. Run `taspr sync` to update all PR branches.\n\n## License\n\nMIT\n\\`\\`\\`\n\n## Additional Documentation\n\n### CLAUDE.md (for AI-assisted development)\n```markdown\n# taspr\n\nBun-powered stacked PR CLI for GitHub.\n\n## Commands\n\\`\\`\\`bash\nbun run dev          # Watch mode\nbun run build        # Build all platform binaries\nbun run test         # Run tests\nbun run typecheck    # Type validation\n\\`\\`\\`\n\n## Structure\n- src/cli/ - Command implementations\n- src/core/ - Business logic\n- src/git/ - Git operations\n- src/github/ - GitHub API via gh CLI\n- src/types.ts - TypeScript interfaces\n\n## Conventions\n- Strict TypeScript\n- Bun Shell ($\\`\\`) for git commands\n- Tests mirror src/ structure\n- gh CLI for all GitHub operations\n\\`\\`\\`\n\n## Acceptance Criteria\n- [ ] README explains what taspr is and why to use it\n- [ ] Quick start gets users going in \u003c2 minutes\n- [ ] All commands documented with examples\n- [ ] Troubleshooting covers common issues\n- [ ] Installation instructions for all platforms\n- [ ] CLAUDE.md helps AI-assisted development\n- [ ] Configuration options documented","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-25T15:01:25.505428-05:00","updated_at":"2025-12-25T15:01:25.505428-05:00","dependencies":[{"issue_id":"taspr-z8e","depends_on_id":"taspr-8iv","type":"parent-child","created_at":"2025-12-25T15:01:37.920096-05:00","created_by":"daemon"}]}
{"id":"taspr-zqh","title":"Git config options","description":"## Goal\nSupport configuration via git config for branch prefix and default branch.\n\n## Configuration Options\n\n### taspr.branchPrefix\nCustom prefix for branch names (default: \"taspr\"):\n```bash\ngit config taspr.branchPrefix jaspr\n# Produces: jaspr/msims/a1b2c3d4 instead of taspr/msims/a1b2c3d4\n```\n\n### taspr.defaultBranch\nDefault branch to stack on (default: auto-detect from origin):\n```bash\ngit config taspr.defaultBranch main\n```\n\n## Implementation\n\n```typescript\n// src/git/config.ts\n\ninterface TasprConfig {\n  branchPrefix: string;\n  defaultBranch: string;\n}\n\nasync function getTasprConfig(): Promise\u003cTasprConfig\u003e {\n  const [prefixResult, defaultResult] = await Promise.all([\n    $\\`git config --get taspr.branchPrefix\\`.nothrow(),\n    $\\`git config --get taspr.defaultBranch\\`.nothrow(),\n  ]);\n  \n  const prefix = prefixResult.exitCode === 0 \n    ? prefixResult.stdout.toString().trim() \n    : 'taspr';\n    \n  let defaultBranch: string;\n  if (defaultResult.exitCode === 0) {\n    defaultBranch = defaultResult.stdout.toString().trim();\n  } else {\n    // Auto-detect from origin\n    defaultBranch = await detectDefaultBranch();\n  }\n  \n  return { branchPrefix: prefix, defaultBranch };\n}\n\nasync function detectDefaultBranch(): Promise\u003cstring\u003e {\n  // Method 1: Check remote HEAD\n  const result = await $\\`git symbolic-ref refs/remotes/origin/HEAD\\`.nothrow();\n  if (result.exitCode === 0) {\n    const ref = result.stdout.toString().trim();\n    return ref.replace('refs/remotes/origin/', '');\n  }\n  \n  // Method 2: Common defaults\n  for (const branch of ['main', 'master']) {\n    const exists = await $\\`git rev-parse --verify origin/\\${branch}\\`.nothrow();\n    if (exists.exitCode === 0) return branch;\n  }\n  \n  throw new Error('Could not detect default branch. Set it with: git config taspr.defaultBranch \u003cbranch\u003e');\n}\n```\n\n### Usage\n```typescript\nconst config = await getTasprConfig();\nconst branchName = \\`\\${config.branchPrefix}/\\${username}/\\${prId}\\`;\nconst baseBranch = config.defaultBranch;\n```\n\n## Testing\n- Default prefix â†’ \"taspr\"\n- Custom prefix â†’ uses custom value\n- Default branch auto-detection\n- Custom default branch\n\n## Files to Create/Modify\n- src/git/config.ts (may already exist)\n\n## Acceptance Criteria\n- [ ] Reads branchPrefix from git config\n- [ ] Falls back to \"taspr\" if not set\n- [ ] Reads defaultBranch from git config\n- [ ] Auto-detects default branch from origin if not set\n- [ ] Clear error if can't detect default branch","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-25T14:30:16.504099-05:00","updated_at":"2025-12-25T14:30:16.504099-05:00","dependencies":[{"issue_id":"taspr-zqh","depends_on_id":"taspr-1ni","type":"parent-child","created_at":"2025-12-25T14:30:20.288564-05:00","created_by":"daemon"}]}

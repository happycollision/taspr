{"id":"spry-00m","title":"Refactor main sync loop to use batch lookup","description":"Refactor the main sync loop in sync.ts to use batch PR lookup.\n\n## Before (sequential, lines 276-326)\n```typescript\nfor (const unit of activeUnits) {\n  const existingPR = await findPRByBranch(headBranch);\n}\n```\n\n## After (batch)\n```typescript\nconst prMap = existingPrMap ?? await findPRsByBranches(branchNames);\nfor (const unit of activeUnits) {\n  const existingPR = prMap.get(getBranchName(unit.id, branchConfig)) ?? null;\n}\n```\n\n## Files\n- src/cli/commands/sync.ts (lines 276-326)","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-09T00:03:04.64729-05:00","updated_at":"2026-01-10T00:36:02.180409-05:00","closed_at":"2026-01-09T00:09:02.118448-05:00","close_reason":"Closed","dependencies":[{"issue_id":"spry-00m","depends_on_id":"spry-380","type":"blocks","created_at":"2026-01-09T00:03:09.8342-05:00","created_by":"don.denton"}]}
{"id":"spry-01g","title":"Group inherits PR identity when commits with existing PRs are grouped","description":"When grouping commits where one or more already have open PRs, the group should inherit the PR identity.\n\n## Behavior\n\n1. **Single PR exists**: Ask user if they want to:\n   - Adopt the existing PR (group inherits that ID)\n   - Close the PR and create new one for the group\n2. **Multiple PRs exist**: User must pick which one to keep, others get closed\n3. The group takes on the chosen PR's ID to preserve branch/PR identity\n\n## ID Management\n\n- IDs are internal state management, not user-facing identifiers\n- When a commit joins a group with an existing PR, it adopts that group's ID\n- When a commit leaves a group that inherited its ID, it gets a NEW ID\n- This is intentional \"magic\" - users shouldn't need to think about IDs\n\n## Implementation Notes\n\n- Add interactive prompt when grouping detects existing PRs\n- Rewrite commit trailers during group operation\n- Handle edge case: commit removed from group needs new ID","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-03T00:20:12.200488-05:00","updated_at":"2026-01-10T00:36:02.204929-05:00","closed_at":"2026-01-04T15:32:33.07197-05:00","close_reason":"Closed","dependencies":[{"issue_id":"spry-01g","depends_on_id":"spry-2hk","type":"blocks","created_at":"2026-01-03T00:20:19.47021-05:00","created_by":"dondenton"}]}
{"id":"spry-01v","title":"Refactor cleanupMergedPRs to use batch lookup","description":"Refactor the `cleanupMergedPRs` function in sync.ts to use batch PR lookup.\n\n## Before (sequential)\n```typescript\nfor (const unit of units) {\n  const pr = await findPRByBranch(branchName, { includeAll: true });\n}\n```\n\n## After (batch)\n```typescript\nconst branchNames = units.map(u =\u003e getBranchName(u.id, branchConfig));\nconst prMap = await findPRsByBranches(branchNames, { includeAll: true });\nfor (const unit of units) {\n  const pr = prMap.get(getBranchName(unit.id, branchConfig)) ?? null;\n}\n```\n\n## Files\n- src/cli/commands/sync.ts (lines 65-75)","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-09T00:03:04.433581-05:00","updated_at":"2026-01-10T00:36:02.180861-05:00","closed_at":"2026-01-09T00:09:02.110002-05:00","close_reason":"Closed","dependencies":[{"issue_id":"spry-01v","depends_on_id":"spry-380","type":"blocks","created_at":"2026-01-09T00:03:09.713666-05:00","created_by":"don.denton"}]}
{"id":"spry-06a","title":"Optional: Machine user for PR review integration tests","description":"## Goal\nEnable integration tests for PR approval/changes_requested scenarios that are currently skipped due to GitHub's self-review restriction.\n\n## Context\nGitHub doesn't allow users to approve or request changes on their own PRs. The `getPRReviewStatus` function is already tested via:\n- Unit tests for `determineReviewDecision` (all cases covered)\n- Integration tests for `none` and `review_required` states\n\nThe skipped tests (`approved`, `changes_requested`) require a second GitHub account to submit reviews.\n\n## Why This Is Optional\n- Unit tests already cover the logic\n- GitHub's branch protection will catch misconfigured repos in production\n- This is \"belt and suspenders\" testing\n\n## Setup Steps (Manual - ~10 min)\n1. Create a new GitHub account (e.g., `taspr-test-reviewer`)\n2. Add it as a collaborator to `happycollision/taspr-check` with write access\n3. Generate a PAT (classic) with `repo` scope from that account\n4. Store as `GITHUB_REVIEWER_TOKEN` env var (local) or CI secret\n\n## Code Changes (After Setup)\n1. Update `tests/integration/pr-status.test.ts`:\n   - Add helper to get reviewer token from env\n   - Use `gh api repos/{owner}/{repo}/pulls/{pr}/reviews` with `GH_TOKEN` override\n   - Unskip `approved` and `changes_requested` tests\n   - Skip gracefully if `GITHUB_REVIEWER_TOKEN` not set\n\n## Files to Modify\n- tests/integration/pr-status.test.ts\n\n## Acceptance Criteria\n- [ ] Tests run when GITHUB_REVIEWER_TOKEN is set\n- [ ] Tests skip gracefully when token is not set\n- [ ] Approved and changes_requested states are verified","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-31T13:22:35.957968-05:00","updated_at":"2026-01-10T00:36:02.203412-05:00"}
{"id":"spry-07a","title":"Update git configuration module","description":"Update src/git/config.ts:\n- Config keys: taspr.branchPrefix → spry.branchPrefix\n- Config keys: taspr.defaultBranch → spry.defaultBranch\n- Config keys: taspr.tempCommitPrefixes → spry.tempCommitPrefixes\n- Default branch prefix value: \"taspr\" → \"spry\"","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-09T11:55:48.700011-05:00","updated_at":"2026-01-10T00:36:02.191761-05:00","closed_at":"2026-01-09T13:37:07.951952-05:00","close_reason":"Closed"}
{"id":"spry-08w","title":"Automated rebase onto main","description":"## Goal\nAutomatically rebase stack onto latest main when behind.\n\n## Implementation\n\n```typescript\n// src/git/rebase.ts\n\ninterface RebaseResult {\n  success: boolean;\n  commitCount: number;\n  conflictFile?: string;\n}\n\nasync function rebaseOntoMain(): Promise\u003cRebaseResult\u003e {\n  const defaultBranch = await getDefaultBranch();\n  \n  // Count commits in stack\n  const mergeBase = await $\\`git merge-base HEAD origin/\\${defaultBranch}\\`.text();\n  const commitCount = parseInt(\n    await $\\`git rev-list \\${mergeBase.trim()}..HEAD --count\\`.text(), \n    10\n  );\n  \n  // Attempt rebase\n  const result = await $\\`git rebase origin/\\${defaultBranch}\\`.nothrow();\n  \n  if (result.exitCode === 0) {\n    return { success: true, commitCount };\n  }\n  \n  // Check for conflict\n  const status = await $\\`git status --porcelain\\`.text();\n  const conflictMatch = status.match(/^UU (.+)$/m);\n  \n  if (conflictMatch) {\n    return { \n      success: false, \n      commitCount, \n      conflictFile: conflictMatch[1] \n    };\n  }\n  \n  throw new Error('Rebase failed for unknown reason');\n}\n```\n\n### Preserving Trailers\nGit rebase preserves commit messages, so Taspr trailers survive automatically.\n\n## Integration with Sync\n```typescript\nasync function sync() {\n  if (await isStackBehindMain()) {\n    console.log('Rebasing onto origin/main...');\n    \n    const result = await rebaseOntoMain();\n    \n    if (result.success) {\n      console.log(\\`✓ Rebased \\${result.commitCount} commit(s)\\`);\n    } else {\n      // Handle conflict...\n    }\n  }\n}\n```\n\n## Testing\n- Clean rebase succeeds\n- Rebase with conflict fails gracefully\n- Trailers preserved through rebase\n\n## Files to Modify\n- src/git/rebase.ts\n\n## Acceptance Criteria\n- [ ] Rebases stack onto main\n- [ ] Reports commit count\n- [ ] Detects conflicts\n- [ ] Preserves Taspr trailers","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-25T14:36:27.786184-05:00","updated_at":"2026-01-10T00:36:02.162199-05:00","closed_at":"2025-12-31T14:05:40.698458-05:00","close_reason":"Added rebaseOntoMain() function with conflict detection. All 4 new tests passing, trailers preserved through rebase.","dependencies":[{"issue_id":"spry-08w","depends_on_id":"spry-efn","type":"parent-child","created_at":"2025-12-25T14:36:31.944543-05:00","created_by":"daemon"},{"issue_id":"spry-08w","depends_on_id":"spry-e17","type":"blocks","created_at":"2025-12-25T14:36:32.225243-05:00","created_by":"daemon"},{"issue_id":"spry-08w","depends_on_id":"spry-e17","type":"depends-on","created_at":"2025-12-25T14:36:32.225243-05:00","created_by":"daemon"}]}
{"id":"spry-0b9","title":"Merged PR detection and cleanup","description":"## Goal\nIdentify merged PRs and clean them up from local tracking.\n\n## Background\nAfter a PR merges:\n1. The PR is in \"merged\" state on GitHub\n2. The branch can be deleted\n3. Local tracking should stop including it in the stack\n\n## Implementation\n\n### Detecting Merged PRs\n```typescript\nasync function getMergedPRUnits(\n  units: PRUnit[],\n  config: BranchNameConfig\n): Promise\u003cPRUnit[]\u003e {\n  const merged: PRUnit[] = [];\n  \n  for (const unit of units) {\n    const branch = getBranchName(unit.id, config);\n    const pr = await findPRByBranch(branch);\n    \n    if (pr?.state === 'merged') {\n      merged.push(unit);\n    }\n  }\n  \n  return merged;\n}\n```\n\n### Cleanup Actions\n1. **Delete remote branch** (optional):\n   ```bash\n   git push origin --delete taspr/msims/a1b2c3d4\n   ```\n\n2. **Report merged PRs**:\n   ```\n   ✓ PR #142 merged to main\n   ✓ Deleted branch taspr/msims/a1b2c3d4\n   ```\n\n### During Sync\n```typescript\nasync function cleanupMergedPRs(units: PRUnit[]): Promise\u003cPRUnit[]\u003e {\n  const merged = await getMergedPRUnits(units);\n  \n  if (merged.length \u003e 0) {\n    console.log(\\`✓ Removed \\${merged.length} merged PR(s) from tracking\\`);\n    \n    // Optionally delete remote branches\n    for (const unit of merged) {\n      await deleteRemoteBranch(getBranchName(unit.id));\n    }\n  }\n  \n  // Return remaining (non-merged) units\n  return units.filter(u =\u003e !merged.includes(u));\n}\n```\n\n## Integration with View\nAfter landing, `taspr view` shows:\n- Merged PRs with ✓ status\n- Or excludes merged PRs entirely (after sync)\n\n## Testing\n- Detect merged state\n- Delete remote branch\n- Remaining PRs still tracked\n\n## Files to Create/Modify\n- src/core/sync.ts\n- src/github/branches.ts\n\n## Acceptance Criteria\n- [ ] Detects merged PRs via GitHub API\n- [ ] Optionally deletes remote branches\n- [ ] Reports cleanup in sync output\n- [ ] Remaining stack is correctly updated","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T14:31:11.906558-05:00","updated_at":"2026-01-10T00:36:02.163759-05:00","closed_at":"2025-12-31T00:19:36.836181-05:00","close_reason":"Implemented merged PR detection and cleanup in sync command. During sync, detects merged PRs via GitHub API, deletes their remote branches, and reports the cleanup.","dependencies":[{"issue_id":"spry-0b9","depends_on_id":"spry-oef","type":"parent-child","created_at":"2025-12-25T14:31:15.902133-05:00","created_by":"daemon"},{"issue_id":"spry-0b9","depends_on_id":"spry-4zl","type":"blocks","created_at":"2025-12-25T14:31:16.180399-05:00","created_by":"daemon"},{"issue_id":"spry-0b9","depends_on_id":"spry-4zl","type":"depends-on","created_at":"2025-12-25T14:31:16.180399-05:00","created_by":"daemon"}]}
{"id":"spry-0bl","title":"Conflict prediction for group TUI","description":"## Goal\nImplement precise conflict prediction for the group TUI, warning users when reordering commits would cause merge conflicts.\n\n## Context\nThis is part of Epic 7: Group Management. When users reorder commits in the TUI, we need to predict whether the reorder would cause a conflict BEFORE they commit to it. This uses a hybrid approach: fast file-level check first, then precise merge simulation if files overlap.\n\n## UX Design\nWhen moving a commit past another that would conflict:\n\n```\n» A e5f6a7b8  Add login endpoint       ← MOVING\n  A c9d0e1f2  Fix login bug            ✗ CONFLICT (auth.ts:15-22)\n\n─────────────────────────────────────────\n✗ Moving past \"Fix login bug\" will conflict in auth.ts (lines 15-22)\n```\n\nStatus indicators:\n- ✓ clean - no file overlap, safe to move\n- ⚠️ warning - file overlap but merge would succeed (same file, different lines)\n- ✗ conflict - actual merge conflict detected\n\n## Implementation\n\n### Hybrid Approach\n```typescript\ninterface ConflictResult {\n  status: 'clean' | 'warning' | 'conflict';\n  files?: string[];           // Overlapping files\n  conflictLines?: string[];   // e.g., \"auth.ts:15-22\"\n}\n```\n\n### Step 1: Fast File Overlap Check\n```typescript\n// Get files modified by a commit\nasync function getCommitFiles(hash: string): Promise\u003cstring[]\u003e {\n  const result = await $`git diff-tree --no-commit-id --name-only -r ${hash}`.text();\n  return result.trim().split('\\n').filter(Boolean);\n}\n\n// Check if two commits modify overlapping files\nasync function checkFileOverlap(commitA: string, commitB: string): Promise\u003cstring[]\u003e {\n  const filesA = await getCommitFiles(commitA);\n  const filesB = await getCommitFiles(commitB);\n  const setA = new Set(filesA);\n  return filesB.filter(f =\u003e setA.has(f));\n}\n```\n\n### Step 2: Precise Merge Simulation (only if files overlap)\n```typescript\n// Use git merge-tree to simulate actual merge\nasync function simulateMerge(\n  base: string, \n  commitA: string, \n  commitB: string\n): Promise\u003cConflictResult\u003e {\n  // git merge-tree simulates merge without touching working tree\n  // Exit code 0 with CONFLICT in output = conflicts exist\n  const result = await $`git merge-tree ${base} ${commitA} ${commitB}`\n    .nothrow()\n    .text();\n  \n  if (result.includes('CONFLICT')) {\n    // Parse conflict details from output\n    const conflicts = parseConflictOutput(result);\n    return { \n      status: 'conflict', \n      files: conflicts.files,\n      conflictLines: conflicts.lines \n    };\n  }\n  \n  return { status: 'warning', files: overlappingFiles };\n}\n```\n\n### Caching\nCache file lists during TUI session to avoid repeated git calls:\n```typescript\nconst fileCache = new Map\u003cstring, string[]\u003e();\n\nasync function getCommitFilesCached(hash: string): Promise\u003cstring[]\u003e {\n  if (!fileCache.has(hash)) {\n    fileCache.set(hash, await getCommitFiles(hash));\n  }\n  return fileCache.get(hash)!;\n}\n```\n\n## Git Commands Used\n- `git diff-tree --no-commit-id --name-only -r \u003ccommit\u003e` - get files modified (fast)\n- `git merge-tree \u003cbase\u003e \u003ccommit1\u003e \u003ccommit2\u003e` - simulate merge (precise, non-destructive)\n\n## Files to Create\n- src/git/conflict-predict.ts\n\n## Testing\n- Unit tests for file overlap detection\n- Unit tests for merge simulation parsing\n- Integration tests with actual conflicting commits\n- Test caching behavior\n\n## Acceptance Criteria\n- [ ] `getCommitFiles()` returns list of files modified by commit\n- [ ] `checkFileOverlap()` detects overlapping files between commits\n- [ ] `simulateMerge()` uses git merge-tree to detect actual conflicts\n- [ ] Results are cached during TUI session\n- [ ] Conflict lines are extracted from merge-tree output\n- [ ] Performance is acceptable (\u003c 100ms for typical checks)","notes":"## Testing Workflow\nAfter completing implementation:\n1. Run `bun run build` to build the CLI\n2. Run `bun test --no-coverage` to verify all tests pass\n3. Tell the user to run `bun run scenario` and select one of these scenarios for manual testing:\n   - **conflictScenario** - Setup that will conflict on rebase (best for testing conflict prediction)\n   - **multiCommitStack** - 3 commits for testing file overlap detection\n\n## Scenario Usage\nThe `bun run scenario` command spawns a shell in a temp git repo with `taspr` in PATH. Use this to manually verify conflict prediction works correctly. After testing, type `exit` to clean up.\n\n## New Scenarios Needed\nConsider adding to `src/scenario/definitions.ts`:\n- **conflictingReorder** - A scenario where two commits modify the same file in ways that would conflict if reordered","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-01T22:47:55.226468-05:00","updated_at":"2026-01-10T00:36:02.195038-05:00","closed_at":"2026-01-02T10:24:30.585297-05:00","close_reason":"Closed","dependencies":[{"issue_id":"spry-0bl","depends_on_id":"spry-r22","type":"parent-child","created_at":"2026-01-01T22:48:51.646554-05:00","created_by":"daemon"}]}
{"id":"spry-0ezd","title":"Testing and documentation for merge commit feature","description":"Add comprehensive test coverage and documentation for the merge commit feature.\n\n## Context\n\nWith all merge commit functionality implemented, we need comprehensive testing and documentation to ensure reliability and help users understand the feature.\n\n## Changes Required\n\n### 1. Unit Tests\n\n**Data Model Tests (src/git/commands.test.ts, src/git/trailers.test.ts):**\n- `getStackCommits()` with merge commits returns parent arrays\n- `parseTrailers()` handles multi-value `Spry-Merge-Parents`\n- `addTrailers()` with array values adds multiple trailers\n- Trailer roundtrip: add → parse → verify array preserved\n\n**Rebase Operation Tests (src/git/plumbing.test.ts, src/git/rebase.test.ts):**\n- `rewriteCommitChain()` preserves merge structure\n- `rebasePlumbing()` maps all merge parents correctly\n- `injectMissingIds()` adds `Spry-Merge-Parents` to merges\n- Three-way merge vs merge commit detection\n- Parent mapping through rebase chain\n\n**Validation Tests (src/git/merge-validation.test.ts):**\n- Detects unreachable merge parent IDs\n- Validates parent count matches trailers\n- Pre/post operation validation hooks work\n\n**TUI Tests (src/tui/state.test.ts):**\n- `indentCommit()` creates merge placeholder and auto-assigns group\n- `outdentCommit()` removes merge when last indented commit outdented\n- Merge placeholder filtering before git operations\n- Moving commits with indent levels preserved\n- Cannot swap with merge commits\n\n**Recovery Tests (src/git/merge-recovery.test.ts):**\n- `detectFlattenedMerges()` finds commits with trailers but single parent\n- `recoverMergeCommits()` reconstructs merge with correct parents\n- Recovery validation catches missing parent IDs\n- Tree consistency preserved after recovery\n\n**PR Body Tests (src/github/pr-body.test.ts):**\n- `generateMergeCommitWarning()` formats warning correctly\n- PR body includes warning when merge commits present\n- Multiple merge commits all listed\n- Warning updates on PR sync\n\n### 2. Integration Tests\n\n**End-to-End Workflows (tests/integration/):**\n\nTest file: `tests/integration/merge-commits.test.ts`\n\n```typescript\ndescribe(\"merge commits in groups\", () =\u003e {\n  test(\"indent commits creates merge in git\", async () =\u003e {\n    // Setup: Create stack with commits\n    // Run group editor, indent commits 2-3\n    // Verify: Real merge commit created in git\n    // Verify: Merge has 2 parents\n    // Verify: Merge has Spry-Merge-Parents trailer\n  });\n\n  test(\"rebase preserves merge structure\", async () =\u003e {\n    // Setup: Create merge commit\n    // Run sp sync (triggers rebase)\n    // Verify: Merge still has 2 parents after rebase\n    // Verify: Parents mapped correctly\n  });\n\n  test(\"multiple branch-merge sections in one PR\", async () =\u003e {\n    // Setup: Create group with 2 indented sections\n    // Verify: 2 merge commits created\n    // Verify: All in same group\n    // Verify: PR disclaimer lists both merges\n  });\n\n  test(\"recover flattened merge\", async () =\u003e {\n    // Setup: Create merge, flatten with git rebase\n    // Run sp group --recover\n    // Verify: Merge reconstructed with 2 parents\n    // Verify: Tree unchanged\n  });\n\n  test(\"move commits into/out of branch\", async () =\u003e {\n    // Setup: Create branch-merge group\n    // Move commit past merge (outdent effect)\n    // Verify: Commit no longer in branch\n    // Move commit back\n    // Verify: Re-added to branch\n  });\n});\n```\n\n### 3. Documentation Updates\n\n**CHANGELOG.md:**\n\n```markdown\n## [Unreleased]\n\n### Added\n\n- **Merge commits in grouped PRs:** Create true branch-and-merge structures within PR groups\n  - Use ←→ arrows in move mode to indent/outdent commits\n  - Automatic merge commit generation when indenting\n  - Multiple branch-merge sections per PR group supported\n  - All rebase operations preserve merge commit structure\n  - PR disclaimers list merge commits that can be ignored during review\n  - `sp group --recover` command to rebuild flattened merge commits\n\n### Changed\n\n- `CommitInfo` type now includes `parents: string[]` field\n- Git trailers support multi-value format for `Spry-Merge-Parents`\n- Group editor move mode uses ←→ for indent/outdent (previously unused)\n```\n\n**README.md (or docs/):**\n\nAdd section explaining merge commit feature:\n\n```markdown\n## Branch-and-Merge Groups\n\nSpry supports creating branches within PR groups that merge back to the main line. This allows fast-forward merging while preserving feature branch structure.\n\n### Creating Merge Commits\n\n1. Run `sp group` to open the group editor\n2. Press `Space` to enter move mode\n3. Use `→` (right arrow) to indent commits - this creates a branch\n4. Multiple indented commits form a single branch\n5. A merge commit is automatically created to rejoin the main line\n6. Press `Enter` to apply\n\n### Visual Structure\n\n```\n  A commit 1\n    A commit 2         (indented - branches off)\n    A commit 3         (indented)\n  A [merge] Merge      (rejoins main line)\n  A commit 4\n```\n\n### Recovery\n\nIf an external rebase flattens your merge commits, recover them:\n\n```bash\nsp group --recover\n```\n\nThis detects flattened merges using commit trailers and reconstructs them.\n```\n\n**Code Comments:**\n\nAdd detailed comments in critical functions:\n- `rebasePlumbing()`: Explain merge vs regular commit handling\n- `injectMissingIds()`: Explain `Spry-Merge-Parents` format\n- `indentCommit()`: Explain placeholder creation logic\n- `recoverMergeCommits()`: Explain detection and reconstruction\n\n### 4. Manual Testing Checklist\n\nCreate manual test plan:\n\n```markdown\n## Manual Test Plan: Merge Commits\n\n- [ ] Indent single commit, verify merge created\n- [ ] Indent multiple commits, verify single merge\n- [ ] Outdent commit, verify merge removed\n- [ ] Multiple branch-merge sections in one group\n- [ ] Move commit into indented section\n- [ ] Move commit out of indented section\n- [ ] Create PR with merge commits, verify disclaimer\n- [ ] Sync PR with merge commits, verify preservation\n- [ ] Rebase with merge commits, verify structure preserved\n- [ ] External rebase flattens merge, recover with --recover\n- [ ] Edit merge commit message after creation\n- [ ] Visual rendering in TUI (indents, merge indicator)\n- [ ] Help text updates in move mode\n```\n\n## Test Coverage Goals\n\n- Unit test coverage: \u003e90% for modified functions\n- Integration test coverage: All major workflows\n- Edge cases covered: conflicts, invalid structures, recovery failures\n\n## Verification\n\n1. Run full test suite: `bun test`\n2. Check coverage report\n3. Manual testing checklist completed\n4. Documentation reviewed for accuracy\n5. CHANGELOG entry added\n\n## Files to Modify\n\n- tests/unit/ (various test files)\n- tests/integration/merge-commits.test.ts (NEW)\n- CHANGELOG.md\n- README.md or docs/\n- Code comments in src/git/, src/tui/\n\n## Dependencies\n\nRequires Phase 1-6 complete (all functionality implemented).","status":"open","priority":2,"issue_type":"task","owner":"don.denton@trillianthealth.com","created_at":"2026-01-13T11:40:14.675119-05:00","created_by":"Don Denton","updated_at":"2026-01-13T11:40:14.675119-05:00","dependencies":[{"issue_id":"spry-0ezd","depends_on_id":"spry-xt0q","type":"blocks","created_at":"2026-01-13T11:40:21.52361-05:00","created_by":"Don Denton"}]}
{"id":"spry-0gw","title":"taspr-migrate-rebase","description":"# Migrate rebase.ts to In-Memory Operations\n\nReplace traditional rebase operations in \\`src/git/rebase.ts\\` with in-memory equivalents.\n\n## Functions to Migrate\n\n### 1. \\`injectMissingIds\\`\n**Current**: Uses \\`git rebase -i --exec\\` with shell script that runs \\`git commit --amend\\`\n\n**New Approach**:\n1. Get commits missing IDs\n2. For each commit, generate new message with trailer\n3. Use \\`rewriteCommitChain\\` to rebuild chain with new messages\n4. Finalize with \\`finalizeRewrite\\`\n\n### 2. \\`rebaseOntoMain\\`\n**Current**: Uses \\`git rebase \\${defaultBranchRef}\\`\n\n**New Approach**:\n1. Use \\`inMemoryRebase\\` to cherry-pick commits\n2. On conflict: offer fallback to traditional rebase\n3. On success: finalize with \\`finalizeRewrite\\`\n\n## Migration Strategy\n1. Create new implementations alongside existing\n2. Add feature flag or environment variable to switch\n3. Test thoroughly\n4. Remove old implementations\n\n## Tests\n- All existing tests must pass\n- Add tests for the untracked file scenario\n- Performance comparison tests","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-08T22:11:23.029653-05:00","updated_at":"2026-01-08T22:47:33.015841-05:00","closed_at":"2026-01-08T22:47:33.015841-05:00","close_reason":"Closed","dependencies":[{"issue_id":"spry-0gw","depends_on_id":"spry-3dn","type":"blocks","created_at":"2026-01-08T22:11:27.646986-05:00","created_by":"don.denton"},{"issue_id":"spry-0gw","depends_on_id":"spry-d6j","type":"blocks","created_at":"2026-01-08T22:11:27.704493-05:00","created_by":"don.denton"}]}
{"id":"spry-0kf","title":"Refactor tests to reduce repetition with helper functions","description":"The test files contain a lot of repetitive code that could be extracted into reusable helper functions. This would make tests easier to write and maintain.\n\n## Examples of repetition to address\n- Setting up test repositories\n- Creating commits with trailers\n- Mocking GitHub API responses\n- Common assertions\n\n## Acceptance Criteria\n- [ ] Identify common patterns across test files\n- [ ] Create test helper module(s)\n- [ ] Refactor existing tests to use helpers\n- [ ] Tests still pass after refactoring","status":"closed","priority":3,"issue_type":"task","created_at":"2025-12-31T14:39:29.230176-05:00","updated_at":"2026-01-10T00:36:02.166146-05:00","closed_at":"2025-12-31T14:58:00.031368-05:00","close_reason":"Refactored 11 test files to use new helpers: fixtureManager() for automatic cleanup, updateOriginMain() for simulating other developer's work. Made createGitFixture() private. All 164 tests pass."}
{"id":"spry-0la","title":"Add --up-to flag for selective PR creation in sync --open","description":"Allow users to limit which commits get PRs opened during `taspr sync --open`.\n\n## Syntax\n```bash\ntaspr sync --open --up-to \u003cidentifier\u003e\n```\n\n## Identifier Resolution\nThe `\u003cidentifier\u003e` can be:\n- Git commit hash (full or partial)\n- Taspr-Commit-Id (the 8-char ID in trailers)\n- Group ID\n\n## Behavior\n- Opens PRs for all commits/groups from the bottom of the stack up to and including the specified commit/group\n- If the specified commit is within a group, the entire group gets a PR opened\n- Must fail with clear error if the identifier is ambiguous (matches multiple commits)\n- Should validate the identifier exists in the current stack\n\n## Error Cases\n- Ambiguous identifier: \"Error: 'abc' matches multiple commits. Please provide more characters to disambiguate.\"\n- Not found: \"Error: No commit or group matching 'xyz' found in stack\"\n- Not in stack: \"Error: Commit 'abc123' exists but is not part of the current stack\"\n\n## Implementation Notes\n- Need a resolver function that tries git hash, then taspr ID, then group ID\n- Track which commits were \"opened\" vs \"skipped\" in output","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-08T12:07:12.657458-05:00","updated_at":"2026-01-08T15:33:55.188272-05:00","closed_at":"2026-01-08T15:33:55.188272-05:00","close_reason":"Implemented --up-to flag. Reuses identifier resolution from --apply. Both flags are mutually exclusive.","dependencies":[{"issue_id":"spry-0la","depends_on_id":"spry-bww","type":"blocks","created_at":"2026-01-08T15:19:00.652405-05:00","created_by":"don.denton"}]}
{"id":"spry-0z7","title":"Handle detached HEAD state gracefully","description":"Running commands in detached HEAD causes silent failures or cryptic errors. getCurrentBranch() returns 'HEAD' which breaks branch creation. Add detection and helpful error message.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-10T00:28:12.704082-05:00","created_by":"don.denton","updated_at":"2026-01-11T21:10:34.113543-05:00","closed_at":"2026-01-11T21:10:34.113543-05:00","close_reason":"Added isDetachedHead() and assertNotDetachedHead() functions, protected rebase and group operations, and added tests","dependencies":[{"issue_id":"spry-0z7","depends_on_id":"spry-do5","type":"parent-child","created_at":"2026-01-10T01:04:18.434522-05:00","created_by":"don.denton"}]}
{"id":"spry-130","title":"View command with PR info","description":"## Goal\nEnhance `taspr view` to show PR numbers and basic status for each PRUnit.\n\n## Current State (from Epic 1)\nView shows local stack structure:\n```\n  ○ Add user model\n    └─ a1b2c3d4\n```\n\n## Enhanced Output\nWith PR info from GitHub:\n```\n  ◐ #142 Add user model\n    └─ a1b2c3d4\n    https://github.com/org/repo/pull/142\n```\n\n### Status Indicators\n- `✓` Merged\n- `◐` Open\n- `○` No PR yet\n- `✗` Closed (not merged)\n\n## Implementation\n\n```typescript\n// src/cli/commands/view.ts\n\nasync function viewCommand() {\n  const result = await parseStack();\n  if (!result.ok) { /* handle error */ }\n  \n  // Get branch config for lookups\n  const config = await getBranchNameConfig();\n  \n  // Enrich units with PR info\n  const enrichedUnits = await Promise.all(\n    result.units.map(async unit =\u003e {\n      const branch = getBranchName(unit.id, config);\n      const pr = await findPRByBranch(branch);\n      return { ...unit, pr };\n    })\n  );\n  \n  // Format and display\n  console.log(formatStackView(enrichedUnits));\n}\n```\n\n### Updated Formatting\n```typescript\nfunction formatPRUnit(unit: EnrichedPRUnit): string {\n  const status = getPRStatusIcon(unit.pr);\n  const prNum = unit.pr ? \\`#\\${unit.pr.number} \\` : '';\n  const title = unit.title;\n  \n  let output = \\`  \\${status} \\${prNum}\\${title}\\\\n\\`;\n  \n  // Commits\n  for (const commit of unit.commits) {\n    output += \\`    └─ \\${commit.slice(0, 8)}\\\\n\\`;\n  }\n  \n  // PR URL\n  if (unit.pr) {\n    output += \\`    \\${unit.pr.url}\\\\n\\`;\n  }\n  \n  return output;\n}\n\nfunction getPRStatusIcon(pr: PRInfo | null): string {\n  if (!pr) return '○';\n  switch (pr.state) {\n    case 'open': return '◐';\n    case 'merged': return '✓';\n    case 'closed': return '✗';\n    default: return '○';\n  }\n}\n```\n\n## Caching for Performance\nPR lookups are slow. Consider caching:\n- Within a single view command\n- Optional: `.git/taspr/cache.json` with TTL\n\nFor now, just parallelize lookups within view.\n\n## Testing\n- View with no PRs → all ○\n- View with open PRs → shows ◐ and URLs\n- View with mixed states\n\n## Files to Modify\n- src/cli/commands/view.ts\n- src/cli/output.ts\n\n## Acceptance Criteria\n- [ ] Shows PR numbers when PRs exist\n- [ ] Shows correct status icons\n- [ ] Shows PR URLs\n- [ ] Handles units without PRs gracefully","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T14:29:59.545059-05:00","updated_at":"2026-01-10T00:36:02.203146-05:00","closed_at":"2025-12-28T23:45:48.773948-05:00","close_reason":"Implemented and tested. View command now shows PR numbers, status icons (○/◐/✓/✗), and PR URLs when PRs exist.","dependencies":[{"issue_id":"spry-130","depends_on_id":"spry-d0k","type":"parent-child","created_at":"2025-12-25T14:30:03.44579-05:00","created_by":"daemon"},{"issue_id":"spry-130","depends_on_id":"spry-ab6","type":"blocks","created_at":"2025-12-25T14:30:03.718564-05:00","created_by":"daemon"},{"issue_id":"spry-130","depends_on_id":"spry-ab6","type":"depends-on","created_at":"2025-12-25T14:30:03.718564-05:00","created_by":"daemon"}]}
{"id":"spry-1jo","title":"Error messages - clear, actionable errors throughout","description":"## Goal\nEnsure all error conditions produce clear, actionable error messages that help users understand what went wrong and how to fix it.\n\n## Error Categories to Handle\n\n### Git Errors\n- **Not a git repository**: 'Not in a git repository. Run this command from within a git project.'\n- **No commits**: 'No commits found between HEAD and origin/main. Create some commits first.'\n- **Dirty working tree**: 'You have uncommitted changes. Commit or stash them before running sync.'\n- **Detached HEAD**: 'You are in detached HEAD state. Check out a branch first.'\n- **Rebase in progress**: 'A rebase is in progress. Complete or abort it before continuing.'\n\n### GitHub Errors\n- **gh not installed**: 'The GitHub CLI (gh) is required but not installed. Install it from https://cli.github.com'\n- **gh not authenticated**: 'Not authenticated with GitHub. Run: gh auth login'\n- **No push access**: 'You don\\'t have push access to this repository.'\n- **PR creation failed**: Include the GitHub error message, suggest checking permissions\n- **Rate limited**: 'GitHub API rate limit exceeded. Try again in X minutes.'\n- **Network errors**: 'Could not connect to GitHub. Check your internet connection.'\n\n### Stack/Group Errors\n- **Overlapping groups**: 'Groups cannot overlap. Commits X and Y belong to multiple groups.'\n- **Unclosed group**: 'Group \"X\" started at commit Y but was never closed.'\n- **Invalid group range**: 'Group end marker found before start marker.'\n- **Empty stack**: 'No commits in current stack. Create commits on this branch first.'\n\n### Command Errors\n- **Invalid arguments**: Use Commander\\'s built-in validation with helpful messages\n- **Missing required options**: Commander handles this, but customize messages\n- **Invalid PR number**: 'PR #X not found. Check the PR number and try again.'\n\n## Implementation Guidelines\n\n### Error Message Format\n```\nError: \u003cbrief description\u003e\n\n\u003cdetailed explanation if needed\u003e\n\n\u003csuggested fix or next step\u003e\n```\n\n### Example Good Error\n```\nError: Cannot sync - uncommitted changes detected\n\nYou have 3 modified files that would be lost during rebase.\n\nTo fix:\n  git stash        # Save changes temporarily\n  taspr sync       # Run sync\n  git stash pop    # Restore changes\n```\n\n### Code Pattern\n```typescript\n// src/errors.ts\nexport class TasprError extends Error {\n  constructor(\n    message: string,\n    public readonly suggestion?: string,\n    public readonly details?: string\n  ) {\n    super(message);\n    this.name = 'TasprError';\n  }\n}\n\nexport function formatError(error: TasprError): string {\n  let output = `Error: ${error.message}`;\n  if (error.details) output += `\\n\\n${error.details}`;\n  if (error.suggestion) output += `\\n\\nTo fix:\\n  ${error.suggestion}`;\n  return output;\n}\n```\n\n### Audit All Commands\n- Review each command for error paths\n- Ensure consistent error formatting\n- Test error messages are helpful\n\n## Acceptance Criteria\n- [ ] All errors use consistent format\n- [ ] Errors include actionable suggestions where possible\n- [ ] No raw exception messages leak to users\n- [ ] Network/API errors are user-friendly\n- [ ] Exit codes are meaningful (0=success, 1=user error, 2=system error)","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-25T14:49:11.790611-05:00","updated_at":"2026-01-10T00:36:02.19768-05:00","dependencies":[{"issue_id":"spry-1jo","depends_on_id":"spry-do5","type":"parent-child","created_at":"2025-12-25T15:01:36.509681-05:00","created_by":"daemon"}],"comments":[{"id":1,"issue_id":"spry-1jo","author":"dondenton","text":"Partial sync failure recovery: If sp sync crashes mid-operation (e.g., after pushing branches but before creating PRs), users need clear guidance on the state they're in and how to recover. Currently there's no rollback and no recovery instructions. When implementing error messages, include: (1) what operations succeeded, (2) what failed, (3) what state things are in, (4) how to recover (usually just re-run sp sync). See spry-8cz for the original issue - punting on transaction-like rollback in favor of better error messaging.","created_at":"2026-01-10T19:43:43Z"}]}
{"id":"spry-1rd","title":"Force push updated branches","description":"## Goal\nForce-push branches that have changed after local commit amendments.\n\n## Implementation\n\n```typescript\n// src/github/branches.ts\n\nasync function forcePushBranch(commitHash: string, branchName: string): Promise\u003cvoid\u003e {\n  await $\\`git push --force origin ${commitHash}:refs/heads/${branchName}\\`;\n}\n\nasync function updateChangedBranches(\n  units: PRUnit[],\n  statuses: Map\u003cstring, SyncStatus\u003e,\n  config: BranchNameConfig\n): Promise\u003cstring[]\u003e {\n  const updated: string[] = [];\n  \n  for (const unit of units) {\n    const status = statuses.get(unit.id)!;\n    \n    if (status.needsUpdate) {\n      await forcePushBranch(status.localCommit, status.branchName);\n      updated.push(status.branchName);\n    }\n  }\n  \n  return updated;\n}\n```\n\n### Safety Considerations\n- Force push is destructive—overwrites remote branch\n- Fine for taspr branches (single owner)\n- GitHub retains old commits briefly via reflog\n\n### Reporting\n```\n$ taspr sync\n\n✓ Updated 2 branch(es):\n  • taspr/msims/a1b2c3d4 (b2c3d4e5 → new-hash)\n  • taspr/msims/f7e8d9c0 (c3d4e5f6 → new-hash)\n```\n\n## Integration with Sync Command\nThe sync command now:\n1. Injects missing IDs (Epic 2)\n2. For each unit:\n   - If no remote branch: push + create PR (Epic 3)\n   - If remote differs: force push (this task)\n   - If up to date: skip\n\n## Testing\n- Force push succeeds\n- Old commit is replaced\n- PR reflects new code\n\n## Files to Modify\n- src/github/branches.ts\n\n## Acceptance Criteria\n- [ ] Force pushes changed branches\n- [ ] Reports which branches were updated\n- [ ] Handles push failures gracefully","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T14:29:39.346235-05:00","updated_at":"2026-01-10T00:36:02.19363-05:00","closed_at":"2025-12-30T00:25:21.568515-05:00","close_reason":"Already implemented. Force push is integrated via pushBranch(commit, branch, force=true) when needsUpdate is detected. All tests pass.","dependencies":[{"issue_id":"spry-1rd","depends_on_id":"spry-d0k","type":"parent-child","created_at":"2025-12-25T14:29:42.942259-05:00","created_by":"daemon"},{"issue_id":"spry-1rd","depends_on_id":"spry-suj","type":"blocks","created_at":"2025-12-25T14:29:43.214548-05:00","created_by":"daemon"},{"issue_id":"spry-1rd","depends_on_id":"spry-suj","type":"depends-on","created_at":"2025-12-25T14:29:43.214548-05:00","created_by":"daemon"}]}
{"id":"spry-1z7","title":"Rename tool from taspr to spry (binary: sp)","description":"Rename the entire CLI tool from \"taspr\" to \"spry\" with the binary name changing to \"sp\".\n\n## Naming Changes\n\n| Category | Old | New |\n|----------|-----|-----|\n| Tool name | taspr | spry |\n| Binary name | taspr | sp |\n| Package name | taspr | spry |\n| GitHub repo | happycollision/taspr | happycollision/spry-cli |\n| Git config keys | taspr.* | spry.* |\n| Git trailers | Taspr-Commit-Id, Taspr-Group | Spry-Commit-Id, Spry-Group |\n| Branch prefix | taspr/ | spry/ |\n| Environment vars | TASPR_* | SPRY_* |\n| Test repo name | taspr-check | spry-check |\n\n## Notes\n- No backwards compatibility concerns - tool not in production use yet\n- One file rename needed: scripts/setup-taspr-check.ts → scripts/setup-spry-check.ts\n- After all changes: run bunx tsc, bun run build, bun test, and verify ./dist/sp --help works","status":"closed","priority":2,"issue_type":"epic","created_at":"2026-01-09T11:55:10.578847-05:00","updated_at":"2026-01-09T13:37:07.968981-05:00","closed_at":"2026-01-09T13:37:07.968981-05:00","close_reason":"Closed"}
{"id":"spry-1z7.1","title":"Update package.json","description":"Update package.json with new names:\n- Line 2: \"name\": \"taspr\" → \"name\": \"spry\"\n- Line 6: \"taspr\": \"./dist/taspr\" → \"sp\": \"./dist/sp\"\n- Line 11: build script output dist/taspr → dist/sp\n- Line 14: script name setup-taspr-check.ts → setup-spry-check.ts","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-09T11:55:48.463012-05:00","updated_at":"2026-01-09T13:37:07.943625-05:00","closed_at":"2026-01-09T13:37:07.943625-05:00","close_reason":"Closed","dependencies":[{"issue_id":"spry-1z7.1","depends_on_id":"spry-1z7","type":"parent-child","created_at":"2026-01-09T11:55:48.470328-05:00","created_by":"don.denton"}]}
{"id":"spry-1z7.10","title":"Update scripts and installation","description":"Update build/release scripts:\n\nscripts/release.sh:\n- Comment: \"Release script for spry\"\n- GitHub URL: https://github.com/happycollision/spry-cli/actions\n\nscripts/setup-taspr-check.ts → scripts/setup-spry-check.ts (RENAME FILE):\n- SAFETY_MARKER = \"\u003c!-- spry-test-repo:v1 --\u003e\"\n- REPO_NAME default = \"spry-check\"\n- Env var: SPRY_TEST_REPO_NAME, SPRY_TEST_REPO_SETUP_SKIP_CONFIRM\n- Git config email/name: spry-tests@example.com, spry-tests\n- Commit message: \"Initialize spry-check repository\"\n- Temp dir: spry-check-setup-\n- Console messages\n\ninstall.sh:\n- Comment: \"spry installation script\"\n- REPO=\"happycollision/spry-cli\"\n- INSTALL_DIR=\"${SPRY_INSTALL_DIR:-$HOME/.spry}\"\n- BIN_DIR=\"${SPRY_BIN_DIR:-$SPRY_INSTALL_DIR/bin}\"\n- Binary names: sp-${os}-${arch}, sp.exe\n- Success message: \"spry $version installed\"\n- Help message: \"Run 'sp --help' to get started\"","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-09T11:57:13.680987-05:00","updated_at":"2026-01-09T13:37:07.964163-05:00","closed_at":"2026-01-09T13:37:07.964163-05:00","close_reason":"Closed","dependencies":[{"issue_id":"spry-1z7.10","depends_on_id":"spry-1z7","type":"parent-child","created_at":"2026-01-09T11:57:13.685944-05:00","created_by":"don.denton"}]}
{"id":"spry-1z7.11","title":"Update GitHub Actions workflow","description":"Update .github/workflows/release.yml:\n\n- Lines 58-60: Binary output names: dist/sp-${{ matrix.target }}.exe and dist/sp-${{ matrix.target }}\n- Line 66: Artifact name: sp-${{ matrix.target }}\n- Line 85: find artifacts -type f -name 'sp-*'","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-09T11:57:13.799046-05:00","updated_at":"2026-01-09T13:37:07.965294-05:00","closed_at":"2026-01-09T13:37:07.965294-05:00","close_reason":"Closed","dependencies":[{"issue_id":"spry-1z7.11","depends_on_id":"spry-1z7","type":"parent-child","created_at":"2026-01-09T11:57:13.80088-05:00","created_by":"don.denton"}]}
{"id":"spry-1z7.12","title":"Update documentation","description":"Update all documentation files:\n\nREADME.md:\n- Title: # spry\n- Installation URLs: happycollision/spry-cli\n- Environment variables: SPRY_INSTALL_DIR, SPRY_BIN_DIR\n- All command examples: sp view, sp sync, sp land, sp clean, sp group\n- Git config examples: git config spry.branchPrefix, spry.defaultBranch\n- Build paths and aliases\n\nCHANGELOG.md:\n- Command references in changelog entries\n\n.env.example:\n- Comment: \"spry Environment Configuration\"\n- Variable: SPRY_TEST_REPO_NAME=spry-check","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-09T11:57:13.908005-05:00","updated_at":"2026-01-09T13:37:07.966481-05:00","closed_at":"2026-01-09T13:37:07.966481-05:00","close_reason":"Closed","dependencies":[{"issue_id":"spry-1z7.12","depends_on_id":"spry-1z7","type":"parent-child","created_at":"2026-01-09T11:57:13.909261-05:00","created_by":"don.denton"}]}
{"id":"spry-1z7.13","title":"Build and verify","description":"After all changes are complete, verify everything works:\n\n1. bunx tsc - TypeScript compilation should pass\n2. bun run build - Should create ./dist/sp binary\n3. bun test - All tests should pass\n4. ./dist/sp --help - Binary should work and show \"spry\" branding","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-09T11:57:14.010753-05:00","updated_at":"2026-01-09T13:37:07.967559-05:00","closed_at":"2026-01-09T13:37:07.967559-05:00","close_reason":"Closed","dependencies":[{"issue_id":"spry-1z7.13","depends_on_id":"spry-1z7","type":"parent-child","created_at":"2026-01-09T11:57:14.011847-05:00","created_by":"don.denton"}]}
{"id":"spry-1z7.2","title":"Update CLI entry point","description":"Update src/cli/index.ts:\n- Line 13: .name(\"taspr\") → .name(\"spry\")","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-09T11:55:48.588839-05:00","updated_at":"2026-01-09T13:37:07.948536-05:00","closed_at":"2026-01-09T13:37:07.948536-05:00","close_reason":"Closed","dependencies":[{"issue_id":"spry-1z7.2","depends_on_id":"spry-1z7","type":"parent-child","created_at":"2026-01-09T11:55:48.589839-05:00","created_by":"don.denton"}]}
{"id":"spry-1z7.4","title":"Update git trailers","description":"Update src/git/trailers.ts:\n- Line 5: \"Taspr-Commit-Id\" → \"Spry-Commit-Id\"\n- Line 7: \"Taspr-Group\" → \"Spry-Group\"\n\nAlso update src/git/group-titles.ts:\n- refs/taspr/\u003cusername\u003e/group-titles → refs/spry/\u003cusername\u003e/group-titles","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-09T11:55:48.815653-05:00","updated_at":"2026-01-09T13:37:07.95497-05:00","closed_at":"2026-01-09T13:37:07.95497-05:00","close_reason":"Closed","dependencies":[{"issue_id":"spry-1z7.4","depends_on_id":"spry-1z7","type":"parent-child","created_at":"2026-01-09T11:55:48.817167-05:00","created_by":"don.denton"}]}
{"id":"spry-1z7.5","title":"Update core source files","description":"Update references in core source files:\n\n- src/git/commands.ts - Error message referencing git config spry.defaultBranch\n- src/github/branches.ts - Variable names (tasprConfig → spryConfig), example comments\n- src/cli/commands/sync.ts - Variable names, URL: https://github.com/happycollision/spry-cli#temporary-commits\n- src/cli/commands/land.ts - Error messages: \"Run 'sp view' to see status.\"\n- src/cli/commands/group.ts - Usage: \"Usage: sp group dissolve \u003cgroup-id\u003e\"\n- src/cli/commands/clean.ts - Comments about \"spry pattern\"\n- src/cli/output.ts - Help message: \"run `sp group --fix`\"\n- src/core/id.ts - Comments about Spry-Commit-Id\n- src/core/identifier.ts - Comments about Spry-Commit-Id\n- src/git/rebase.ts - Comments referencing spry sync","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-09T11:56:49.381464-05:00","updated_at":"2026-01-09T13:37:07.957324-05:00","closed_at":"2026-01-09T13:37:07.957324-05:00","close_reason":"Closed","dependencies":[{"issue_id":"spry-1z7.5","depends_on_id":"spry-1z7","type":"parent-child","created_at":"2026-01-09T11:56:49.387952-05:00","created_by":"don.denton"}]}
{"id":"spry-1z7.6","title":"Update scenario/testing infrastructure","description":"Update test infrastructure files:\n\nsrc/scenario/core.ts:\n- Temp directory names: /tmp/spry-test-origin-*, /tmp/spry-test-*\n- Comments referencing these paths\n\nsrc/scenario/runner.ts:\n- Comments about \"spawns a shell with spry in PATH\"\n- Variable names: tasprPath → spryPath\n- Function comments about spry dist directory\n\nsrc/scenario/definitions.ts:\n- Scenario name: \"with-taspr-ids\" → \"with-spry-ids\"","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-09T11:56:49.514797-05:00","updated_at":"2026-01-09T13:37:07.958788-05:00","closed_at":"2026-01-09T13:37:07.958788-05:00","close_reason":"Closed","dependencies":[{"issue_id":"spry-1z7.6","depends_on_id":"spry-1z7","type":"parent-child","created_at":"2026-01-09T11:56:49.516379-05:00","created_by":"don.denton"}]}
{"id":"spry-1z7.7","title":"Update integration test files","description":"Update all integration test files with new command names and references:\n\n- tests/integration/clean.test.ts - sp sync, branch patterns\n- tests/integration/sync.test.ts - SPRY_TEST_REPO_NAME, sp commands\n- tests/integration/land.test.ts - sp command references\n- tests/integration/pr-status.test.ts - sp command references\n- tests/integration/group-fix.test.ts - describe(\"sp group --fix\"...)\n- tests/integration/helpers.ts - Comments and command strings \"sp ${command}\"","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-09T11:56:49.64107-05:00","updated_at":"2026-01-09T13:37:07.960226-05:00","closed_at":"2026-01-09T13:37:07.960226-05:00","close_reason":"Closed","dependencies":[{"issue_id":"spry-1z7.7","depends_on_id":"spry-1z7","type":"parent-child","created_at":"2026-01-09T11:56:49.643536-05:00","created_by":"don.denton"}]}
{"id":"spry-1z7.8","title":"Update test helpers","description":"Update test helper files:\n\ntests/helpers/github-fixture.ts:\n- Safety marker: \"\u003c!-- spry-test-repo:v1 --\u003e\"\n- DEFAULT_REPO_NAME = \"spry-check\"\n- Error messages referencing spry test repo\n- Comment about setup-spry-check.ts\n\ntests/helpers/local-repo.ts:\n- Comment about \"spry integration tests\"\n\ntests/helpers/story.test.ts:\n- Command references: \"sp sync\", \"sp view\"","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-09T11:57:02.091771-05:00","updated_at":"2026-01-09T13:37:07.961741-05:00","closed_at":"2026-01-09T13:37:07.961741-05:00","close_reason":"Closed","dependencies":[{"issue_id":"spry-1z7.8","depends_on_id":"spry-1z7","type":"parent-child","created_at":"2026-01-09T11:57:02.098337-05:00","created_by":"don.denton"}]}
{"id":"spry-1z7.9","title":"Update unit test files","description":"Update unit test files with new config keys and branch patterns:\n\n- src/git/config.test.ts - git config spry.* commands, default values\n- src/git/trailers.test.ts - Comments about \"spry trailer types\"\n- src/git/remote.test.ts - Test config: { prefix: \"spry\", username: \"testuser\" }\n- src/github/branches.test.ts - Test config, branch names like spry/testuser/abc123\n- src/git/pr-detection.test.ts - Test config with spry branch pattern\n- src/core/identifier.test.ts - References to Spry-Commit-Id\n- src/git/plumbing.test.ts - Comments","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-09T11:57:02.221363-05:00","updated_at":"2026-01-09T13:37:07.962905-05:00","closed_at":"2026-01-09T13:37:07.962905-05:00","close_reason":"Closed","dependencies":[{"issue_id":"spry-1z7.9","depends_on_id":"spry-1z7","type":"parent-child","created_at":"2026-01-09T11:57:02.222378-05:00","created_by":"don.denton"}]}
{"id":"spry-2d6","title":"Add tests for sp wt commands","description":"Test coverage for sp wt commands.\n\nUnit tests:\n- Path token expansion (\u003crepo_root\u003e, \u003crepo_name\u003e, \u003cworktree_root\u003e)\n- Config helpers (get/set spry.tree.* values)\n- Branch existence checks\n- Default branch detection\n\nIntegration tests:\n- sp wt new creates worktree and branch\n- sp wt new -e uses existing branch\n- sp wt new -i starts from specific ref\n- sp wt rm removes worktree\n- sp wt rm --del-all cleans up branches\n- sp wt setup --init creates template\n- sp wt setup runs script with correct args\n- Auto-setup after create\n\nReference test patterns: ~/dotfiles/test/git-ht-test.sh","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-10T15:23:06.664501-05:00","created_by":"dondenton","updated_at":"2026-01-10T20:46:57.99305-05:00","dependencies":[{"issue_id":"spry-2d6","depends_on_id":"spry-ra3","type":"parent-child","created_at":"2026-01-10T15:23:13.243194-05:00","created_by":"dondenton"},{"issue_id":"spry-2d6","depends_on_id":"spry-ij4","type":"blocks","created_at":"2026-01-10T15:26:17.855629-05:00","created_by":"dondenton"},{"issue_id":"spry-2d6","depends_on_id":"spry-9i5","type":"blocks","created_at":"2026-01-10T15:26:17.945345-05:00","created_by":"dondenton"},{"issue_id":"spry-2d6","depends_on_id":"spry-nhq","type":"blocks","created_at":"2026-01-10T15:26:18.035997-05:00","created_by":"dondenton"},{"issue_id":"spry-2d6","depends_on_id":"spry-b4m","type":"blocks","created_at":"2026-01-10T15:26:18.130576-05:00","created_by":"dondenton"}]}
{"id":"spry-2gq","title":"Add interactive mode for sync --open (-i/--interactive)","description":"Add an interactive TUI mode for selecting which commits/groups to open PRs for.\n\n## Syntax\n```bash\ntaspr sync --open -i\ntaspr sync --open --interactive\n```\n\n## Behavior\n- Shows a list of all commits/groups in the stack\n- Indicates which already have PRs (show as disabled/locked)\n- User can toggle which ones to open PRs for\n- Can skip commits in the middle - branches still push for stacking, just no PR created\n- Skipped commits work like temp commits (WIP/fixup!) - branch exists, PR targets it\n\n## TUI Design\nSimilar to `taspr group` TUI:\n- Arrow keys to navigate\n- Space to toggle selection\n- Enter to confirm and create PRs\n- Esc to cancel\n\n## Display Format\n```\nSelect commits to open PRs for:\n  [✓] abc123 Add user model          (PR #42 - existing)\n  [ ] def456 Add user API            (will push branch only)\n  [x] ghi789 Add user tests          (will create PR)\n  [ ] jkl012 Add user docs           (will push branch only)\n\n↑/↓ Navigate  Space Toggle  Enter Confirm  Esc Cancel\n```\n\n## Notes\n- Skipping in the middle is valid! The skipped branch still gets pushed\n- PRs above skipped commits will base on the skipped branch\n- This matches existing temp commit behavior","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-08T12:30:53.284034-05:00","updated_at":"2026-01-10T00:36:02.184967-05:00","closed_at":"2026-01-08T15:36:25.346713-05:00","close_reason":"Implemented -i/--interactive flag for sync --open. Added openSelect TUI component. All three selector options (--apply, --up-to, -i) are mutually exclusive."}
{"id":"spry-2hk","title":"Prevent WIP/fixup/amend commits from becoming PRs","description":"Commits with certain prefixes should be handled specially during `taspr sync --open`:\n- WIP (case insensitive)\n- fixup!\n- amend!\n- squash!\n\n## Behavior\n\n**These commits should NOT automatically get PRs**, but they don't block anything:\n1. Push branch (needed for stacking if there are dependent commits)\n2. Skip PR creation\n3. Dependent commits CAN have PRs (reviewable, but base has no PR)\n4. Output: `⚠ Skipped PR for \"WIP: ...\" (work in progress)` or similar\n\n**Escape hatch**: Explicit grouping allows PR creation. If user groups a WIP commit with others, we create the PR.\n\n## Implementation Notes\n\n- Add `isWorkInProgress(title: string): boolean` helper\n- Modify sync to check title before PR creation\n- Still push branches for stacking (unlike regular commits without --open)\n- Track \"skipped WIP\" separately in sync output","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-03T00:00:37.575334-05:00","updated_at":"2026-01-10T00:36:02.184163-05:00","closed_at":"2026-01-03T13:57:47.20772-05:00","close_reason":"Implemented temp commit detection with configurable prefixes via git config taspr.tempCommitPrefixes. WIP, fixup!, amend!, squash! commits now skip PR creation during sync --open while still pushing branches for stacking. Added unit tests for isTempCommit() and config parsing, plus integration tests for the sync behavior."}
{"id":"spry-2in","title":"Installation script - curl | bash installer","description":"## Goal\nCreate a simple installation script that users can run via `curl | bash` to install taspr.\n\n## Installation Command\n\n```bash\ncurl -fsSL https://raw.githubusercontent.com/OWNER/taspr/main/install.sh | bash\n```\n\n## Installation Script\n\n```bash\n#\\!/bin/bash\n# install.sh - Install taspr CLI\n\nset -euo pipefail\n\n# Configuration\nREPO=\"OWNER/taspr\"\nINSTALL_DIR=\"${INSTALL_DIR:-$HOME/.local/bin}\"\n\n# Detect platform\nOS=\"$(uname -s | tr '[:upper:]' '[:lower:]')\"\nARCH=\"$(uname -m)\"\n\ncase \"$OS\" in\n  darwin) OS=\"darwin\" ;;\n  linux) OS=\"linux\" ;;\n  *) echo \"Error: Unsupported OS: $OS\"; exit 1 ;;\nesac\n\ncase \"$ARCH\" in\n  x86_64) ARCH=\"x64\" ;;\n  amd64) ARCH=\"x64\" ;;\n  arm64) ARCH=\"arm64\" ;;\n  aarch64) ARCH=\"arm64\" ;;\n  *) echo \"Error: Unsupported architecture: $ARCH\"; exit 1 ;;\nesac\n\nBINARY=\"taspr-${OS}-${ARCH}\"\n\n# Get latest release\necho \"Fetching latest release...\"\nLATEST_TAG=$(curl -fsSL \"https://api.github.com/repos/$REPO/releases/latest\" | grep '\"tag_name\":' | sed -E 's/.*\"([^\"]+)\".*/\\1/')\n\nif [ -z \"$LATEST_TAG\" ]; then\n  echo \"Error: Could not determine latest release\"\n  exit 1\nfi\n\necho \"Installing taspr $LATEST_TAG for $OS/$ARCH...\"\n\n# Download binary\nDOWNLOAD_URL=\"https://github.com/$REPO/releases/download/$LATEST_TAG/$BINARY\"\nTMP_FILE=\"$(mktemp)\"\n\ncurl -fsSL \"$DOWNLOAD_URL\" -o \"$TMP_FILE\"\n\n# Create install directory if needed\nmkdir -p \"$INSTALL_DIR\"\n\n# Install binary\nchmod +x \"$TMP_FILE\"\nmv \"$TMP_FILE\" \"$INSTALL_DIR/taspr\"\n\necho \"\"\necho \"✓ taspr installed to $INSTALL_DIR/taspr\"\necho \"\"\n\n# Check if install dir is in PATH\nif [[ \":$PATH:\" \\!= *\":$INSTALL_DIR:\"* ]]; then\n  echo \"⚠ $INSTALL_DIR is not in your PATH\"\n  echo \"\"\n  echo \"Add it to your shell config:\"\n  echo \"  echo 'export PATH=\\\"$INSTALL_DIR:\\$PATH\\\"' \u003e\u003e ~/.bashrc\"\n  echo \"  # or for zsh:\"\n  echo \"  echo 'export PATH=\\\"$INSTALL_DIR:\\$PATH\\\"' \u003e\u003e ~/.zshrc\"\n  echo \"\"\nfi\n\n# Verify installation\nif command -v taspr \u0026\u003e /dev/null; then\n  echo \"Installed version:\"\n  taspr --version\nelse\n  echo \"Run 'taspr --version' to verify installation\"\nfi\n\necho \"\"\necho \"Prerequisites:\"\necho \"  - git (you probably have this)\"\necho \"  - gh CLI (https://cli.github.com)\"\necho \"\"\necho \"Quick start:\"\necho \"  cd your-repo\"\necho \"  taspr view    # See your stack\"\necho \"  taspr sync    # Push to GitHub\"\n```\n\n## Alternative: npm/bunx Installation\n\nFor users who prefer npm/bun:\n\n```json\n// package.json\n{\n  \"name\": \"taspr\",\n  \"version\": \"0.1.0\",\n  \"bin\": {\n    \"taspr\": \"./dist/taspr\"\n  },\n  \"files\": [\n    \"dist/taspr\"\n  ]\n}\n```\n\n```bash\n# Global install via npm\nnpm install -g taspr\n\n# Or run without installing\nnpx taspr view\nbunx taspr view\n```\n\n## Uninstall Script\n\n```bash\n#\\!/bin/bash\n# uninstall.sh\n\nrm -f \"${INSTALL_DIR:-$HOME/.local/bin}/taspr\"\necho \"✓ taspr uninstalled\"\n```\n\n## Version Check / Update\n\nThe CLI could include update checking:\n```typescript\n// Check for updates (run occasionally, not every command)\nasync function checkForUpdates() {\n  const current = VERSION;\n  const latest = await fetchLatestVersion();\n  \n  if (semver.gt(latest, current)) {\n    console.log(`Update available: ${current} → ${latest}`);\n    console.log('Run: curl -fsSL https://example.com/install.sh | bash');\n  }\n}\n```\n\n## Security Considerations\n\n- Script should verify checksums if we provide them\n- Use HTTPS for all downloads\n- Consider signing binaries (future enhancement)\n\n## Acceptance Criteria\n- [ ] install.sh works on macOS (Intel and Apple Silicon)\n- [ ] install.sh works on Linux (x64 and ARM64)\n- [ ] Script detects platform automatically\n- [ ] Script downloads correct binary from GitHub releases\n- [ ] Script provides PATH guidance if needed\n- [ ] Script verifies installation with --version\n- [ ] Prerequisites (git, gh) are clearly documented\n- [ ] Uninstall instructions provided","status":"closed","priority":3,"issue_type":"task","created_at":"2025-12-25T15:00:34.84736-05:00","updated_at":"2026-01-10T00:36:02.16303-05:00","closed_at":"2026-01-08T12:06:38.158378-05:00","close_reason":"Implemented install.sh with curl support, version selection (--prerelease, specific versions), and GitHub Actions release workflow","dependencies":[{"issue_id":"spry-2in","depends_on_id":"spry-do5","type":"parent-child","created_at":"2025-12-25T15:01:37.614674-05:00","created_by":"daemon"}]}
{"id":"spry-2k9","title":"Group edit command","description":"## Goal\nImplement `taspr group edit` to modify an existing group's range or title.\n\n## Implementation\n\n```typescript\ngroupCommand\n  .command('edit')\n  .description(\"Edit an existing group's range or title\")\n  .action(async () =\u003e {\n    const result = await parseStack();\n    // ... validation\n    \n    // Find existing groups\n    const groups = result.units.filter(u =\u003e u.type === 'group');\n    if (groups.length === 0) {\n      console.log('No groups in current stack');\n      return;\n    }\n    \n    // Select group to edit\n    const group = await select({\n      message: 'Select group to edit',\n      choices: groups.map(g =\u003e ({\n        name: \\`\\${g.title} (\\${g.id}, \\${g.commits.length} commits)\\`,\n        value: g,\n      })),\n    });\n    \n    // What to change\n    const change = await select({\n      message: 'What would you like to change?',\n      choices: [\n        { name: 'Change title', value: 'title' },\n        { name: 'Change commit range', value: 'range' },\n        { name: 'Both', value: 'both' },\n      ],\n    });\n    \n    if (change === 'title' || change === 'both') {\n      const newTitle = await input({ \n        message: 'New title:', \n        default: group.title \n      });\n      await updateGroupTitle(group.id, newTitle);\n    }\n    \n    if (change === 'range' || change === 'both') {\n      const newRange = await selectCommits(result.units, group);\n      await moveGroupBoundaries(group.id, newRange);\n    }\n  });\n```\n\n### Moving Group Boundaries\n```typescript\nasync function moveGroupBoundaries(\n  groupId: string,\n  newRange: CommitInfo[]\n): Promise\u003cvoid\u003e {\n  // 1. Remove old Start/End trailers\n  // 2. Add new Start/End trailers\n  // 3. This requires rebase\n}\n```\n\n## Testing\n- Edit title only\n- Edit range only\n- Edit both\n- Validate new range doesn't overlap\n\n## Files to Modify\n- src/cli/commands/group.ts\n- src/core/group.ts\n\n## Acceptance Criteria\n- [ ] Lists existing groups\n- [ ] Allows editing title\n- [ ] Allows editing commit range\n- [ ] Moves trailers correctly\n- [ ] Validates no overlap with other groups","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-25T14:35:06.986405-05:00","updated_at":"2026-01-10T00:36:02.173454-05:00","closed_at":"2026-01-01T22:45:42.991139-05:00","close_reason":"Replaced by unified group TUI - see taspr-7mu for revised plan","dependencies":[{"issue_id":"spry-2k9","depends_on_id":"spry-r22","type":"parent-child","created_at":"2025-12-25T14:35:11.643065-05:00","created_by":"daemon"},{"issue_id":"spry-2k9","depends_on_id":"spry-cso","type":"blocks","created_at":"2025-12-25T14:35:11.919004-05:00","created_by":"daemon"},{"issue_id":"spry-2k9","depends_on_id":"spry-cso","type":"depends-on","created_at":"2025-12-25T14:35:11.919004-05:00","created_by":"daemon"}]}
{"id":"spry-2x9","title":"taspr-inmem-core","description":"# Core In-Memory Git Primitives\n\nCreate `src/git/inmemory.ts` with low-level plumbing wrappers:\n\n## Functions to Implement\n\n### 1. `getTree(commit: string): Promise\u003cstring\u003e`\nGet tree SHA from a commit: `git rev-parse ${commit}^{tree}`\n\n### 2. `getParents(commit: string): Promise\u003cstring[]\u003e`\nGet all parent SHAs: `git rev-parse ${commit}^@`\n\n### 3. `getAuthorEnv(commit: string): Promise\u003cRecord\u003cstring, string\u003e\u003e`\nExtract author info for preserving authorship:\n- GIT_AUTHOR_NAME, GIT_AUTHOR_EMAIL, GIT_AUTHOR_DATE\n\n### 4. `getAuthorAndCommitterEnv(commit: string): Promise\u003cRecord\u003cstring, string\u003e\u003e`\nExtract both author and committer info (for message-only and DAG-only changes):\n- All author fields + GIT_COMMITTER_NAME, GIT_COMMITTER_EMAIL, GIT_COMMITTER_DATE\n\n### 5. `createCommit(tree: string, parents: string[], message: string, env: Record\u003cstring, string\u003e): Promise\u003cstring\u003e`\nCreate commit with `git commit-tree`:\n```typescript\nconst parentFlags = parents.flatMap(p =\u003e ['-p', p]);\nreturn $`git commit-tree ${tree} ${parentFlags} -m ${message}`.env(env).text().trim();\n```\n\n### 6. `mergeTree(base: string, ours: string, theirs: string): Promise\u003c{ok: true, tree: string} | {ok: false}\u003e`\nThree-way merge with `git merge-tree --write-tree`:\n```typescript\nconst result = await $`git merge-tree --write-tree --merge-base=${base} ${ours} ${theirs}`.nothrow();\nif (result.exitCode !== 0) return { ok: false };\nreturn { ok: true, tree: result.stdout.toString().trim().split('\\n')[0] };\n```\n\n### 7. `updateRef(ref: string, newSha: string, oldSha?: string): Promise\u003cvoid\u003e`\nAtomic ref update: `git update-ref ${ref} ${newSha} [${oldSha}]`\n\n### 8. `checkGitVersion(): Promise\u003c{ok: true} | {ok: false, version: string}\u003e`\nVerify Git 2.38+ for `merge-tree --write-tree` support\n\n## Tests\n- Unit tests for each function\n- Test error handling (missing commits, conflicts, etc.)","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-08T22:10:38.430076-05:00","updated_at":"2026-01-08T22:44:20.612878-05:00","closed_at":"2026-01-08T22:44:20.612878-05:00","close_reason":"Closed","dependencies":[{"issue_id":"spry-2x9","depends_on_id":"spry-n6r","type":"blocks","created_at":"2026-01-08T22:10:42.908063-05:00","created_by":"don.denton"}]}
{"id":"spry-33h","title":"Add test-logs/ to .gitignore","description":"Read the parent epic spry-ww0 for full context.\n\n## Task\nAdd test-logs/ directory to .gitignore so generated story logs are not committed.\n\n## Files\n- .gitignore\n\n## Note\nThis is a simple one-liner but listed as a separate task for completeness. Can be done alongside any other task.","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-05T00:33:33.499913-05:00","updated_at":"2026-01-09T10:36:55.856335-05:00","closed_at":"2026-01-09T10:36:55.856335-05:00","close_reason":"Implemented Story API with test ID sanitization"}
{"id":"spry-380","title":"Add findPRsByBranches batch lookup function","description":"Add a new function to `src/github/pr.ts` that fetches PR info for multiple branches in a single API call.\n\n## Implementation\n```typescript\nexport async function findPRsByBranches(\n  branchNames: string[],\n  options?: { includeAll?: boolean },\n): Promise\u003cMap\u003cstring, PRInfo | null\u003e\u003e\n```\n\n- Call `gh pr list --json number,url,state,title,headRefName` once (no `--head` filter)\n- Optionally include `--state all` for merged PR lookup\n- Filter results locally to match requested branches\n- Return a Map\u003cbranchName, PRInfo | null\u003e\n\n## Files\n- src/github/pr.ts","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-09T00:03:04.316566-05:00","updated_at":"2026-01-10T00:36:02.181098-05:00","closed_at":"2026-01-09T00:07:49.147285-05:00","close_reason":"Closed"}
{"id":"spry-3dn","title":"taspr-inmem-chain","description":"# In-Memory Commit Chain Rewrite\n\nImplement rewriting a chain of commits with new messages (e.g., adding trailers).\n\n## Function\n\n```typescript\ninterface CommitRewrite {\n  originalHash: string;\n  newMessage: string;\n}\n\nasync function rewriteCommitChain(\n  rewrites: CommitRewrite[],\n  options: GitOptions = {}\n): Promise\u003cstring\u003e  // Returns new tip SHA\n```\n\n## Algorithm\n\nFor a chain A -\u003e B -\u003e C where we want to change B's message:\n\n1. Find the first commit to rewrite and its parent (the \"base\")\n2. For each commit from base to tip:\n   - If commit needs rewriting: use new message\n   - Else: preserve original message\n   - Create new commit with `git commit-tree` using:\n     - Same tree as original\n     - Parent = previous new commit (or base if first)\n     - Author/committer env preserved\n3. Return new tip SHA\n\n## Key Insight\nWhen only changing messages, trees are unchanged, so we just rebuild parent relationships.\n\n## Usage\n- `injectMissingIds`: Add Taspr-Commit-Id to commits missing it\n- `applyGroupSpec`: Add/remove Taspr-Group trailers\n- `dissolveGroup`: Remove group trailers from specific commits\n\n## Tests\n- Single commit rewrite\n- Multiple commit chain rewrite\n- Mixed (some commits unchanged, some rewritten)\n- Preserves commits that don't need changes","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-08T22:10:38.777657-05:00","updated_at":"2026-01-08T22:46:14.168753-05:00","closed_at":"2026-01-08T22:46:14.168753-05:00","close_reason":"Closed","dependencies":[{"issue_id":"spry-3dn","depends_on_id":"spry-9nb","type":"blocks","created_at":"2026-01-08T22:10:43.012806-05:00","created_by":"don.denton"}]}
{"id":"spry-3pw","title":"Share PR data between interactive and main sync loops","description":"Optimize to avoid duplicate PR lookups between interactive mode and main sync loop.\n\nBoth loops need open PR status for the same branches. We can:\n1. Fetch once before interactive mode\n2. Pass the prMap through to the main sync loop\n3. Avoid duplicate lookups entirely\n\nThis reduces total API calls from 2 to 1 for the open PR case (cleanup still needs --state all).\n\n## Files\n- src/cli/commands/sync.ts","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-09T00:03:04.751683-05:00","updated_at":"2026-01-09T00:09:02.121236-05:00","closed_at":"2026-01-09T00:09:02.121236-05:00","close_reason":"Closed","dependencies":[{"issue_id":"spry-3pw","depends_on_id":"spry-7ie","type":"blocks","created_at":"2026-01-09T00:03:09.888949-05:00","created_by":"don.denton"}]}
{"id":"spry-3wu","title":"View command (local only)","description":"## Goal\nImplement the `taspr view` command to display stack structure in the terminal.\n\n## Background\nThis is the first user-facing command. It shows the current stack state based purely on local git data—no GitHub integration yet.\n\n## Output Format\n\n```\n$ taspr view\n\nStack: feature/auth (4 commits, 3 PRs)\n\n───────────────────────────────────────────────────────────────────────────\n  ○ Add user model\n    └─ a1b2c3d4\n───────────────────────────────────────────────────────────────────────────\n  ○ Authentication feature [f7e8d9c0]\n    ├─ b2c3d4e5 Add login endpoint\n    ├─ c3d4e5f6 Add password validation  \n    └─ d4e5f6a7 Add 2FA support\n───────────────────────────────────────────────────────────────────────────\n  ○ Add admin dashboard\n    └─ e5f6a7b8\n───────────────────────────────────────────────────────────────────────────\n  ↓ origin/main\n```\n\n### Elements\n- **Header**: Branch name, commit count, PR count (PRUnits)\n- **Separator**: Horizontal line between PRUnits\n- **Status indicator**: `○` for local-only (no PR). Later: `✓` merged, `◐` open, etc.\n- **Title**: Commit subject (single) or Group-Title (group)\n- **Group indicator**: `[group-id]` after title for groups\n- **Commits**: Tree structure showing commit IDs and subjects\n- **Footer**: Shows origin/main as the base\n\n## Implementation\n\n### Command Registration\n```typescript\n// src/cli/commands/view.ts\nimport { Command } from 'commander';\nimport { parseStack } from '../../core/stack';\nimport { formatStackView } from '../output';\n\nexport const viewCommand = new Command('view')\n  .description('Display status of current stack')\n  .action(async () =\u003e {\n    const result = await parseStack();\n    \n    if (!result.ok) {\n      // Show validation error\n      console.error(formatValidationError(result));\n      process.exit(1);\n    }\n    \n    console.log(formatStackView(result.units));\n  });\n```\n\n### Output Formatting\n```typescript\n// src/cli/output.ts\nexport function formatStackView(units: PRUnit[]): string {\n  // Build formatted output string\n}\n\nexport function formatValidationError(error: StackParseError): string {\n  // Format error with actionable message\n}\n```\n\n## Validation Error Display\n\nWhen groups are malformed, show helpful errors:\n\n```\n$ taspr view\n\n✗ Error: Unclosed group starting at commit b2c3d4e5\n\n  Group f7e8d9c0 (\"Auth feature\") has Taspr-Group-Start but no \n  matching Taspr-Group-End was found in subsequent commits.\n  \n  To fix, either:\n    1. Run `taspr group edit` to set the end boundary\n    2. Run `taspr group dissolve` to remove the incomplete group\n```\n\n## Edge Cases\n1. **Empty stack**: \"No commits ahead of origin/main\"\n2. **No origin/main**: Error with setup instructions\n3. **All commits in one group**: Show single PRUnit\n4. **Commits without IDs**: Show hash only, indicate sync needed\n\n## Testing Strategy\n1. Mock stack data and verify output formatting\n2. Test error formatting for various validation errors\n3. Integration test with real git repo\n\n## Files to Create/Modify\n- src/cli/commands/view.ts (create)\n- src/cli/output.ts (create) - Output formatting utilities\n- src/cli/index.ts (modify) - Register view command\n\n## Acceptance Criteria\n- [ ] Shows stack with all PRUnits\n- [ ] Correctly formats singles and groups\n- [ ] Shows validation errors clearly\n- [ ] Handles empty stack gracefully\n- [ ] Tree structure for group commits\n- [ ] Exit code 0 on success, 1 on validation error","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T14:23:56.483682-05:00","updated_at":"2026-01-10T00:36:02.203853-05:00","closed_at":"2025-12-26T01:28:05.134007-05:00","close_reason":"Implemented view command with formatStackView, formatValidationError, and getStackCommitsWithTrailers","dependencies":[{"issue_id":"spry-3wu","depends_on_id":"spry-67b","type":"parent-child","created_at":"2025-12-25T14:24:00.129571-05:00","created_by":"daemon"},{"issue_id":"spry-3wu","depends_on_id":"spry-919","type":"blocks","created_at":"2025-12-25T14:24:00.407869-05:00","created_by":"daemon"},{"issue_id":"spry-3wu","depends_on_id":"spry-919","type":"depends-on","created_at":"2025-12-25T14:24:00.407869-05:00","created_by":"daemon"}]}
{"id":"spry-3z71","title":"Enhance sync to fast-forward local default branch","description":"Add optional functionality to `sp sync` to update the local version of the default branch (e.g., `main`) when syncing.\n\n**Behavior:**\n- Check if local default branch and origin have diverged\n- If diverged: warn the user\n- If local is merely behind (no working tree changes): fast-forward local branch\n- This should work regardless of which branch is currently checked out\n\n**Scenarios to handle:**\n1. ✓ Working from main, in root repo tree (may already be covered by default sync behavior)\n2. ✓ Working from main, in a worktree (may already be covered by default sync behavior)\n3. Working from another branch, main is in root repo tree\n4. Working from another branch, main is in a worktree\n5. No local version of main exists → do nothing\n\n**Notes:**\n- The default branch detection should be dynamic (not hardcoded to `main`)\n- Should work with worktrees\n- Need to investigate if scenarios 1-2 are already handled by current sync implementation\n- Should be optional behavior (flag or config option?)\n\n**Implementation considerations:**\n- Use `git rev-list --left-right --count local_branch...origin/branch` to detect divergence\n- Use `git fetch` + `git update-ref` or `git branch -f` to fast-forward without checkout\n- Handle worktree detection with `git worktree list`","status":"open","priority":2,"issue_type":"feature","owner":"don.denton@trillianthealth.com","created_at":"2026-01-13T09:38:56.434776-05:00","created_by":"Don Denton","updated_at":"2026-01-13T09:38:56.434776-05:00"}
{"id":"spry-44e","title":"ID generation","description":"## Goal\nGenerate unique 8-character hex IDs for commits.\n\n## Implementation\n\n```typescript\n// src/core/id.ts\nimport { randomBytes } from 'crypto';\n\nexport function generateCommitId(): string {\n  return randomBytes(4).toString('hex');\n}\n```\n\n### Properties\n- 8 hex characters = 32 bits = 4 billion possibilities\n- Collision risk negligible for active stacks (typically \u003c 50 commits)\n- Once PRs merge, their IDs leave the active set\n\n### Usage Contexts\n1. `Taspr-Commit-Id` - Assigned to every commit\n2. `Taspr-Group-Start` / `Taspr-Group-End` - Marks group boundaries\n\nSame generation function, different semantic use.\n\n## Testing\n- Generate many IDs, verify format (8 hex chars)\n- Verify uniqueness over reasonable sample size\n\n## Files to Create\n- src/core/id.ts\n\n## Acceptance Criteria\n- [ ] Generates 8-character hex strings\n- [ ] Uses crypto for randomness\n- [ ] Has basic tests","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T14:24:45.726897-05:00","updated_at":"2026-01-10T00:36:02.189578-05:00","closed_at":"2025-12-26T21:03:50.523511-05:00","close_reason":"Implemented generateCommitId() in src/core/id.ts with tests","dependencies":[{"issue_id":"spry-44e","depends_on_id":"spry-sbb","type":"parent-child","created_at":"2025-12-25T14:24:49.603638-05:00","created_by":"daemon"}]}
{"id":"spry-4b6","title":"Branch name generation","description":"## Goal\nGenerate stable branch names for PRUnits following the pattern `\u003cprefix\u003e/\u003cusername\u003e/\u003cpr-id\u003e`.\n\n## Implementation\n\n```typescript\n// src/github/branches.ts\n\ninterface BranchNameConfig {\n  prefix: string;      // From git config or default \"taspr\"\n  username: string;    // From GitHub API\n}\n\nasync function getBranchNameConfig(): Promise\u003cBranchNameConfig\u003e {\n  // Get prefix from git config\n  const prefixResult = await $`git config --get taspr.branchPrefix`.nothrow();\n  const prefix = prefixResult.exitCode === 0 \n    ? prefixResult.stdout.toString().trim() \n    : 'taspr';\n  \n  // Get username from GitHub\n  const username = await $`gh api user --jq .login`.text();\n  \n  return { prefix, username: username.trim() };\n}\n\nfunction getBranchName(prId: string, config: BranchNameConfig): string {\n  return `${config.prefix}/${config.username}/${prId}`;\n}\n```\n\n### Examples\n```\ntaspr/msims/a1b2c3d4     # Default prefix, single commit\ntaspr/msims/f7e8d9c0     # Default prefix, group\njaspr/msims/a1b2c3d4     # Custom prefix via git config\n```\n\n### Configuration\n```bash\n# Set custom prefix\ngit config taspr.branchPrefix jaspr\n```\n\n## Caching\nUsername lookup is slow (network call). Cache within a sync operation:\n\n```typescript\nlet cachedConfig: BranchNameConfig | null = null;\n\nasync function getBranchNameConfig(): Promise\u003cBranchNameConfig\u003e {\n  if (cachedConfig) return cachedConfig;\n  // ... fetch\n  cachedConfig = config;\n  return config;\n}\n```\n\n## Testing\n- Default prefix generation\n- Custom prefix from git config\n- Valid branch name characters (pr-ids are hex, always safe)\n\n## Files to Create\n- src/github/branches.ts\n- src/git/config.ts (may already exist from Epic 1)\n\n## Acceptance Criteria\n- [ ] Generates branch names with correct pattern\n- [ ] Reads custom prefix from git config\n- [ ] Fetches username from GitHub API\n- [ ] Caches config within operation","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T14:26:47.651395-05:00","updated_at":"2026-01-10T00:36:02.167886-05:00","closed_at":"2025-12-26T23:29:21.511757-05:00","close_reason":"Implemented and tested","dependencies":[{"issue_id":"spry-4b6","depends_on_id":"spry-ce1","type":"parent-child","created_at":"2025-12-25T14:26:51.374607-05:00","created_by":"daemon"},{"issue_id":"spry-4b6","depends_on_id":"spry-74a","type":"blocks","created_at":"2025-12-25T14:27:05.963936-05:00","created_by":"daemon"},{"issue_id":"spry-4b6","depends_on_id":"spry-74a","type":"depends-on","created_at":"2025-12-25T14:27:05.963936-05:00","created_by":"daemon"}]}
{"id":"spry-4dq","title":"Land command (single PR)","description":"## Goal\nImplement `taspr land` to merge the bottom ready PR.\n\n## Implementation\n\n```typescript\n// src/cli/commands/land.ts\n\nexport const landCommand = new Command('land')\n  .description('Merge the bottom ready PR in the stack')\n  .option('--all', 'Merge all consecutive ready PRs')\n  .action(async (options) =\u003e {\n    // Parse stack and get PR info\n    const result = await parseStack();\n    if (!result.ok) {\n      console.error(formatValidationError(result));\n      process.exit(1);\n    }\n    \n    const config = await getBranchNameConfig();\n    const enrichedUnits = await enrichWithPRInfo(result.units, config);\n    \n    // Find bottom unmerged PR\n    const unmerged = enrichedUnits.filter(u =\u003e u.pr?.state === 'open');\n    if (unmerged.length === 0) {\n      console.log('No unmerged PRs in stack');\n      return;\n    }\n    \n    const bottom = unmerged[0];\n    \n    // Check if ready\n    const status = await getPRMergeStatus(bottom.pr!.number);\n    if (!status.mergeable) {\n      console.error(\\`✗ PR #\\${bottom.pr!.number} is not ready:\\\\n\\`);\n      if (status.checksStatus === 'failing') {\n        console.error('  • CI checks failing');\n      }\n      if (status.reviewDecision !== 'approved') {\n        console.error('  • Needs approval');\n      }\n      process.exit(1);\n    }\n    \n    // Merge\n    console.log(\\`Merging PR #\\${bottom.pr!.number} (\\${bottom.title})...\\`);\n    const result = await mergePR(bottom.pr!.number);\n    console.log(\\`✓ Merged PR #\\${bottom.pr!.number} to main\\`);\n  });\n```\n\n## Output\n\n### Success\n```\n$ taspr land\n\nMerging PR #142 (Add user model)...\n✓ Merged PR #142 to main\n```\n\n### Not Ready\n```\n$ taspr land\n\n✗ PR #142 is not ready:\n  • CI checks failing\n\nRun 'taspr view' to see status.\n```\n\n### No PRs\n```\n$ taspr land\n\nNo unmerged PRs in stack\n```\n\n## Testing\n- Land ready PR → success\n- Land non-ready PR → error with reason\n- Empty stack → appropriate message\n\n## Files to Create\n- src/cli/commands/land.ts\n\n## Acceptance Criteria\n- [ ] Merges bottom open PR when ready\n- [ ] Clear error when PR not ready\n- [ ] Reports success with PR number\n- [ ] Handles empty stack","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T14:31:28.590491-05:00","updated_at":"2026-01-10T00:36:02.163395-05:00","closed_at":"2025-12-30T14:11:15.979654-05:00","close_reason":"Implemented land command that merges the bottom open PR in the stack using fast-forward merge. Includes branch cleanup after successful merge and proper error handling for non-fast-forwardable PRs.","dependencies":[{"issue_id":"spry-4dq","depends_on_id":"spry-oef","type":"parent-child","created_at":"2025-12-25T14:31:32.341642-05:00","created_by":"daemon"},{"issue_id":"spry-4dq","depends_on_id":"spry-4zl","type":"depends-on","created_at":"2025-12-25T14:31:32.613862-05:00","created_by":"daemon"},{"issue_id":"spry-4dq","depends_on_id":"spry-4zl","type":"blocks","created_at":"2025-12-25T14:31:32.613862-05:00","created_by":"daemon"}]}
{"id":"spry-4iy","title":"Stack structure detection (PRUnit parsing)","description":"## Goal\nBuild a PRUnit[] array from commits, identifying which commits are singles and which belong to groups.\n\n## Background\nAfter parsing commits and their trailers, we need to understand the stack structure:\n- Commits without group trailers become individual PRUnits (type: 'single')\n- Commits between Taspr-Group-Start and Taspr-Group-End become one PRUnit (type: 'group')\n\n## Data Structures\n\n```typescript\ninterface PRUnit {\n  type: 'single' | 'group';\n  id: string;           // Taspr-Commit-Id (single) or group-id (group)\n  title: string;        // Commit subject (single) or Taspr-Group-Title (group)\n  commitIds: string[];  // All Taspr-Commit-Id values in this unit\n  commits: string[];    // Current git hashes\n}\n\ninterface CommitInfo {\n  hash: string;\n  subject: string;\n  body: string;\n  trailers: CommitTrailers;\n}\n```\n\n## Algorithm\n\n```typescript\nfunction detectPRUnits(commits: CommitInfo[]): PRUnit[] {\n  const units: PRUnit[] = [];\n  let currentGroup: Partial\u003cPRUnit\u003e | null = null;\n  \n  for (const commit of commits) {\n    const commitId = commit.trailers['Taspr-Commit-Id'];\n    const startId = commit.trailers['Taspr-Group-Start'];\n    const endId = commit.trailers['Taspr-Group-End'];\n    \n    if (startId \u0026\u0026 !currentGroup) {\n      // Start a new group\n      currentGroup = {\n        type: 'group',\n        id: startId,\n        title: commit.trailers['Taspr-Group-Title'] || commit.subject,\n        commitIds: [commitId],\n        commits: [commit.hash],\n      };\n    } else if (currentGroup) {\n      // Add to current group\n      currentGroup.commitIds!.push(commitId);\n      currentGroup.commits!.push(commit.hash);\n      \n      if (endId === currentGroup.id) {\n        // End of group\n        units.push(currentGroup as PRUnit);\n        currentGroup = null;\n      }\n    } else {\n      // Single commit\n      units.push({\n        type: 'single',\n        id: commitId,\n        title: commit.subject,\n        commitIds: [commitId],\n        commits: [commit.hash],\n      });\n    }\n  }\n  \n  // Handle unclosed group (validation error - covered in next task)\n  return units;\n}\n```\n\n## Edge Cases\n1. **Empty stack**: Return empty array\n2. **All singles**: Each commit becomes a PRUnit\n3. **All in one group**: One PRUnit with all commits\n4. **Mixed**: Singles and groups interspersed\n5. **Commit without Taspr-Commit-Id**: Still include (ID will be undefined, handled by sync later)\n\n## Testing Strategy\nTest with various commit arrangements:\n1. Three singles\n2. Three commits in one group\n3. Single, group of 2, single\n4. Group of 3, group of 2\n\n## Files to Create/Modify\n- src/core/stack.ts (create)\n\n## Acceptance Criteria\n- [ ] Correctly identifies single commits\n- [ ] Correctly identifies group boundaries\n- [ ] Preserves commit order (oldest first)\n- [ ] Handles commits without IDs gracefully\n- [ ] Has comprehensive tests for various scenarios","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T14:23:08.166742-05:00","updated_at":"2026-01-10T00:36:02.205212-05:00","closed_at":"2025-12-26T01:10:10.855841-05:00","close_reason":"Implemented detectPRUnits() in src/core/stack.ts with 10 passing tests","dependencies":[{"issue_id":"spry-4iy","depends_on_id":"spry-67b","type":"parent-child","created_at":"2025-12-25T14:23:12.019736-05:00","created_by":"daemon"},{"issue_id":"spry-4iy","depends_on_id":"spry-puc","type":"depends-on","created_at":"2025-12-25T14:23:12.300646-05:00","created_by":"daemon"},{"issue_id":"spry-4iy","depends_on_id":"spry-puc","type":"blocks","created_at":"2025-12-25T14:23:12.300646-05:00","created_by":"daemon"}]}
{"id":"spry-4jz","title":"Test new prefix","description":"Testing that new issues get spry- prefix","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-09T13:34:24.277718-05:00","updated_at":"2026-01-09T13:34:27.639902-05:00","closed_at":"2026-01-09T13:34:27.639902-05:00","close_reason":"Closed"}
{"id":"spry-4lh","title":"Git log parsing","description":"## Goal\nRead commits between HEAD and the merge-base with origin/main, extracting all relevant information.\n\n## Background\ntaspr needs to understand the stack of commits that will become PRs. The stack is:\n- All commits from HEAD back to (but not including) the merge-base with origin/main\n- Ordered from oldest to newest (bottom of stack = first to merge)\n\n## Implementation\n\n### Git Commands Needed\n```bash\n# Find merge-base\ngit merge-base HEAD origin/main\n\n# Get commits in stack (oldest first)\ngit log --reverse --format=\"%H%x00%s%x00%B\" \u003cmerge-base\u003e..HEAD\n```\n\n### Output Format\nUse null-byte separators for reliable parsing:\n- `%H` - commit hash\n- `%s` - subject line\n- `%B` - full body (includes subject)\n\n### Function Signature\n```typescript\ninterface CommitInfo {\n  hash: string;\n  subject: string;\n  body: string;\n}\n\nasync function getStackCommits(): Promise\u003cCommitInfo[]\u003e\n```\n\n### Edge Cases\n1. **No commits ahead of main**: Return empty array\n2. **No origin/main**: Error with helpful message\n3. **Detached HEAD**: Should still work\n4. **Merge commits in stack**: Include them (user's choice to have them)\n\n## Bun Shell Usage\n```typescript\nimport { $ } from \"bun\";\n\nconst mergeBase = await $`git merge-base HEAD origin/main`.text();\nconst log = await $`git log --reverse --format=\"%H%x00%s%x00%B%x00\" ${mergeBase.trim()}..HEAD`.text();\n```\n\n## Testing Strategy\nCreate a temporary git repository with known commits and verify parsing:\n1. Create temp dir\n2. git init\n3. Add commits with known subjects/bodies\n4. Call getStackCommits()\n5. Assert on results\n\n## Files to Create/Modify\n- src/git/commands.ts (create) - Git command wrapper with getStackCommits()\n\n## Acceptance Criteria\n- [ ] Returns commits in oldest-to-newest order\n- [ ] Correctly parses hash, subject, body\n- [ ] Handles empty stack (no commits ahead)\n- [ ] Handles repos without origin/main with clear error\n- [ ] Has tests with real git repos in temp directories","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T14:22:32.243959-05:00","updated_at":"2026-01-10T00:36:02.195888-05:00","closed_at":"2025-12-26T00:42:13.283588-05:00","close_reason":"Closed","dependencies":[{"issue_id":"spry-4lh","depends_on_id":"spry-67b","type":"parent-child","created_at":"2025-12-25T14:22:35.916747-05:00","created_by":"daemon"},{"issue_id":"spry-4lh","depends_on_id":"spry-4ny","type":"blocks","created_at":"2025-12-25T14:22:36.196173-05:00","created_by":"daemon"},{"issue_id":"spry-4lh","depends_on_id":"spry-4ny","type":"depends-on","created_at":"2025-12-25T14:22:36.196173-05:00","created_by":"daemon"}]}
{"id":"spry-4ny","title":"Project scaffolding and CLI setup","description":"## Goal\nSet up the Bun project structure, dependencies, and basic CLI scaffolding.\n\n## Tasks\n\n### 1. Initialize Bun project\n- Update package.json with proper metadata\n- Add dependencies: commander\n- Add devDependencies: @types/bun (already present)\n- Configure bun build for CLI compilation\n\n### 2. Create directory structure\n```\nsrc/\n├── cli/\n│   ├── index.ts          # Entry point\n│   └── commands/         # Command implementations\n├── core/                 # Business logic\n├── git/                  # Git operations\n└── types.ts              # Shared types\ntests/\n├── helpers/              # Test utilities\n└── ...                   # Test files\n```\n\n### 3. Set up CLI with Commander\n- Create main entry point at src/cli/index.ts\n- Configure program name, version, description\n- Add placeholder commands: view, sync, land, group\n- Ensure `bun run src/cli/index.ts` works\n\n### 4. Configure TypeScript\n- Strict mode enabled (already in tsconfig.json)\n- Path aliases if needed\n- Ensure types work with Bun\n\n### 5. Set up test infrastructure\n- Configure bun:test\n- Create test helper for creating temporary git repositories\n- Add test scripts to package.json\n\n### 6. Add build script\n- `bun build --compile` for standalone binary\n- Cross-platform target support\n\n## Acceptance Criteria\n- [ ] Running `bun run src/cli/index.ts --help` shows help\n- [ ] Running `bun run src/cli/index.ts view` shows placeholder message\n- [ ] Running `bun test` executes a sample test\n- [ ] TypeScript compiles without errors\n\n## Files to Create/Modify\n- package.json (modify)\n- src/cli/index.ts (create)\n- src/cli/commands/view.ts (create - placeholder)\n- src/types.ts (create - empty or with basic interfaces)\n- tests/helpers/git-fixture.ts (create)\n- tests/sample.test.ts (create - simple test)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T14:22:10.925801-05:00","updated_at":"2026-01-10T00:36:02.172402-05:00","closed_at":"2025-12-25T23:42:42.674094-05:00","close_reason":"Closed","dependencies":[{"issue_id":"spry-4ny","depends_on_id":"spry-67b","type":"parent-child","created_at":"2025-12-25T14:22:18.35922-05:00","created_by":"daemon"}]}
{"id":"spry-4r0f","title":"clean: detect and remove dangling branches on active stacks","description":"Extend the clean command to detect dangling branches on active stacks. This can happen when a PR was opened toward the end of a stack, but has been removed/moved, leaving some commits with remote branches that have no open PRs targeting them. The clean command should identify and offer to remove these orphaned branches.","status":"open","priority":3,"issue_type":"task","owner":"don.denton@trillianthealth.com","created_at":"2026-01-13T21:29:23.680452-05:00","created_by":"Don Denton","updated_at":"2026-01-13T21:29:28.23953-05:00"}
{"id":"spry-4zl","title":"PR merge via GitHub API","description":"## Goal\nMerge a PR using the GitHub API via gh CLI.\n\n## Implementation\n\n```typescript\n// src/github/pr.ts\n\ntype MergeMethod = 'merge' | 'squash' | 'rebase';\n\ninterface MergeResult {\n  sha: string;      // Merge commit SHA\n  merged: boolean;\n}\n\nasync function mergePR(\n  prNumber: number,\n  method?: MergeMethod\n): Promise\u003cMergeResult\u003e {\n  // Use gh CLI to merge\n  const methodFlag = method ? \\`--\\${method}\\` : '';\n  \n  const result = await $\\`gh pr merge \\${prNumber} \\${methodFlag} --json sha,state\\`.nothrow();\n  \n  if (result.exitCode !== 0) {\n    const error = result.stderr.toString();\n    if (error.includes('not mergeable')) {\n      throw new PRNotMergeableError(prNumber);\n    }\n    throw new GitHubAPIError(\\`Failed to merge PR #\\${prNumber}: \\${error}\\`);\n  }\n  \n  const data = JSON.parse(result.stdout.toString());\n  return { sha: data.sha, merged: true };\n}\n```\n\n### Checking Mergeability\n```typescript\ninterface PRMergeStatus {\n  mergeable: boolean;\n  mergeableState: string;\n  checksStatus: 'pending' | 'passing' | 'failing';\n  reviewDecision: 'approved' | 'review_required' | 'changes_requested';\n}\n\nasync function getPRMergeStatus(prNumber: number): Promise\u003cPRMergeStatus\u003e {\n  const result = await $\\`gh pr view \\${prNumber} --json mergeable,mergeStateStatus,reviewDecision,statusCheckRollup\\`;\n  const data = JSON.parse(result.stdout.toString());\n  \n  return {\n    mergeable: data.mergeable === 'MERGEABLE',\n    mergeableState: data.mergeStateStatus,\n    checksStatus: getChecksStatus(data.statusCheckRollup),\n    reviewDecision: data.reviewDecision?.toLowerCase() || 'review_required',\n  };\n}\n```\n\n## Error Handling\n- PR not found → clear error\n- PR not mergeable → explain why (conflicts, checks, reviews)\n- Network error → retry logic\n\n## Testing\n- Successful merge\n- Merge blocked by checks\n- Merge blocked by reviews\n- Merge blocked by conflicts\n\n## Files to Modify\n- src/github/pr.ts\n\n## Acceptance Criteria\n- [ ] Merges PR via gh CLI\n- [ ] Returns merge commit SHA\n- [ ] Clear errors for non-mergeable PRs\n- [ ] Respects repo's merge settings","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T14:30:56.060186-05:00","updated_at":"2026-01-10T00:36:02.164152-05:00","closed_at":"2025-12-30T00:47:30.077665-05:00","close_reason":"Implemented landPR() function that fast-forwards target branch to PR head commit, preserving commit hashes. Uses git push directly instead of GitHub merge API. Includes canFastForward check and deleteRemoteBranch helper.","dependencies":[{"issue_id":"spry-4zl","depends_on_id":"spry-oef","type":"parent-child","created_at":"2025-12-25T14:30:59.702866-05:00","created_by":"daemon"}]}
{"id":"spry-51o","title":"Safety and robustness improvements","status":"closed","priority":2,"issue_type":"epic","created_at":"2026-01-10T00:26:43.987125-05:00","created_by":"don.denton","updated_at":"2026-01-10T00:27:34.241813-05:00","closed_at":"2026-01-10T00:27:34.241813-05:00","close_reason":"Created by mistake, using existing Polish epic instead"}
{"id":"spry-5esj","title":"group --fix should list commits to help user understand the issue","description":"When running 'sp group --fix', the error summary shows the group name and that commits are non-contiguous, but doesn't list the actual commits involved. This makes it hard for users to understand:\n\n1. Which commits belong to the split group\n2. Which commits are interrupting the group\n3. How they might want to reorganize things\n\nThe fix should show the commit list (hash + subject) for both the group commits and the interrupting commits, similar to how formatValidationError already shows abbreviated hashes but with more detail in the interactive repair flow.","status":"open","priority":3,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-17T00:35:45.809204-05:00","created_by":"Don Denton","updated_at":"2026-01-17T00:35:51.969774-05:00"}
{"id":"spry-5ky","title":"Audit all taspr workflows for edge cases","description":"## Goal\n\nSystematically review all taspr workflows and identify edge cases that could cause errors or unexpected behavior. Use Opus 4.5 to think through scenarios methodically.\n\n## Workflow Areas to Audit\n\n### 1. Stack Operations\n- Creating commits on feature branch\n- Rebasing stack onto updated main\n- Cherry-picking commits\n- Amending commits in middle of stack\n- Reordering commits\n\n### 2. Group Operations\n- Creating groups (taspr group)\n- Splitting groups\n- Nested groups (if possible)\n- Groups spanning entire stack\n- Single-commit groups\n\n### 3. Sync Operations\n- First sync (no IDs yet)\n- Subsequent syncs (updating existing PRs)\n- Sync after rebase\n- Sync after amending grouped commits\n- Sync with dirty working tree\n- Sync during merge conflict\n\n### 4. Temp Commits (WIP, fixup!, etc.)\n- Single temp commit\n- Temp commit in stack\n- Multiple temp commits\n- Grouped temp commits\n- Squashing after grouping (see spry-ei6)\n\n### 5. PR Lifecycle\n- PR created → changes pushed\n- PR merged → cleanup\n- PR closed without merge\n- Stale PRs (branch deleted manually)\n- PR retargeting after base merged\n\n### 6. ID Management\n- ID injection during sync\n- ID preservation during rebase\n- ID conflicts (same ID on different commits)\n- Missing IDs after external rebase\n\n### 7. Branch Naming\n- Username changes\n- Prefix changes mid-stack\n- Branch name collisions\n\n### Questions to Answer\n\n- What stack/group states are valid vs invalid?\n- Where does taspr need guardrails or auto-repair?\n- What error messages should users see for invalid states?\n- Should any operations be blocked preemptively?\n\n## Related Issues\n\n- spry-ei6: Fix group integrity when fixup! commits are squashed\n\n## Output\n\nDocument findings as new beads issues for specific fixes needed.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-03T14:18:08.620633-05:00","updated_at":"2026-01-10T00:36:02.197961-05:00","dependencies":[{"issue_id":"spry-5ky","depends_on_id":"spry-ei6","type":"relates-to","created_at":"2026-01-03T14:18:19.833166-05:00","created_by":"dondenton"}]}
{"id":"spry-5lf","title":"Create CHANGELOG.md with Keep a Changelog format","description":"Create changelog with summarized retroactive entries for alpha.1-4 releases. Use Keep a Changelog format with [Unreleased] section at top.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-09T10:13:49.096751-05:00","updated_at":"2026-01-10T00:36:02.179922-05:00","closed_at":"2026-01-09T10:14:18.973981-05:00","close_reason":"Closed"}
{"id":"spry-5zx","title":"Add test log files showing full taspr CLI output for UI review","description":"Create log files during test runs that capture the full textual output of all `taspr` CLI invocations. This allows reviewing the UI rendering in all states without running tests manually.\n\n## Implementation Ideas\n- Write output to files in a `test-logs/` or `test-output/` directory\n- Include timestamp and test name in log entries\n- Capture both stdout and stderr\n- Show the command that was run along with its output\n\n## Output Format Example\n```\n=== test: view command shows stack ===\n$ taspr view\nStack: feature/auth (3 commits, PRs: 2/3 opened)\n\n  → origin/main\n────────────────────────────────────────────────────────────────────────\n  ◐ #142 Add user model\n    └─ taspr-abc\n    https://github.com/owner/repo/pull/142\n...\n```\n\n## Acceptance Criteria\n- [ ] All integration tests log their CLI output\n- [ ] Logs are organized by test file/suite\n- [ ] Output is human-readable for UI review\n- [ ] Logs can be git-ignored or committed for review","status":"closed","priority":3,"issue_type":"task","created_at":"2025-12-31T14:39:39.068921-05:00","updated_at":"2026-01-10T00:36:02.166398-05:00","closed_at":"2026-01-05T00:34:03.022072-05:00"}
{"id":"spry-66n","title":"Add story logging to remaining integration tests","description":"Read the parent epic spry-mbn for full context.\n\n## Task\nAdd story logging to the remaining integration test files, following the pattern established in sync.test.ts (spry-w74).\n\n## Files to Update\n- tests/integration/land.test.ts\n- tests/integration/clean.test.ts  \n- tests/integration/group-fix.test.ts\n- tests/integration/pr-status.test.ts\n\n## Pattern\nSame as sync.test.ts - see spry-w74 for the exact pattern.\n\n## Acceptance\n- All integration test files have story annotations\n- Running TASPR_STORY_TEST_LOGGING=1 bun test tests/integration/ produces markdown files for each test file","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-05T00:33:28.022045-05:00","updated_at":"2026-01-10T00:36:02.168866-05:00","closed_at":"2026-01-09T11:58:17.363085-05:00","close_reason":"Closed","dependencies":[{"issue_id":"spry-66n","depends_on_id":"spry-w74","type":"blocks","created_at":"2026-01-05T00:33:48.205808-05:00","created_by":"dondenton"}]}
{"id":"spry-67b","title":"Epic 1: Read Stack from Git","description":"## Goal\nParse a local git branch into a structured representation of commits and groups.\n\n## Background\n\ntaspr is a Bun-powered CLI tool for managing stacked PRs on GitHub. The fundamental model is:\n- **Each commit = one PR** by default\n- **Groups** bundle multiple contiguous commits into a single PR\n\nThis epic establishes the foundation: reading git history and understanding the stack structure before any GitHub integration.\n\n## Core Concepts\n\n### Stack\nA linear sequence of commits on a branch between HEAD and the merge-base with origin/main. Each commit potentially maps to a PR.\n\n### Group\nA contiguous range of commits that should be treated as a single PR. Defined by trailers:\n- `Taspr-Group-Start: \u003c8-hex-id\u003e` on the first commit\n- `Taspr-Group-Title: \u003ctitle\u003e` on the first commit (PR title)\n- `Taspr-Group-End: \u003csame-8-hex-id\u003e` on the last commit\n\n### Commit Identity\nEvery commit gets a `Taspr-Commit-Id` trailer (8 hex characters) that survives rebases. This is how taspr tracks commits across history rewrites.\n\n### PRUnit\nThe logical unit that maps to a PR:\n- **Single**: One commit = one PR. ID is the Taspr-Commit-Id, title is commit subject.\n- **Group**: Multiple commits = one PR. ID is the group-id, title is Taspr-Group-Title.\n\n## Deliverable\nRunning `taspr view` outputs a tree of commits showing which belong to groups and which are standalone. No GitHub integration yet—purely local git data.\n\n## Key Data Structures\n\n```typescript\ninterface CommitInfo {\n  hash: string;\n  subject: string;\n  body: string;\n  trailers: Record\u003cstring, string\u003e;\n}\n\ninterface PRUnit {\n  type: 'single' | 'group';\n  id: string;           // Taspr-Commit-Id (single) or group-id (group)\n  title: string;        // Commit subject (single) or Taspr-Group-Title (group)\n  commitIds: string[];  // All Taspr-Commit-Id values in this unit\n  commits: string[];    // Current git hashes\n}\n\ntype StackParseResult = \n  | { ok: true; units: PRUnit[] }\n  | { ok: false; error: 'unclosed-group'; groupId: string; startCommit: string }\n  | { ok: false; error: 'overlapping-groups'; group1: GroupInfo; group2: GroupInfo; overlappingCommit: string }\n```\n\n## Technical Decisions\n- **CLI Framework**: Commander (good TypeScript support, works with Bun)\n- **Runtime**: Bun (fast TypeScript execution, native test runner)\n- **Git commands**: Bun Shell ($\\`\\`) for safe command execution\n\n## Testable Outcome\n`taspr view` shows commits, identifies groups, reports validation errors for malformed groups.\n\n## File Structure for This Epic\n```\nsrc/\n├── cli/\n│   ├── index.ts          # Entry point with Commander\n│   └── commands/\n│       └── view.ts       # View command implementation\n├── core/\n│   └── stack.ts          # Stack parsing, PRUnit detection\n├── git/\n│   ├── commands.ts       # Git command wrapper\n│   └── trailers.ts       # Trailer parsing\n└── types.ts              # TypeScript interfaces\ntests/\n├── helpers/\n│   └── git-fixture.ts    # Test utilities for temp repos\n└── core/\n    └── stack.test.ts     # Stack parsing tests\n```","status":"closed","priority":1,"issue_type":"epic","created_at":"2025-12-25T14:21:57.996735-05:00","updated_at":"2026-01-10T00:36:02.172771-05:00","closed_at":"2025-12-26T01:28:13.837115-05:00","close_reason":"All 6 child tasks completed: project scaffolding, git log parsing, trailer parsing, PRUnit detection, group validation, view command"}
{"id":"spry-6q3","title":"Unified group TUI","description":"## Goal\nImplement a unified interactive TUI for `taspr group` that allows users to reorder commits and assign groups in a single interface.\n\n## Context\nThis replaces the originally planned separate `group create/edit` commands with a single unified experience. The TUI displays all commits in the stack and allows:\n- Reordering commits (via move mode)\n- Assigning commits to groups (A, B, C, ... Z)\n- Previewing conflict risks before committing changes\n\n## UX Design\n\n### Normal Mode\n```\nGroup Editor - 4 commits\n\n  → origin/main\n\n  ─ a1b2c3d4  Add user model           ← cursor (highlighted)\n  A e5f6a7b8  Add login endpoint\n  A c9d0e1f2  Add password validation\n  B 12345678  Add dashboard\n\n─────────────────────────────────────────\nGroups: A (2 commits), B (1 commit)\n↑↓ navigate │ Space move mode │ ←→ group │ Enter confirm │ Esc cancel\n```\n\n### Move Mode (after pressing Space)\n```\nGroup Editor - 4 commits [MOVE MODE]\n\n  → origin/main\n\n  ─ a1b2c3d4  Add user model\n» A e5f6a7b8  Add login endpoint       ← MOVING (different color)\n  A c9d0e1f2  Add password validation\n  B 12345678  Add dashboard\n\n─────────────────────────────────────────\n↑↓ swap position │ Space exit move mode │ ←→ disabled\n```\n\n## Controls\n- **Up/Down arrows**:\n  - Normal mode: Move cursor between commits\n  - Move mode: Swap selected commit with adjacent commit\n- **Space**: Toggle \"move mode\" on current commit\n- **Left/Right arrows**: Cycle group assignment (only works in normal mode)\n  - Left-most = ungrouped (─)\n  - Right cycles: A → B → C → ... → Z → ungrouped\n- **Enter**: Confirm, prompt for group names, perform rebase\n- **Esc**: Cancel without changes\n\n## Key Behaviors\n- Only ONE commit can be in \"move mode\" at a time\n- Left/Right arrows are disabled while a commit is in move mode\n- Single-commit groups ARE allowed\n- On confirm: prompt for group names, then immediate git rebase\n- Group trailers are added after rebase\n\n## Implementation Phases\n\n### Phase 1: Terminal Utilities\nCreate `src/tui/terminal.ts`:\n- `enableRawMode()` / `disableRawMode()`\n- `parseKeypress(data: Buffer)` → `{ name, ctrl, shift }`\n- ANSI escape helpers: `clearScreen()`, `moveCursor()`, `colors`\n\n### Phase 2: State Management\nCreate `src/tui/state.ts`:\n```typescript\ninterface TUIState {\n  commits: CommitDisplay[];       // Current order (may differ from original)\n  cursor: number;                 // Current cursor position\n  moveMode: number | null;        // Index of commit in move mode (null = normal mode)\n  groups: Map\u003cnumber, string | null\u003e;  // index → 'A'|'B'|...|null\n}\n```\n- `moveCursor(state, 'up'|'down')` - move cursor in normal mode\n- `toggleMoveMode(state)` - enter/exit move mode for cursor commit\n- `swapCommit(state, direction)` - swap commit in move mode with adjacent\n- `cycleGroup(state, 'left'|'right')` - change group (only in normal mode)\n\n### Phase 3: Rendering\nCreate `src/tui/render.ts`:\n- `renderScreen(state): string`\n- Match existing output patterns from `src/cli/output.ts`\n\n### Phase 4: TUI Main Loop\nCreate `src/tui/group-editor.ts`:\n- Fetch commits with `getStackCommitsWithTrailers()`\n- Validate stack with `parseStack()` - exit if errors\n- Initialize state from existing commits/groups\n- Render loop with raw stdin\n- On move: check for conflicts (see conflict-predict issue)\n- On Enter: exit raw mode, prompt for group names, call rebase logic\n\n### Phase 5: CLI Integration\nCreate `src/cli/commands/group.ts`:\n- `groupCommand()` - launch TUI\n\nUpdate `src/cli/index.ts`:\n```typescript\nconst groupCmd = program.command(\"group\").description(\"Manage commit groups\");\ngroupCmd.action(groupCommand);  // default action launches TUI\ngroupCmd.command(\"dissolve\").argument(\"[group]\").action(dissolveCommand);\n```\n\n## Files to Create\n- src/tui/terminal.ts\n- src/tui/state.ts\n- src/tui/render.ts\n- src/tui/group-editor.ts\n- src/cli/commands/group.ts\n\n## Files to Modify\n- src/cli/index.ts (replace placeholder group command)\n\n## Technical Approach\n**TUI Library**: Raw terminal handling with Node.js `readline` (Bun compatible). No external TUI library needed. Use `process.stdin.setRawMode(true)` for key input.\n\n## Testing\n- Unit tests for state transitions in state.test.ts\n- Unit tests for key parsing in terminal.test.ts\n- Unit tests for rendering in render.test.ts\n- Manual testing across terminal emulators (iTerm2, Terminal.app, VS Code)\n\n## Edge Cases\n1. **Empty stack**: Show message and exit\n2. **Single commit**: Allow grouping (creates single-commit group)\n3. **Existing groups**: Show in initial state, allow modification\n4. **Non-TTY**: Detect `process.stdin.isTTY` and show error\n\n## Acceptance Criteria\n- [ ] TUI launches and displays commits\n- [ ] Arrow key navigation works\n- [ ] Move mode allows reordering commits\n- [ ] Left/Right cycles group assignment\n- [ ] Enter prompts for group names\n- [ ] Esc cancels without changes\n- [ ] Works in common terminal emulators","notes":"## Testing Workflow\nAfter completing implementation:\n1. Run `bun run build` to build the CLI\n2. Run `bun test --no-coverage` to verify all tests pass\n3. Tell the user to run `bun run scenario` and select one of these scenarios for manual testing:\n   - **multiCommitStack** - 3 commits on feature branch (best for testing TUI navigation and reordering)\n   - **withTasprIds** - 2 commits with existing Taspr-Commit-Id trailers (test group assignment)\n   - **emptyStack** - Test empty state handling\n\n## Scenario Usage\nThe `bun run scenario` command spawns a shell in a temp git repo with `taspr` in PATH. The agent should:\n1. Run `bun run build` \n2. Tell the user: \"Run `bun run scenario` and select **multiCommitStack** to test the TUI\"\n\nAfter testing, type `exit` to clean up the temp repo.\n\n## New Scenarios Needed\nAdd to `src/scenario/definitions.ts`:\n- **withGroups** - Stack with existing group trailers (Taspr-Group-Start/End/Title) for testing group editing\n- **singleCommitStack** - Single commit on feature branch for edge case testing","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-01T22:47:20.422051-05:00","updated_at":"2026-01-10T00:36:02.178421-05:00","closed_at":"2026-01-02T10:19:10.556857-05:00","close_reason":"Closed","dependencies":[{"issue_id":"spry-6q3","depends_on_id":"spry-r22","type":"parent-child","created_at":"2026-01-01T22:48:51.367927-05:00","created_by":"daemon"},{"issue_id":"spry-6q3","depends_on_id":"spry-0bl","type":"blocks","created_at":"2026-01-01T22:48:56.67974-05:00","created_by":"daemon"},{"issue_id":"spry-6q3","depends_on_id":"spry-fx7","type":"blocks","created_at":"2026-01-01T22:48:56.959636-05:00","created_by":"daemon"}]}
{"id":"spry-6yt","title":"Fix n×n GitHub API calls in sp view","description":"sp view makes 3 parallel API calls (checks, reviews, comments) PER PR in the stack. A stack of 10 PRs fires 30 concurrent GitHub API calls.\n\n**Problem locations:**\n- src/cli/commands/view.ts lines 21-25: Promise.all([getPRChecksStatus, getPRReviewStatus, getPRCommentStatus]) inside Promise.all(units.map(...))\n\n**Impact:**\n- Hammers GitHub API unnecessarily\n- Risk of rate limiting on moderate-sized stacks\n- Slower than necessary (could batch)\n\n**Fix approach:**\n1. Use batch API calls where possible (gh api with GraphQL can fetch multiple PRs at once)\n2. Or serialize calls with concurrency limit\n3. findPRsByBranches() already shows the batch pattern - fetch all in one call\n\n**Related:** spry-hi9 (rate limiting) depends on reducing call volume first.","status":"closed","priority":0,"issue_type":"bug","created_at":"2026-01-10T14:57:35.145442-05:00","created_by":"dondenton","updated_at":"2026-01-10T15:28:33.489326-05:00","closed_at":"2026-01-10T15:28:33.489326-05:00","close_reason":"Implemented batch API calls - 47% reduction in GitHub API calls for sp view"}
{"id":"spry-74a","title":"GitHub username detection","description":"## Goal\nGet the current user's GitHub username for branch naming.\n\n## Implementation\n\n```typescript\n// src/github/api.ts\n\nasync function getGitHubUsername(): Promise\u003cstring\u003e {\n  const result = await $\\`gh api user --jq .login\\`.nothrow();\n  \n  if (result.exitCode !== 0) {\n    throw new GitHubAuthError(\n      'Failed to get GitHub username. Ensure gh CLI is installed and authenticated.\\n' +\n      'Run: gh auth login'\n    );\n  }\n  \n  return result.stdout.toString().trim();\n}\n```\n\n### Error Handling\nThe `gh api user` command fails if:\n1. `gh` CLI is not installed\n2. User is not authenticated\n3. Network issues\n\nProvide clear error messages for each case.\n\n### gh CLI Dependency\ntaspr delegates all GitHub auth to `gh`. This means:\n- No token management in taspr\n- User's existing `gh` auth works automatically\n- Enterprise GitHub works if configured in `gh`\n\n### Check for gh Installation\n```typescript\nasync function ensureGhInstalled(): Promise\u003cvoid\u003e {\n  const result = await $\\`which gh\\`.nothrow();\n  if (result.exitCode !== 0) {\n    throw new DependencyError(\n      'gh CLI not found. Please install it:\\n' +\n      '  brew install gh          # macOS\\n' +\n      '  apt install gh           # Ubuntu\\n' +\n      '  https://cli.github.com   # Other'\n    );\n  }\n}\n```\n\n## Testing\n- Mock successful gh api response\n- Mock gh not installed\n- Mock gh not authenticated\n\n## Files to Create\n- src/github/api.ts\n\n## Acceptance Criteria\n- [ ] Returns GitHub username\n- [ ] Clear error if gh not installed\n- [ ] Clear error if gh not authenticated\n- [ ] Error messages include remediation steps","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T14:27:02.008649-05:00","updated_at":"2026-01-10T00:36:02.167558-05:00","closed_at":"2025-12-26T23:29:21.498338-05:00","close_reason":"Implemented and tested","dependencies":[{"issue_id":"spry-74a","depends_on_id":"spry-ce1","type":"parent-child","created_at":"2025-12-25T14:27:05.694237-05:00","created_by":"daemon"}]}
{"id":"spry-75b4","title":"'sp sync' should sync current branch onto origin/main","description":"Currently, 'sp sync' behavior may not be clearly defined or may not properly sync the current branch with the remote main branch.\n\nWe need 'sp sync' to:\n1. Sync (rebase or merge) the current branch onto the equivalent of origin/main\n2. Handle the user's configured default branch name (main, master, etc.)\n3. Handle the user's configured remote name (origin, upstream, github, etc.)\n4. Provide clear feedback about what sync operation was performed\n5. Handle conflicts gracefully with helpful error messages\n\nThis makes 'sp sync' a convenient command for keeping feature branches up-to-date with the main development branch.","status":"open","priority":2,"issue_type":"feature","owner":"don.denton@trillianthealth.com","created_at":"2026-01-16T12:33:50.939236-05:00","created_by":"Don Denton","updated_at":"2026-01-16T12:33:50.939236-05:00","dependencies":[{"issue_id":"spry-75b4","depends_on_id":"spry-sicu","type":"relates-to","created_at":"2026-01-16T12:36:31.456019-05:00","created_by":"Don Denton"}]}
{"id":"spry-77v","title":"gh CLI dependency checks","description":"## Remaining Work\n\nThe core gh CLI check (`ensureGhInstalled`) exists and is called before all GitHub operations. What's missing:\n\n### 1. Caching\nCurrently `ensureGhInstalled` checks `which gh` on every call. Should cache the result after first successful check.\n\n```typescript\nlet ghChecked = false;\n\nexport async function ensureGhInstalled(): Promise\u003cvoid\u003e {\n  if (ghChecked) return;\n  // ... existing check ...\n  ghChecked = true;\n}\n```\n\n### 2. Explicit Authentication Check\nCurrently authentication failures are caught when API calls fail. Could add explicit `gh auth status` check for clearer error messages.\n\n### 3. Repository Access Check\nCould add check for `gh repo view` to detect when user doesn't have access to the current repo.\n\n## What's Already Done\n- ✅ `ensureGhInstalled()` function exists in `src/github/api.ts`\n- ✅ Called before all GitHub operations in `pr.ts` and `view.ts`\n- ✅ Clear installation instructions for macOS, Linux, other\n- ✅ Error class `DependencyError` for missing gh\n- ✅ Error class `GitHubAuthError` for auth failures","status":"open","priority":4,"issue_type":"task","created_at":"2025-12-25T14:49:31.737179-05:00","updated_at":"2026-01-08T22:37:11.645728-05:00"}
{"id":"spry-784w","title":"Allow 'sp group' to run even when group errors are detected","description":"Currently, when spry detects group errors (e.g., orphaned commits, mismatched metadata), it forces users to run 'sp group --fix' and prevents them from running 'sp group' normally.\n\nThis is unnecessarily restrictive. Users should be able to run 'sp group' to inspect the current state and manually fix issues if they prefer, rather than being forced into the automated fix flow.\n\nWe should:\n1. Allow 'sp group' to execute even when errors are present\n2. Display a warning about detected errors but still show the group information\n3. Suggest 'sp group --fix' as an option, but don't block manual inspection/fixes\n\nThis gives users more control and flexibility when dealing with group inconsistencies.","status":"closed","priority":2,"issue_type":"bug","owner":"don.denton@trillianthealth.com","created_at":"2026-01-16T12:31:00.94085-05:00","created_by":"Don Denton","updated_at":"2026-01-17T00:26:40.134329-05:00","closed_at":"2026-01-17T00:26:40.134329-05:00","close_reason":"Changed group-editor.ts to show warning but continue launching TUI when errors detected"}
{"id":"spry-78q","title":"README and documentation","description":"## Goal\nCreate comprehensive README and documentation for users to understand and use taspr.\n\n## README.md Structure\n\n```markdown\n# taspr\n\nStacked PR management for GitHub. Each commit becomes a PR, properly stacked.\n\n## What is taspr?\n\ntaspr manages \"stacked PRs\" - a workflow where you create a chain of dependent pull requests, each building on the one before it. This enables:\n\n- **Incremental reviews**: Small, focused PRs are easier to review\n- **Logical commits**: Keep your local history clean and meaningful\n- **Fast iteration**: Land PRs as they\\'re approved without waiting for the whole stack\n\n## Quick Start\n\n\\`\\`\\`bash\n# Install\ncurl -fsSL https://raw.githubusercontent.com/OWNER/taspr/main/install.sh | bash\n\n# In your repo, create some commits\ngit commit -m \"Add user model\"\ngit commit -m \"Add user API endpoints\"\ngit commit -m \"Add user UI components\"\n\n# View your stack\ntaspr view\n\n# Push to GitHub as stacked PRs\ntaspr sync\n\n# After bottom PR is approved, land it\ntaspr land\n\\`\\`\\`\n\n## Prerequisites\n\n- **git** - You probably have this\n- **gh** - GitHub CLI for authentication ([install](https://cli.github.com))\n\n## Installation\n\n### Quick Install (recommended)\n\\`\\`\\`bash\ncurl -fsSL https://raw.githubusercontent.com/OWNER/taspr/main/install.sh | bash\n\\`\\`\\`\n\n### Manual Download\nDownload the appropriate binary from [Releases](https://github.com/OWNER/taspr/releases):\n- macOS Intel: `taspr-darwin-x64`\n- macOS Apple Silicon: `taspr-darwin-arm64`\n- Linux x64: `taspr-linux-x64`\n- Linux ARM64: `taspr-linux-arm64`\n\n## How It Works\n\n### The Stack Model\n\nBy default, each commit in your branch becomes its own PR:\n\n\\`\\`\\`\nmain\n  │\n  ├── Commit A  →  PR #1 (base: main)\n  │     │\n  │     └── Commit B  →  PR #2 (base: PR #1\\'s branch)\n  │           │\n  │           └── Commit C  →  PR #3 (base: PR #2\\'s branch)\n\\`\\`\\`\n\nWhen PR #1 merges, GitHub automatically retargets PR #2 to main.\n\n### Commit Tracking\n\ntaspr adds a trailer to each commit to track it across rebases:\n\\`\\`\\`\nfeat: add user authentication\n\nTaspr-Commit-Id: a1b2c3d4\n\\`\\`\\`\n\n### Groups (Optional)\n\nGroup multiple commits into a single PR:\n\\`\\`\\`bash\ntaspr group create\n# Select commits interactively\n\\`\\`\\`\n\n## Commands\n\n### `taspr view`\nShow your current stack structure and PR status.\n\n\\`\\`\\`bash\ntaspr view          # Current branch\ntaspr view --all    # All branches with stacks\n\\`\\`\\`\n\n### `taspr sync`\nPush your stack to GitHub, creating or updating PRs.\n\n\\`\\`\\`bash\ntaspr sync          # Push and create PRs\ntaspr sync --open   # Also open new PRs in browser\n\\`\\`\\`\n\n### `taspr land`\nMerge the bottom PR to main.\n\n\\`\\`\\`bash\ntaspr land          # Land bottom ready PR\ntaspr land --all    # Land all consecutive ready PRs\n\\`\\`\\`\n\n### `taspr group`\nManage commit groups.\n\n\\`\\`\\`bash\ntaspr group create    # Create a new group\ntaspr group edit      # Edit existing group\ntaspr group dissolve  # Remove a group\n\\`\\`\\`\n\n## Configuration\n\ntaspr uses git config for settings:\n\n\\`\\`\\`bash\n# Branch prefix (default: taspr)\ngit config taspr.prefix mystacks\n\n# Default base branch (default: detected from origin)\ngit config taspr.baseBranch main\n\\`\\`\\`\n\n## Tips\n\n### Amending Commits\nAfter amending a commit, run `taspr sync` to update the corresponding PR.\n\n### Rebasing\nWhen you rebase, commit IDs are preserved (they\\'re in trailers, not hashes). Just `taspr sync` after rebasing.\n\n### Inserting Commits\nAdd a commit anywhere in your stack, then `taspr sync`. New commits automatically get their own PRs.\n\n## Troubleshooting\n\n### \"gh not authenticated\"\nRun `gh auth login` to authenticate with GitHub.\n\n### \"Cannot sync - uncommitted changes\"\nCommit or stash your changes before running sync.\n\n### PRs showing wrong diff\nThis usually means your stack got out of sync. Run `taspr sync` to update all PR branches.\n\n## License\n\nMIT\n\\`\\`\\`\n\n## Additional Documentation\n\n### CLAUDE.md (for AI-assisted development)\n```markdown\n# taspr\n\nBun-powered stacked PR CLI for GitHub.\n\n## Commands\n\\`\\`\\`bash\nbun run dev          # Watch mode\nbun run build        # Build all platform binaries\nbun run test         # Run tests\nbun run typecheck    # Type validation\n\\`\\`\\`\n\n## Structure\n- src/cli/ - Command implementations\n- src/core/ - Business logic\n- src/git/ - Git operations\n- src/github/ - GitHub API via gh CLI\n- src/types.ts - TypeScript interfaces\n\n## Conventions\n- Strict TypeScript\n- Bun Shell ($\\`\\`) for git commands\n- Tests mirror src/ structure\n- gh CLI for all GitHub operations\n\\`\\`\\`\n\n## Acceptance Criteria\n- [ ] README explains what taspr is and why to use it\n- [ ] Quick start gets users going in \u003c2 minutes\n- [ ] All commands documented with examples\n- [ ] Troubleshooting covers common issues\n- [ ] Installation instructions for all platforms\n- [ ] CLAUDE.md helps AI-assisted development\n- [ ] Configuration options documented","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-25T15:01:25.505428-05:00","updated_at":"2026-01-10T00:36:02.16454-05:00","dependencies":[{"issue_id":"spry-78q","depends_on_id":"spry-do5","type":"parent-child","created_at":"2025-12-25T15:01:37.920096-05:00","created_by":"daemon"}]}
{"id":"spry-7a5","title":"Enhanced view formatting with status indicators","description":"## Goal\nUpdate view output to show blocking indicators for each PR.\n\n## Implementation\n\n```typescript\n// src/cli/output.ts\n\ninterface PRStatusInfo {\n  checks: 'pending' | 'passing' | 'failing';\n  review: 'approved' | 'changes_requested' | 'pending';\n  comments: { total: number; resolved: number };\n}\n\nfunction formatBlockingIndicators(status: PRStatusInfo): string {\n  const indicators: string[] = [];\n  \n  // Comment threads\n  if (status.comments.total \u003e 0 \u0026\u0026 status.comments.resolved \u003c status.comments.total) {\n    indicators.push(\\`💬 \\${status.comments.resolved}/\\${status.comments.total}\\`);\n  }\n  \n  // CI checks\n  if (status.checks === 'pending') {\n    indicators.push('⏳ checks');\n  } else if (status.checks === 'failing') {\n    indicators.push('✗ checks');\n  }\n  \n  // Review status\n  if (status.review === 'pending') {\n    indicators.push('👀 review');\n  } else if (status.review === 'changes_requested') {\n    indicators.push('✗ review');\n  }\n  \n  return indicators.join('  ');\n}\n```\n\n## Output Format\n```\n  ◐ #143 Authentication feature            💬 3/5  ⏳ checks\n```\n\nThe indicators are right-aligned after the title.\n\n## Testing\n- PR with multiple blocking indicators\n- PR with single indicator\n- PR with no blockers (shows nothing extra)\n\n## Files to Modify\n- src/cli/output.ts\n- src/cli/commands/view.ts\n\n## Acceptance Criteria\n- [ ] Shows comment thread status\n- [ ] Shows CI check status\n- [ ] Shows review status\n- [ ] Clean formatting with proper alignment","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-25T14:32:59.785483-05:00","updated_at":"2026-01-10T00:36:02.193269-05:00","closed_at":"2025-12-31T13:39:34.02718-05:00","close_reason":"Implemented status indicators in view command showing comment threads, CI checks, and review status for open PRs","dependencies":[{"issue_id":"spry-7a5","depends_on_id":"spry-7qh","type":"parent-child","created_at":"2025-12-25T14:33:04.509152-05:00","created_by":"daemon"},{"issue_id":"spry-7a5","depends_on_id":"spry-ceg","type":"blocks","created_at":"2025-12-25T14:33:04.785797-05:00","created_by":"daemon"},{"issue_id":"spry-7a5","depends_on_id":"spry-ceg","type":"depends-on","created_at":"2025-12-25T14:33:04.785797-05:00","created_by":"daemon"},{"issue_id":"spry-7a5","depends_on_id":"spry-xnf","type":"blocks","created_at":"2025-12-25T14:33:05.057758-05:00","created_by":"daemon"},{"issue_id":"spry-7a5","depends_on_id":"spry-xnf","type":"depends-on","created_at":"2025-12-25T14:33:05.057758-05:00","created_by":"daemon"},{"issue_id":"spry-7a5","depends_on_id":"spry-dcq","type":"blocks","created_at":"2025-12-25T14:33:05.327966-05:00","created_by":"daemon"},{"issue_id":"spry-7a5","depends_on_id":"spry-dcq","type":"depends-on","created_at":"2025-12-25T14:33:05.327966-05:00","created_by":"daemon"}]}
{"id":"spry-7dul","title":"Only push branches up to the last opened PR in a stack","description":"Current behavior: sp sync --open -i pushes all commits as branches even when only early commits are selected for PR opening. This wastes API calls and creates unnecessary branches.\n\nExpected behavior:\n- Only push branches for commits that have PRs OR are between the base and a commit with a PR\n- Example 1: 5 commits, only commit 1 has PR → push only 1 branch\n- Example 2: 5 commits, commits 1 and 4 have PRs → push 4 branches (1st with PR, 2nd-3rd without PR as they're dependencies, 4th with PR). The 5th should not be pushed.\n\nThis is especially wasteful when selectively opening PRs with --open -i and choosing only early commits in a large stack (e.g., 1 PR opened but 19 branches pushed unnecessarily).","status":"closed","priority":1,"issue_type":"bug","owner":"don.denton@trillianthealth.com","created_at":"2026-01-12T17:10:31.101492-05:00","created_by":"Don Denton","updated_at":"2026-01-16T22:29:49.859719-05:00","closed_at":"2026-01-13T21:45:56.957831-05:00"}
{"id":"spry-7ie","title":"Refactor interactive mode to use batch lookup","description":"Refactor the interactive mode build loop in sync.ts to use batch PR lookup.\n\n## Before (sequential, lines 243-256)\n```typescript\nfor (const unit of activeUnits) {\n  const existingPR = await findPRByBranch(headBranch);\n}\n```\n\n## After (batch)\n```typescript\nconst branchNames = activeUnits.map(u =\u003e getBranchName(u.id, branchConfig));\nconst prMap = await findPRsByBranches(branchNames);\nfor (const unit of activeUnits) {\n  const existingPR = prMap.get(getBranchName(unit.id, branchConfig)) ?? null;\n}\n```\n\n## Files\n- src/cli/commands/sync.ts (lines 240-265)","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-09T00:03:04.540644-05:00","updated_at":"2026-01-09T00:09:02.115399-05:00","closed_at":"2026-01-09T00:09:02.115399-05:00","close_reason":"Closed"}
{"id":"spry-7n0a","title":"Support merge commits in grouped PRs","description":"Add support for creating true merge commits within grouped PRs, allowing branches to split and rejoin in the DAG while maintaining the ability to fast-forward merge to the default branch.\n\n## Overview\n\nEnable users to create branch-and-merge structures within a single PR group using the group editor. Commits can be indented to create branches, with automatic merge commit generation to rejoin the main line. Multiple branch-and-merge sections can exist within a single PR group.\n\n## Key Features\n\n1. **Visual UI in group editor:** Use ←→ arrows in move mode to indent/outdent commits\n2. **Automatic merge commits:** System creates merge commits to rejoin branches\n3. **Multi-value trailers:** Track merge parents using `Spry-Merge-Parents` trailers\n4. **Rebase preservation:** All rebase operations preserve merge commit structure\n5. **PR disclaimers:** PRs with merge commits list which commits are merges\n6. **Recovery command:** `sp group --recover` rebuilds flattened merge commits\n\n## Visual Example\n\n```\nBefore indent:\n  A commit 1\n  A commit 2\n  A commit 3\n  A commit 4\n\nAfter indenting commits 2-3:\n  A commit 1\n    A commit 2         (indented, branches off)\n    A commit 3         (indented)\n  A [merge] Merge      (rejoins main line)\n  A commit 4\n```\n\n## DAG Structure\n- commit 1 → commit 2 (branch point)\n- commit 2 → commit 3\n- commit 3 → merge commit\n- commit 1 → merge commit (second parent)\n- merge commit → commit 4\n\n## Validation Rules\n\n1. Branch-and-merge groups must be within same PR group\n2. A single PR group can contain multiple branch-and-merge sections\n3. Indenting commits without a group auto-creates a PR group\n4. No nested merges initially (single level: 0 or 1)\n5. Moving commits in move mode allows sliding into/out of branches\n\n## Implementation Phases\n\n1. Data model: Add parent tracking and multi-value trailers\n2. Git operations: Update rebase plumbing to preserve merge commits\n3. UI: Add indent/outdent in group editor (placeholder merges initially)\n4. PR: Add merge commit disclaimer\n5. Integration: Connect UI to git operations (make merges real)\n6. Testing and documentation\n7. Recovery: Add `sp group --recover` command\n\n## Critical Design Decisions\n\n- Use ←→ in move mode (unused currently) for indent/outdent\n- Merge commits use `Spry-Merge-Parents` trailer referencing commit IDs\n- Preserve merge tree during rebase (no re-merge)\n- Merge commits auto-generated but user-editable after creation\n- PR disclaimer lists all merge commits by subject (not just final)","status":"open","priority":2,"issue_type":"epic","owner":"don.denton@trillianthealth.com","created_at":"2026-01-13T11:34:35.05565-05:00","created_by":"Don Denton","updated_at":"2026-01-13T11:34:35.05565-05:00"}
{"id":"spry-7nt","title":"Handle GitHub token expiration mid-operation","description":"GitHub CLI authentication can expire mid-operation. No mechanism to detect and recover from 401 Unauthorized responses. Add detection and prompt user to re-authenticate.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-10T00:28:13.034882-05:00","created_by":"don.denton","updated_at":"2026-01-10T00:28:13.034882-05:00","dependencies":[{"issue_id":"spry-7nt","depends_on_id":"spry-do5","type":"parent-child","created_at":"2026-01-10T01:04:18.613708-05:00","created_by":"don.denton"}]}
{"id":"spry-7qh","title":"Epic 6: View PR Status from GitHub","description":"## Goal\nShow rich status information from GitHub in `taspr view`.\n\n## Background\nAfter the MVP (Epics 1-5), taspr can create and land PRs. This epic enhances feedback by showing:\n- CI check status\n- Review approval status\n- Comment thread resolution\n\nThis helps users know at a glance whether PRs are ready to land.\n\n## Enhanced View Output\n\n```\n$ taspr view\n\nStack: feature/auth (4 commits, 3 PRs)\n\n───────────────────────────────────────────────────────────────────────────\n  ✓ #142 Add user model\n    └─ a1b2c3d4\n    https://github.com/org/repo/pull/142\n───────────────────────────────────────────────────────────────────────────\n  ◐ #143 Authentication feature            💬 3/5  ⏳ checks\n    ├─ b2c3d4e5 Add login endpoint\n    ├─ c3d4e5f6 Add password validation  \n    └─ d4e5f6a7 Add 2FA support\n    https://github.com/org/repo/pull/143\n───────────────────────────────────────────────────────────────────────────\n  ◐ #144 Add admin dashboard               👀 review\n    └─ e5f6a7b8\n    https://github.com/org/repo/pull/144\n───────────────────────────────────────────────────────────────────────────\n  ↓ origin/main\n```\n\n### Status Indicators\n- `✓` Merged\n- `◐` Open\n- `○` No PR yet\n- `✗` Closed (not merged)\n- `!` Conflict or error state\n\n### Blocking Indicators\n- `💬 3/5` — 3 of 5 comment threads resolved\n- `⏳ checks` — CI checks still running\n- `✗ checks` — CI checks failed\n- `👀 review` — Awaiting review approval\n\n## Deliverable\n`taspr view` shows check status, review status, and comment resolution for each PR.\n\n## Dependencies\n- Epic 4 must be complete (view command with basic PR info)\n\n## Priority\nP2 - Enhancement after MVP is complete.","status":"closed","priority":2,"issue_type":"epic","created_at":"2025-12-25T14:32:11.233973-05:00","updated_at":"2026-01-10T00:36:02.171194-05:00","closed_at":"2025-12-31T14:40:45.00116-05:00","close_reason":"All children completed","dependencies":[{"issue_id":"spry-7qh","depends_on_id":"spry-d0k","type":"blocks","created_at":"2025-12-25T14:32:14.956989-05:00","created_by":"daemon"},{"issue_id":"spry-7qh","depends_on_id":"spry-d0k","type":"depends-on","created_at":"2025-12-25T14:32:14.956989-05:00","created_by":"daemon"}]}
{"id":"spry-7rq","title":"Flaky test: clean amended commit detection via trailer","description":"## Failed Test\n```\nGitHub Integration: clean command \u003e Amended commit detection via trailer\n```\n\n## How to Run\n```bash\nGITHUB_INTEGRATION_TESTS=1 bun test tests/integration/clean.test.ts -t 'Amended commit detection'\n```\n\n## Error\n```\nExpected to contain: \"commit-id\"\nReceived: \"Scanning for orphaned branches...\\n\\n✓ No orphaned branches found\\n\"\n```\n\n## Analysis\nThe test expects `sp clean` to find orphaned branches via commit-id trailer matching, but no orphaned branches were found.\n\n**Root cause suspicion:** This could be:\n1. Race condition - previous test cleanup didn't complete, or branches weren't pushed in time\n2. Test isolation issue - leftover state from other tests\n3. Timing issue - branch creation/detection timing\n\nThe test creates a branch, syncs, amends the commit (changing the SHA but keeping the Spry-Commit-Id), and expects clean to detect the orphaned branch via the trailer.\n\n**Fix approach:** Add explicit waits/verification that branches exist before running clean, or investigate the branch state at time of failure.\n\n## Location\ntests/integration/clean.test.ts:271","status":"closed","priority":0,"issue_type":"bug","created_at":"2026-01-10T15:26:15.776413-05:00","created_by":"dondenton","updated_at":"2026-01-10T16:14:48.168107-05:00","closed_at":"2026-01-10T16:14:48.168107-05:00","close_reason":"Fixed: see commit"}
{"id":"spry-7s6","title":"Clean command for orphaned branches and PRs","description":"## Goal\nCreate a `taspr clean` command that finds and removes orphaned branches and PRs that are no longer needed.\n\n## Background\nAfter PRs are merged (either via `taspr land` or GitHub UI), there may be orphaned:\n- Remote branches matching our naming pattern (e.g., `taspr/\u003cusername\u003e/\u003ccommit-id\u003e`)\n- Closed/merged PRs whose branches still exist\n\nThe `sync` command now handles cleanup for PRs that are in the local stack, but there may be orphaned branches from:\n- PRs merged on other machines\n- Branches pushed but never turned into PRs\n- Old stacks that were abandoned\n\n## Implementation\n\n### Branch Pattern\nTaspr branches follow the pattern: `taspr/\u003cusername\u003e/\u003c8-char-id\u003e`\n\n### Detection Logic\n1. List all remote branches matching `taspr/*` pattern\n2. For each branch:\n   - Check if the branch's HEAD commit is reachable from the default branch (merged)\n   - If merged, the branch is orphaned and can be deleted\n3. Optionally also find and close any open PRs for those branches\n\n### Command Interface\n```\ntaspr clean [--dry-run] [--include-prs]\n\nOptions:\n  --dry-run      Show what would be cleaned without actually deleting\n  --include-prs  Also close any open PRs for orphaned branches (default: only delete branches)\n```\n\n### Output\n```\n$ taspr clean --dry-run\n\nFound 3 orphaned branches:\n  taspr/user/a1b2c3d4 (merged to main)\n  taspr/user/e5f6g7h8 (merged to main)\n  taspr/user/i9j0k1l2 (merged to main)\n\nRun without --dry-run to delete these branches.\n\n$ taspr clean\n\n✓ Deleted 3 orphaned branches:\n  taspr/user/a1b2c3d4\n  taspr/user/e5f6g7h8\n  taspr/user/i9j0k1l2\n```\n\n## Testing\nWrite integration tests that:\n1. Create branches and PRs\n2. Merge PRs via GitHub API (simulating GitHub UI merge without branch deletion)\n3. Run `taspr clean` and verify orphaned branches are detected/deleted\n4. Use the existing `github-fixture.ts` pattern for GitHub integration tests\n\n## Files to Create/Modify\n- src/cli/commands/clean.ts (new)\n- src/cli/index.ts (add command)\n- tests/integration/clean.test.ts (new)\n\n## Acceptance Criteria\n- [ ] Detects orphaned branches matching taspr pattern\n- [ ] Correctly identifies merged branches (commit reachable from default branch)\n- [ ] --dry-run shows what would be deleted without deleting\n- [ ] Deletes orphaned branches when run without --dry-run\n- [ ] Integration test covers the full workflow","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-31T00:37:02.656048-05:00","updated_at":"2026-01-10T00:36:02.1781-05:00","closed_at":"2025-12-31T13:47:36.955276-05:00","close_reason":"Implementation already complete with all acceptance criteria met: clean command in src/cli/commands/clean.ts, registered in CLI, and comprehensive integration tests in tests/integration/clean.test.ts"}
{"id":"spry-7v1","title":"Optimize PR status lookups in sync command","description":"`taspr sync --open -i` is slow because PR status is fetched sequentially for each commit.\n\nEach call to `findPRByBranch` spawns a separate `gh pr list` command. With N commits, there are up to 3N sequential API calls:\n1. `cleanupMergedPRs` loop (N calls)\n2. Interactive mode build loop (N calls)  \n3. Main sync loop (N calls)\n\nWith typical GitHub API latency (100-500ms), 10 commits = 3-15 seconds of just PR lookups.\n\n## Solution\nCreate a batch lookup function `findPRsByBranches` that fetches PR info for multiple branches in a single `gh pr list` call, then filters locally.\n\n## Expected Impact\n- Before: 3N sequential `gh` CLI calls\n- After: 2 total `gh` CLI calls\n- ~10-50x faster for typical stacks","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-09T00:02:50.820705-05:00","updated_at":"2026-01-10T00:36:02.181465-05:00","closed_at":"2026-01-09T00:10:13.064162-05:00","close_reason":"Closed"}
{"id":"spry-89a","title":"Move group PR titles from commit trailers to git ref storage","description":"## Summary\n\nDecouple PR titles from commit trailers by storing group titles in `refs/taspr/\u003cuser\u003e/group-titles` (a JSON blob) instead of the `Taspr-Group-Title` trailer. The `Taspr-Group` trailer remains for identifying which commits belong together.\n\n## Key Benefits\n- PR titles can be changed independently of commits\n- Syncable across machines via `taspr sync` (auto push/fetch of user's ref)\n- Per-user namespace avoids conflicts between collaborators\n- Once a PR is opened on GitHub, local changes won't overwrite it\n\n## Implementation Plan\n\n### 1. Create new module: `src/git/group-titles.ts`\n\nNew file for reading/writing group titles to `refs/taspr/\u003cuser\u003e/group-titles`.\n\nKey functions:\n- `getGroupTitlesRef()` - Returns refs/taspr/\u003cgithub-username\u003e/group-titles\n- `readGroupTitles()` / `writeGroupTitles()` - Read/write JSON blob\n- `getGroupTitle()` / `setGroupTitle()` / `deleteGroupTitle()` - Per-group operations\n- `pushGroupTitles()` / `fetchGroupTitles()` - Sync with remote\n\nUser identification via `gh api user --jq .login`.\n\nStorage mechanism:\n```bash\n# Write\necho '{\"group-abc\": \"PR Title\"}' | git hash-object -w --stdin\ngit update-ref refs/taspr/\u003cuser\u003e/group-titles \u003csha\u003e\n\n# Read\ngit cat-file blob refs/taspr/\u003cuser\u003e/group-titles\n\n# Sync\ngit push origin refs/taspr/\u003cuser\u003e/group-titles\ngit fetch origin refs/taspr/\u003cuser\u003e/group-titles:refs/taspr/\u003cuser\u003e/group-titles\n```\n\n### 2. Update `src/types.ts`\nRemove `inconsistent-group-title` error variant from StackParseResult.\n\n### 3. Update `src/git/trailers.ts`\nRemove `Taspr-Group-Title` from CommitTrailers interface.\n\n### 4. Update `src/core/stack.ts`\n- `detectPRUnits()`: Add titles parameter\n- `parseStack()`: Remove title inconsistency validation\n\n### 5. Update `src/git/group-rebase.ts`\n- `applyGroupSpec()`: Stop writing title trailer, use setGroupTitle()\n- `dissolveGroup()`: Add deleteGroupTitle() call\n- `updateGroupTitle()`: Simplify to just setGroupTitle()\n- Purge orphaned titles when groups are merged\n\n### 6. Update `src/tui/group-editor.ts`\nLoad/save titles from ref storage instead of trailers.\n\n### 7. Update `src/cli/commands/sync.ts`\n- fetchGroupTitles() at start\n- pushGroupTitles() at end\n- Pass titles to parseStack()\n\n### 8. Update `src/cli/commands/group.ts`\nRemove inconsistent-title error handling and repairInconsistentTitles().\n\n### 9. Update tests\nRemove inconsistent-title test cases, add group-titles.test.ts.\n\n## Files to Modify\n- src/git/group-titles.ts (NEW)\n- src/types.ts\n- src/git/trailers.ts\n- src/core/stack.ts\n- src/git/group-rebase.ts\n- src/tui/group-editor.ts\n- src/cli/commands/sync.ts\n- src/cli/commands/group.ts\n\n## Edge Cases\n- Missing ref: return empty object\n- Corrupted JSON: log warning, return empty object\n- Title not found: fall back to first commit's subject\n- Sync conflicts: user resolves manually\n- Orphaned titles: purge when groups merged/dissolved","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-04T00:16:47.230504-05:00","updated_at":"2026-01-10T00:36:02.196515-05:00","closed_at":"2026-01-04T14:04:08.856076-05:00","close_reason":"Closed"}
{"id":"spry-8cz","title":"Add rollback/recovery for partial sync failures","description":"If sp sync crashes mid-way (after pushing branches but before creating PRs), orphaned remote branches remain with no rollback or recovery guidance. Need transaction-like behavior or at minimum clear recovery instructions.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-10T00:28:12.465249-05:00","created_by":"don.denton","updated_at":"2026-01-10T14:43:49.21918-05:00","closed_at":"2026-01-10T14:43:49.21918-05:00","close_reason":"Punted on transaction-like rollback - folded into spry-1jo (error messages) to provide clear recovery guidance instead","dependencies":[{"issue_id":"spry-8cz","depends_on_id":"spry-do5","type":"parent-child","created_at":"2026-01-10T01:04:18.290175-05:00","created_by":"don.denton"}]}
{"id":"spry-8mh","title":"Build for all platforms - macOS and Linux binaries","description":"## Goal\nBuild standalone taspr binaries for macOS and Linux using Bun\\'s `bun build --compile` feature.\n\n## Target Platforms\n\n| Platform | Architecture | Target Flag | Binary Name |\n|----------|-------------|-------------|-------------|\n| macOS Intel | x64 | `--target=bun-darwin-x64` | taspr-darwin-x64 |\n| macOS Apple Silicon | ARM64 | `--target=bun-darwin-arm64` | taspr-darwin-arm64 |\n| Linux | x64 | `--target=bun-linux-x64` | taspr-linux-x64 |\n| Linux | ARM64 | `--target=bun-linux-arm64` | taspr-linux-arm64 |\n\nWindows support deferred - most stacked PR workflows are macOS/Linux.\n\n## Bun Compile Basics\n\n```bash\n# Single platform (current)\nbun build --compile src/cli/index.ts --outfile taspr\n\n# Cross-compile for specific target\nbun build --compile --target=bun-darwin-arm64 src/cli/index.ts --outfile taspr-darwin-arm64\n\n# With bytecode for faster startup (experimental)\nbun build --compile --bytecode src/cli/index.ts --outfile taspr\n```\n\n## Binary Size Expectations\n- macOS: ~51MB (includes Bun runtime)\n- Linux: ~50MB\n- These are larger than Go binaries but acceptable for dev tools\n\n## Build Script\n\n```typescript\n// scripts/build.ts\nimport { $ } from 'bun';\n\nconst targets = [\n  { name: 'darwin-x64', target: 'bun-darwin-x64' },\n  { name: 'darwin-arm64', target: 'bun-darwin-arm64' },\n  { name: 'linux-x64', target: 'bun-linux-x64' },\n  { name: 'linux-arm64', target: 'bun-linux-arm64' },\n];\n\nconst entrypoint = 'src/cli/index.ts';\nconst outdir = 'dist';\n\nawait $`mkdir -p ${outdir}`;\n\nfor (const { name, target } of targets) {\n  console.log(`Building for ${name}...`);\n  await $`bun build --compile --target=${target} ${entrypoint} --outfile ${outdir}/taspr-${name}`;\n  console.log(`  ✓ dist/taspr-${name}`);\n}\n\nconsole.log('\\nAll builds complete\\!');\n```\n\n## package.json Scripts\n\n```json\n{\n  \"scripts\": {\n    \"build\": \"bun run scripts/build.ts\",\n    \"build:local\": \"bun build --compile src/cli/index.ts --outfile dist/taspr\",\n    \"build:darwin-arm64\": \"bun build --compile --target=bun-darwin-arm64 src/cli/index.ts --outfile dist/taspr-darwin-arm64\",\n    \"build:darwin-x64\": \"bun build --compile --target=bun-darwin-x64 src/cli/index.ts --outfile dist/taspr-darwin-x64\",\n    \"build:linux-x64\": \"bun build --compile --target=bun-linux-x64 src/cli/index.ts --outfile dist/taspr-linux-x64\",\n    \"build:linux-arm64\": \"bun build --compile --target=bun-linux-arm64 src/cli/index.ts --outfile dist/taspr-linux-arm64\"\n  }\n}\n```\n\n## GitHub Actions for Releases\n\n```yaml\n# .github/workflows/release.yml\nname: Release\n\non:\n  push:\n    tags:\n      - 'v*'\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      \n      - uses: oven-sh/setup-bun@v1\n        with:\n          bun-version: latest\n      \n      - run: bun install\n      \n      - run: bun run build\n      \n      - name: Create Release\n        uses: softprops/action-gh-release@v1\n        with:\n          files: |\n            dist/taspr-darwin-x64\n            dist/taspr-darwin-arm64\n            dist/taspr-linux-x64\n            dist/taspr-linux-arm64\n```\n\n## Version Embedding\n\n```typescript\n// src/version.ts\n// This file is updated by build script\nexport const VERSION = '0.1.0';\nexport const BUILD_DATE = '2025-01-01';\nexport const COMMIT_SHA = 'abc1234';\n```\n\nBuild script can update this from git:\n```typescript\nconst version = await $`git describe --tags --always`.text();\nconst sha = await $`git rev-parse --short HEAD`.text();\n```\n\n## Testing Binaries\n\nTest each platform binary:\n```bash\n# On appropriate platform\n./dist/taspr-darwin-arm64 --version\n./dist/taspr-darwin-arm64 --help\n./dist/taspr-darwin-arm64 view\n```\n\nCross-platform testing via Docker for Linux binaries.\n\n## Acceptance Criteria\n- [ ] `bun run build` produces all 4 platform binaries\n- [ ] `bun run build:local` produces binary for current platform\n- [ ] Binaries are standalone (no external dependencies except git, gh)\n- [ ] --version shows correct version info\n- [ ] GitHub Actions workflow builds on tag push\n- [ ] Binaries are attached to GitHub releases\n- [ ] dist/ is in .gitignore","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-25T14:50:24.67684-05:00","updated_at":"2026-01-08T22:33:51.662638-05:00","closed_at":"2026-01-08T22:33:51.662638-05:00","close_reason":"Release workflow exists and v0.1.0-alpha.1 was published with all platform binaries"}
{"id":"spry-8ut","title":"Strip repo test IDs from story output","description":"The story output currently shows repo test IDs like `[lucky-dolphin-4rg]` in commit messages, but these should be stripped out for cleaner documentation.\n\n## Current Output\n```\nGroup \"First grouped commit [lucky-dolphin-4rg]\" (group-sp) has non-contiguous commits.\n```\n\n## Expected Output\n```\nGroup \"First grouped commit\" (group-sp) has non-contiguous commits.\n```\n\n## Implementation\nUpdate `sanitizeTestId()` in `tests/helpers/story.ts` to also strip out these IDs from:\n- Commit message titles in group names\n- Any other places where `[test-id]` appears in output\n\nThe function already handles some ID stripping but misses the bracketed IDs in the middle of strings.","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-09T12:06:56.798992-05:00","updated_at":"2026-01-09T21:51:28.006839-05:00","closed_at":"2026-01-09T21:51:28.006839-05:00","close_reason":"Closed"}
{"id":"spry-919","title":"Group validation (overlapping and unclosed)","description":"## Goal\nDetect and report malformed groups: overlapping groups and unclosed groups.\n\n## Background\nGroups must follow strict rules:\n1. **No overlapping**: A group cannot start inside another group\n2. **Must close**: Every Taspr-Group-Start must have a matching Taspr-Group-End\n\nValidation happens during stack parsing and should return clear, actionable errors.\n\n## Error Types\n\n```typescript\ntype StackParseResult = \n  | { ok: true; units: PRUnit[] }\n  | { ok: false; error: 'unclosed-group'; groupId: string; startCommit: string; groupTitle: string }\n  | { ok: false; error: 'overlapping-groups'; \n      group1: { id: string; title: string; startCommit: string };\n      group2: { id: string; title: string; startCommit: string };\n      overlappingCommit: string }\n```\n\n## Validation Algorithm\n\n```typescript\nfunction validateAndDetectPRUnits(commits: CommitInfo[]): StackParseResult {\n  let activeGroup: { id: string; title: string; start: string } | null = null;\n  \n  for (const commit of commits) {\n    const startId = commit.trailers['Taspr-Group-Start'];\n    const endId = commit.trailers['Taspr-Group-End'];\n    \n    // Check for overlapping groups\n    if (startId \u0026\u0026 activeGroup \u0026\u0026 startId !== activeGroup.id) {\n      return {\n        ok: false,\n        error: 'overlapping-groups',\n        group1: activeGroup,\n        group2: { \n          id: startId, \n          title: commit.trailers['Taspr-Group-Title'] || commit.subject,\n          startCommit: commit.hash \n        },\n        overlappingCommit: commit.hash,\n      };\n    }\n    \n    if (startId \u0026\u0026 !activeGroup) {\n      activeGroup = { \n        id: startId, \n        title: commit.trailers['Taspr-Group-Title'] || commit.subject,\n        start: commit.hash \n      };\n    }\n    \n    if (endId \u0026\u0026 activeGroup \u0026\u0026 endId === activeGroup.id) {\n      activeGroup = null;\n    }\n  }\n  \n  // Check for unclosed group\n  if (activeGroup) {\n    return {\n      ok: false,\n      error: 'unclosed-group',\n      groupId: activeGroup.id,\n      startCommit: activeGroup.start,\n      groupTitle: activeGroup.title,\n    };\n  }\n  \n  // If validation passes, run detection\n  return { ok: true, units: detectPRUnits(commits) };\n}\n```\n\n## Error Messages (for CLI)\n\n### Unclosed Group\n```\n✗ Error: Unclosed group starting at commit b2c3d4e5\n\n  Group f7e8d9c0 (\"Auth feature\") has Taspr-Group-Start but no \n  matching Taspr-Group-End was found in subsequent commits.\n  \n  To fix, either:\n    1. Run `taspr group edit` to set the end boundary\n    2. Run `taspr group dissolve` to remove the incomplete group\n```\n\n### Overlapping Groups\n```\n✗ Error: Overlapping groups detected\n\n  Group \"Auth feature\" (f7e8d9c0):\n    starts at b2c3d4e5\n\n  Group \"Login flow\" (a9b8c7d6):\n    starts at c3d4e5f6 (inside \"Auth feature\")\n\n  To fix, run `taspr group edit` to adjust the ranges.\n```\n\n## Testing Strategy\n1. Valid stack with no groups\n2. Valid stack with one group\n3. Valid stack with multiple non-overlapping groups\n4. Unclosed group (Start but no End)\n5. Overlapping groups (Start inside another Start)\n6. End without Start (malformed, should be ignored or warned)\n\n## Files to Create/Modify\n- src/core/stack.ts (modify to add validation)\n\n## Acceptance Criteria\n- [ ] Detects unclosed groups with clear error\n- [ ] Detects overlapping groups with clear error\n- [ ] Returns success with PRUnits when valid\n- [ ] Error messages include commit hashes for debugging\n- [ ] Has tests for all validation scenarios","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T14:23:31.178628-05:00","updated_at":"2026-01-10T00:36:02.170824-05:00","closed_at":"2025-12-26T01:18:36.350318-05:00","close_reason":"Implemented parseStack() with validation for unclosed and overlapping groups, 7 new tests","dependencies":[{"issue_id":"spry-919","depends_on_id":"spry-67b","type":"parent-child","created_at":"2025-12-25T14:23:35.162413-05:00","created_by":"daemon"},{"issue_id":"spry-919","depends_on_id":"spry-4iy","type":"blocks","created_at":"2025-12-25T14:23:35.437374-05:00","created_by":"daemon"},{"issue_id":"spry-919","depends_on_id":"spry-4iy","type":"depends-on","created_at":"2025-12-25T14:23:35.437374-05:00","created_by":"daemon"}]}
{"id":"spry-91v","title":"Add changelog instructions to CLAUDE.md","description":"Document changelog maintenance workflow in CLAUDE.md releasing section.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-09T10:13:49.393925-05:00","updated_at":"2026-01-09T10:15:28.085198-05:00","closed_at":"2026-01-09T10:15:28.085198-05:00","close_reason":"Closed"}
{"id":"spry-994","title":"Add changelog validation to release script","description":"Update scripts/release.sh to require changelog entry before releasing. Validate entry exists and has content.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-09T10:13:49.200734-05:00","updated_at":"2026-01-10T00:36:02.179643-05:00","closed_at":"2026-01-09T10:14:51.407821-05:00","close_reason":"Closed","dependencies":[{"issue_id":"spry-994","depends_on_id":"spry-5lf","type":"blocks","created_at":"2026-01-09T10:13:53.652014-05:00","created_by":"don.denton"}]}
{"id":"spry-9i5","title":"Implement sp wt rm command","description":"Remove worktree with optional branch cleanup.\n\nUsage: sp wt rm \u003cname\u003e [options]\n\nBehavior:\n- Removes worktree directory via git worktree remove\n- Optionally deletes local and/or remote branches\n\nFlags:\n- --force - Remove even if working directory is dirty\n- --del-local - Also delete the local branch\n- --del-remote - Also delete the remote branch  \n- --del-all - Delete both local and remote branches\n\nError handling:\n- Fail gracefully if worktree doesn't exist\n- Warn (don't fail) if branch doesn't exist when --del-* specified\n\nReference: ~/dotfiles/bin/git-ht cmd_remove()","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-10T15:23:05.317323-05:00","created_by":"dondenton","updated_at":"2026-01-10T20:46:56.645848-05:00","dependencies":[{"issue_id":"spry-9i5","depends_on_id":"spry-ra3","type":"parent-child","created_at":"2026-01-10T15:23:12.986342-05:00","created_by":"dondenton"},{"issue_id":"spry-9i5","depends_on_id":"spry-s4y","type":"blocks","created_at":"2026-01-10T15:26:17.565253-05:00","created_by":"dondenton"}]}
{"id":"spry-9j47","title":"Add spinner and feedback while opening PRs for the first time","status":"closed","priority":1,"issue_type":"task","owner":"don.denton@trillianthealth.com","created_at":"2026-01-12T17:05:24.015737-05:00","created_by":"Don Denton","updated_at":"2026-01-13T01:00:51.728264-05:00","closed_at":"2026-01-13T01:00:51.728264-05:00","close_reason":"Closed"}
{"id":"spry-9nb","title":"taspr-inmem-rewrite","description":"# In-Memory Message Rewrite\n\nImplement message rewriting without touching the working directory.\n\n## Function\n\n```typescript\nasync function rewriteCommitMessage(\n  commit: string,\n  newMessage: string,\n  options: GitOptions = {}\n): Promise\u003cstring\u003e\n```\n\n## Algorithm\n\n1. Get tree from original commit (unchanged)\n2. Get parents from original commit (unchanged)\n3. Get author AND committer env (preserve both for message-only changes)\n4. Create new commit with `git commit-tree`\n5. Return new commit SHA\n\n## Key Points\n- Tree is reused (no content change)\n- Both author and committer dates preserved (message-only = no timestamp update)\n- No working directory access at all\n\n## Usage Locations\n- Add/remove/modify trailers (Taspr-Commit-Id, Taspr-Group)\n- All operations in `group-rebase.ts` that only change messages\n\n## Tests\n- Verify tree SHA unchanged\n- Verify author/committer info preserved\n- Verify message correctly modified","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-08T22:10:38.609862-05:00","updated_at":"2026-01-08T22:46:14.163762-05:00","closed_at":"2026-01-08T22:46:14.163762-05:00","close_reason":"Closed","dependencies":[{"issue_id":"spry-9nb","depends_on_id":"spry-2x9","type":"blocks","created_at":"2026-01-08T22:10:42.959673-05:00","created_by":"don.denton"}]}
{"id":"spry-9x8","title":"Help text - comprehensive --help for all commands","description":"## Goal\nProvide comprehensive, well-formatted help text for all commands using Commander\\'s built-in help system.\n\n## Commands to Document\n\n### Main Command: `taspr`\n```\ntaspr - Stacked PR management for GitHub\n\nUsage: taspr \u003ccommand\u003e [options]\n\nCommands:\n  view      Show current stack structure and PR status\n  sync      Sync local stack with GitHub (push branches, create/update PRs)\n  land      Merge the bottom PR to main\n  group     Manage commit groups (create, edit, dissolve)\n\nOptions:\n  -h, --help     Show this help message\n  -v, --version  Show version number\n\nExamples:\n  taspr view              Show stack structure\n  taspr sync              Push and create PRs\n  taspr sync --open       Push, create PRs, and open in browser\n  taspr land              Merge bottom ready PR\n  taspr group create      Create a new commit group\n\nRun 'taspr \u003ccommand\u003e --help' for detailed help on each command.\n```\n\n### `taspr view`\n```\nShow the current stack structure and PR status\n\nUsage: taspr view [options]\n\nOptions:\n  --all          Show all stacks across branches (not just current)\n  --json         Output as JSON for scripting\n  -h, --help     Show this help message\n\nThe view command shows:\n  - Commits in the current stack (between HEAD and origin/main)\n  - Which commits are grouped into multi-commit PRs\n  - PR numbers and their current status (draft, open, merged)\n  - CI status, review status, and comment threads (if PRs exist)\n\nStatus indicators:\n  ✓  Checks passing, approved\n  ●  Checks running or pending review\n  ✗  Checks failing or changes requested\n  ◐  Draft PR\n\nExamples:\n  taspr view         Current branch stack\n  taspr view --all   All branches with stacks\n```\n\n### `taspr sync`\n```\nSync local stack with GitHub\n\nUsage: taspr sync [options]\n\nOptions:\n  --open         Open created PRs in browser\n  --dry-run      Show what would be done without doing it\n  -h, --help     Show this help message\n\nThe sync command:\n  1. Adds Taspr-Commit-Id trailers to commits that don\\'t have them\n  2. Creates branches for each PR unit (single commit or group)\n  3. Creates PRs on GitHub with correct stacking (each based on PR below)\n  4. Updates existing PRs if commits have changed\n  5. Rebases on origin/main if behind (with conflict detection)\n\nBranch naming: \u003cprefix\u003e/\u003cusername\u003e/\u003ccommit-id\u003e\n  Example: taspr/alice/a1b2c3d4\n\nEach PR\\'s base branch is the branch of the PR below it in the stack,\nor main/master for the bottom PR.\n\nExamples:\n  taspr sync             Sync stack to GitHub\n  taspr sync --open      Sync and open new PRs in browser\n  taspr sync --dry-run   Preview sync operations\n```\n\n### `taspr land`\n```\nMerge PRs to main\n\nUsage: taspr land [options]\n\nOptions:\n  --all          Land all consecutive ready PRs (not just bottom)\n  -h, --help     Show this help message\n\nThe land command merges the bottom PR in your stack to main/master.\nGitHub automatically retargets child PRs to the new base after merge.\n\nA PR is \"ready\" when:\n  - CI checks are passing\n  - Has required approvals\n  - No unresolved review threads\n  - Not a draft\n\nExamples:\n  taspr land         Merge bottom ready PR\n  taspr land --all   Merge all consecutive ready PRs\n```\n\n### `taspr group`\n```\nManage commit groups (multiple commits as one PR)\n\nUsage: taspr group \u003csubcommand\u003e [options]\n\nSubcommands:\n  create    Create a new group from selected commits\n  edit      Edit an existing group (title or range)\n  dissolve  Remove a group, making commits individual PRs\n\nBy default, each commit becomes its own PR. Groups let you bundle\nmultiple related commits into a single PR while keeping them as\nseparate commits locally.\n\nGroups use git trailers:\n  - Taspr-Group-Start: \u003cgroup-id\u003e   (on first commit)\n  - Taspr-Group-End: \u003cgroup-id\u003e     (on last commit)\n  - Taspr-Group-Title: \u003ctitle\u003e      (on first commit)\n\nExamples:\n  taspr group create     Interactive commit selection\n  taspr group edit       Edit existing group\n  taspr group dissolve   Remove group, keep commits\n```\n\n## Implementation with Commander\n\n```typescript\nimport { program } from 'commander';\n\nprogram\n  .name('taspr')\n  .description('Stacked PR management for GitHub')\n  .version('0.1.0');\n\nprogram\n  .command('view')\n  .description('Show current stack structure and PR status')\n  .option('--all', 'Show all stacks across branches')\n  .option('--json', 'Output as JSON')\n  .addHelpText('after', `\nStatus indicators:\n  ✓  Checks passing, approved\n  ●  Checks running or pending review\n  ✗  Checks failing or changes requested\n  ◐  Draft PR\n\nExamples:\n  taspr view         Current branch stack\n  taspr view --all   All branches with stacks\n`)\n  .action(viewCommand);\n```\n\n## Acceptance Criteria\n- [ ] Main taspr --help shows all commands\n- [ ] Each command has detailed --help\n- [ ] Examples included for common use cases\n- [ ] Status indicators explained in view help\n- [ ] Group trailer format documented in group help\n- [ ] Help text fits standard terminal width (80 chars)","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-25T14:49:58.136451-05:00","updated_at":"2026-01-10T00:36:02.162645-05:00","dependencies":[{"issue_id":"spry-9x8","depends_on_id":"spry-do5","type":"parent-child","created_at":"2025-12-25T15:01:37.068615-05:00","created_by":"daemon"}]}
{"id":"spry-a2y","title":"Add story logging to all major command tests","description":"Currently only some test files generate story output. All major commands and options should be represented in the documentation.\n\nAudit which test files are missing story logging and add it. The goal is comprehensive documentation of:\n- All CLI commands (sync, land, clean, view, group, etc.)\n- Important command options and flags\n- Edge cases and error scenarios","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-09T12:11:53.749786-05:00","updated_at":"2026-01-10T00:36:02.170169-05:00","closed_at":"2026-01-09T23:02:49.090463-05:00","close_reason":"Closed"}
{"id":"spry-a51","title":"gh CLI dependency checks","description":"## Remaining Work\n\nThe core gh CLI check (`ensureGhInstalled`) exists and is called before all GitHub operations. What's missing:\n\n### 1. Caching\nCurrently `ensureGhInstalled` checks `which gh` on every call. Should cache the result after first successful check.\n\n```typescript\nlet ghChecked = false;\n\nexport async function ensureGhInstalled(): Promise\u003cvoid\u003e {\n  if (ghChecked) return;\n  // ... existing check ...\n  ghChecked = true;\n}\n```\n\n### 2. Explicit Authentication Check\nCurrently authentication failures are caught when API calls fail. Could add explicit `gh auth status` check for clearer error messages.\n\n### 3. Repository Access Check\nCould add check for `gh repo view` to detect when user doesn't have access to the current repo.\n\n## What's Already Done\n- ✅ `ensureGhInstalled()` function exists in `src/github/api.ts`\n- ✅ Called before all GitHub operations in `pr.ts` and `view.ts`\n- ✅ Clear installation instructions for macOS, Linux, other\n- ✅ Error class `DependencyError` for missing gh\n- ✅ Error class `GitHubAuthError` for auth failures","status":"closed","priority":4,"issue_type":"task","created_at":"2025-12-25T14:49:31.737179-05:00","updated_at":"2026-01-10T00:43:37.523697-05:00","closed_at":"2026-01-10T00:43:37.523697-05:00","close_reason":"Closed","dependencies":[{"issue_id":"spry-a51","depends_on_id":"spry-do5","type":"parent-child","created_at":"2025-12-25T15:01:36.787108-05:00","created_by":"daemon"},{"issue_id":"spry-a51","depends_on_id":"spry-77v","type":"related","created_at":"2026-01-10T00:43:37.589015-05:00","created_by":"don.denton"}]}
{"id":"spry-ab6","title":"PR lookup by branch","description":"## Goal\nFind existing PRs for branches to avoid creating duplicates.\n\n## Implementation\n\n```typescript\n// src/github/pr.ts\n\ninterface PRInfo {\n  number: number;\n  url: string;\n  state: 'open' | 'closed' | 'merged';\n  title: string;\n}\n\nasync function findPRByBranch(branchName: string): Promise\u003cPRInfo | null\u003e {\n  const result = await $\\`gh pr list --head ${branchName} --json number,url,state,title\\`.nothrow();\n  \n  if (result.exitCode !== 0) {\n    return null;\n  }\n  \n  const prs = JSON.parse(result.stdout.toString());\n  \n  // Return first open PR (should only be one)\n  const openPR = prs.find((pr: PRInfo) =\u003e pr.state === 'open');\n  return openPR || null;\n}\n```\n\n### Usage in Sync\nBefore creating a PR, check if one exists:\n\n```typescript\nasync function ensurePRExists(unit: PRUnit, headBranch: string, baseBranch: string): Promise\u003cPRInfo\u003e {\n  // Check for existing PR\n  const existing = await findPRByBranch(headBranch);\n  if (existing) {\n    return existing;\n  }\n  \n  // Create new PR\n  return await createPR({\n    title: unit.title,\n    head: headBranch,\n    base: baseBranch,\n  });\n}\n```\n\n### Enriching PRUnits\nAfter sync, enrich PRUnits with PR info:\n\n```typescript\ninterface EnrichedPRUnit extends PRUnit {\n  prNumber?: number;\n  prUrl?: string;\n  prState?: 'open' | 'closed' | 'merged';\n}\n\nasync function enrichPRUnitsWithPRInfo(\n  units: PRUnit[], \n  branches: Map\u003cstring, string\u003e\n): Promise\u003cEnrichedPRUnit[]\u003e {\n  return Promise.all(units.map(async unit =\u003e {\n    const branch = branches.get(unit.id);\n    if (!branch) return unit;\n    \n    const pr = await findPRByBranch(branch);\n    return {\n      ...unit,\n      prNumber: pr?.number,\n      prUrl: pr?.url,\n      prState: pr?.state,\n    };\n  }));\n}\n```\n\n## Edge Cases\n1. **No PR for branch**: Return null\n2. **Closed PR for branch**: Return it (may want to reopen or create new)\n3. **Multiple PRs for branch**: Return first open one\n\n## Testing\n- Branch with open PR → returns PR info\n- Branch with closed PR → returns closed PR info\n- Branch with no PR → returns null\n\n## Files to Modify\n- src/github/pr.ts\n\n## Acceptance Criteria\n- [ ] Finds open PRs by branch name\n- [ ] Returns null for branches without PRs\n- [ ] Returns PR info including state\n- [ ] Handles closed/merged PRs","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T14:27:54.485452-05:00","updated_at":"2026-01-10T00:36:02.195562-05:00","closed_at":"2025-12-26T23:29:21.524548-05:00","close_reason":"Implemented and tested","dependencies":[{"issue_id":"spry-ab6","depends_on_id":"spry-ce1","type":"parent-child","created_at":"2025-12-25T14:27:58.424193-05:00","created_by":"daemon"},{"issue_id":"spry-ab6","depends_on_id":"spry-74a","type":"blocks","created_at":"2025-12-25T14:27:58.701-05:00","created_by":"daemon"},{"issue_id":"spry-ab6","depends_on_id":"spry-74a","type":"depends-on","created_at":"2025-12-25T14:27:58.701-05:00","created_by":"daemon"}]}
{"id":"spry-abj","title":"Improve error messages with context and remediation steps","description":"Many errors lack context. User sees 'Failed to delete origin/spry/user/abc123' but not why (permissions? doesn't exist? network?). Add contextual info and suggested fixes to all error messages.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-10T00:28:13.11075-05:00","created_by":"don.denton","updated_at":"2026-01-10T00:28:13.11075-05:00","dependencies":[{"issue_id":"spry-abj","depends_on_id":"spry-do5","type":"parent-child","created_at":"2026-01-10T01:04:18.658337-05:00","created_by":"don.denton"}]}
{"id":"spry-adq","title":"Interactive mode and --orphans flag for sp clean","description":"## Goal\nEnhance `sp clean` with more sophisticated branch detection and an interactive mode.\n\n## Background\nCurrently `sp clean` detects two types of branches:\n1. **Safe**: Branches whose exact SHA is merged into main (fast-forward/rebase)\n2. **Unsafe**: Branches matched only by Spry-Commit-Id trailer (squash/amended)\n\nThere are other scenarios that could leave orphaned branches:\n- Branches with no local counterpart (remote-only spry branches)\n- Branches whose PRs were closed without merging\n- Branches from PRs that were superseded by rebases\n- Branches from abandoned work\n\n## Proposed Changes\n\n### Interactive Mode (`-i` or `--interactive`)\nPresent branches in a TUI allowing user to:\n- Review each branch with context (last commit date, PR status if any)\n- Select which to delete\n- See diff summary or commit log for uncertain cases\n\n### Orphan Detection (`--orphans`)\nAdd detection for branches that:\n- Have no local tracking branch\n- Are owned by current user (match spry prefix pattern)\n- May not have matching commits in main at all\n\nThis would require `--orphans --force` to actually delete, similar to `--unsafe`.\n\n### Considerations\n- What about branches from closed (not merged) PRs?\n- Should we check PR status via GitHub API?\n- How to handle branches from other users (probably never touch)\n- Performance with many branches\n- Should --orphans imply fetching fresh data?\n\n## Parent Epic\ntaspr-8iv: Polish and Distribution\n\n## Related\n- Current implementation: src/cli/commands/clean.ts\n- Test coverage: tests/integration/clean.test.ts","status":"open","priority":4,"issue_type":"feature","created_at":"2026-01-10T00:19:00.072004-05:00","created_by":"don.denton","updated_at":"2026-01-10T00:19:00.072004-05:00"}
{"id":"spry-aqb","title":"taspr-inmem-cleanup","description":"# Cleanup: Remove Traditional Rebase Code\n\nAfter in-memory migration is complete and tested:\n\n## Tasks\n\n1. **Remove \\`runInteractiveRebase\\` function**\n   - No longer needed after migration\n   - Delete from \\`group-rebase.ts\\`\n\n2. **Remove \\`createRebaseScript\\` function**\n   - Shell script generation no longer needed\n\n3. **Remove \\`createIdInjectionScript\\` function**\n   - ID injection now done via commit-tree\n\n4. **Clean up imports**\n   - Remove unused \\`tmpdir\\`, \\`join\\`, \\`unlink\\`, \\`chmod\\`, \\`writeFile\\`\n   - These were only needed for temp script files\n\n5. **Update documentation**\n   - Document Git 2.38+ requirement\n   - Update CLAUDE.md if needed\n   - Add section about in-memory operations to README\n\n6. **Remove feature flag** (if used during migration)\n   - Make in-memory the only path\n   - Remove any environment variable checks\n\n## Verification\n- All tests still pass\n- No references to old functions remain\n- \\`git grep\\` for any leftover rebase -i references","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-08T22:11:36.457115-05:00","updated_at":"2026-01-08T22:59:16.100045-05:00","closed_at":"2026-01-08T22:59:16.100045-05:00","close_reason":"Removed dead abortRebase function and unused $ import from group-rebase.ts. No other traditional rebase code remained - the migration in previous tasks already replaced all git rebase -i patterns with in-memory operations.","dependencies":[{"issue_id":"spry-aqb","depends_on_id":"spry-0gw","type":"blocks","created_at":"2026-01-08T22:11:39.207264-05:00","created_by":"don.denton"},{"issue_id":"spry-aqb","depends_on_id":"spry-fgm","type":"blocks","created_at":"2026-01-08T22:11:39.261167-05:00","created_by":"don.denton"}]}
{"id":"spry-b4m","title":"Implement sp wt list command","description":"Convenience wrapper around git worktree list.\n\nUsage: sp wt list\n\nSimple implementation - just call git worktree list and display output.\nConsider formatting to match spry's output style.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-10T15:23:06.199185-05:00","created_by":"dondenton","updated_at":"2026-01-10T20:46:57.543179-05:00","dependencies":[{"issue_id":"spry-b4m","depends_on_id":"spry-ra3","type":"parent-child","created_at":"2026-01-10T15:23:13.156769-05:00","created_by":"dondenton"},{"issue_id":"spry-b4m","depends_on_id":"spry-s4y","type":"blocks","created_at":"2026-01-10T15:26:17.766408-05:00","created_by":"dondenton"}]}
{"id":"spry-b5u","title":"Update release workflow to use changelog for release notes","description":"Modify .github/workflows/release.yml to extract release notes from CHANGELOG.md instead of auto-generating from commits.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-09T10:13:49.298961-05:00","updated_at":"2026-01-10T00:36:02.179372-05:00","closed_at":"2026-01-09T10:15:09.841139-05:00","close_reason":"Closed","dependencies":[{"issue_id":"spry-b5u","depends_on_id":"spry-5lf","type":"blocks","created_at":"2026-01-09T10:13:53.707602-05:00","created_by":"don.denton"}]}
{"id":"spry-blj","title":"Conflict recovery (continue after manual fix)","description":"## Goal\nHandle the workflow after user manually resolves conflicts.\n\n## Background\nWhen sync hits a conflict:\n1. User manually resolves\n2. User runs `git add` + `git rebase --continue`\n3. User runs `taspr sync` again\n\ntaspr needs to:\n- Detect if we're mid-rebase\n- Continue or restart as appropriate\n\n## Implementation\n\n```typescript\n// src/cli/commands/sync.ts\n\nasync function sync() {\n  // Check for ongoing rebase\n  const conflict = await getConflictInfo();\n  \n  if (conflict) {\n    console.log('Detected ongoing rebase conflict.');\n    console.log('');\n    console.log(formatConflictError(conflict));\n    process.exit(1);\n  }\n  \n  // Normal sync flow...\n}\n```\n\n### Post-Rebase Flow\nAfter user completes `git rebase --continue`:\n1. Stack is rebased onto new main\n2. All commit hashes have changed\n3. Running `taspr sync` should:\n   - Update all branches with new hashes\n   - Report which PRs were updated\n\n```typescript\nasync function sync() {\n  // ... conflict check ...\n  \n  // After successful rebase or no rebase needed\n  const statuses = await getAllSyncStatuses(units);\n  \n  const updated = [];\n  for (const [id, status] of statuses) {\n    if (status.needsUpdate) {\n      await forcePushBranch(status.localCommit, status.branchName);\n      updated.push(status.branchName);\n    }\n  }\n  \n  if (updated.length \u003e 0) {\n    console.log(\\`✓ Updated \\${updated.length} PR branch(es)\\`);\n  }\n}\n```\n\n## Testing\n- Sync detects mid-rebase state\n- Sync after rebase --continue updates branches\n- All PRs reflect new commits\n\n## Files to Modify\n- src/cli/commands/sync.ts\n- src/git/rebase.ts\n\n## Acceptance Criteria\n- [ ] Detects ongoing conflict and exits with instructions\n- [ ] After manual resolution, sync updates all branches\n- [ ] Clear feedback on what was updated","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-25T14:37:00.272928-05:00","updated_at":"2026-01-10T00:36:02.177217-05:00","closed_at":"2025-12-31T14:15:52.361656-05:00","close_reason":"Closed","dependencies":[{"issue_id":"spry-blj","depends_on_id":"spry-efn","type":"parent-child","created_at":"2025-12-25T14:37:04.660065-05:00","created_by":"daemon"},{"issue_id":"spry-blj","depends_on_id":"spry-izr","type":"blocks","created_at":"2025-12-25T14:37:04.935834-05:00","created_by":"daemon"},{"issue_id":"spry-blj","depends_on_id":"spry-izr","type":"depends-on","created_at":"2025-12-25T14:37:04.935834-05:00","created_by":"daemon"}]}
{"id":"spry-bs5","title":"Flaky test: sp group --fix merge mode","description":"## Failed Test\n```\nsp group --fix \u003e Explicit merge with --fix=merge\n```\n\n## How to Run\n```bash\nGITHUB_INTEGRATION_TESTS=1 bun test tests/integration/group-fix.test.ts -t 'Explicit merge'\n```\n\n## Error\n```\ntests/integration/group-fix.test.ts:130\nexpect(result.exitCode).toBe(0);\n\nExpected: 0\nReceived: 1\n```\n\n## Analysis\nThe test runs `sp group --fix` with merge mode and expects success (exit code 0) but gets failure (exit code 1).\n\n**Root cause suspicion:** \n1. The command is failing for an unknown reason - need to capture stderr/stdout from the failed run\n2. Could be a race condition with git state or file system\n3. Could be related to how the test sets up the problematic group state before running --fix\n\n**Fix approach:** Add more logging to capture why the command failed. Check the test setup to ensure the group state is correctly invalid before running --fix merge.\n\n## Location\ntests/integration/group-fix.test.ts:130","status":"closed","priority":0,"issue_type":"bug","created_at":"2026-01-10T15:27:36.541427-05:00","created_by":"dondenton","updated_at":"2026-01-10T16:14:48.170493-05:00","closed_at":"2026-01-10T16:14:48.170493-05:00","close_reason":"Fixed: see commit"}
{"id":"spry-bww","title":"Add --apply flag for sync --open","description":"Add a non-interactive way to specify which commits/groups should have PRs opened.\n\n## Syntax\n```bash\ntaspr sync --open --apply='[\"id1\", \"id2\"]'\n```\n\n## Identifier Resolution\nEach identifier in the array can be:\n- Git commit hash (full or partial)\n- Taspr-Commit-Id (the 8-char ID in trailers)\n- Group ID\n\n## Behavior\n- Only opens PRs for the specified commits/groups\n- All commits still get branches pushed (for stacking)\n- Validates all identifiers exist before starting\n- Skips identifiers that already have PRs (no error)\n\n## Format\nSimple JSON array of identifiers:\n```json\n[\"abc123\", \"def456\", \"group-id\"]\n```\n\n## Error Cases\n- Invalid JSON: \"Error: Invalid --apply format. Expected JSON array of identifiers.\"\n- Ambiguous identifier: \"Error: 'abc' matches multiple commits. Please provide more characters.\"\n- Not found: \"Error: No commit or group matching 'xyz' found in stack\"\n\n## Implementation Notes\n- This provides the data interface for the interactive mode (-i)\n- Interactive mode will build this array through TUI selection\n- Reuse identifier resolution logic from --up-to implementation","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-08T15:18:05.367361-05:00","updated_at":"2026-01-08T15:33:55.077334-05:00","closed_at":"2026-01-08T15:33:55.077334-05:00","close_reason":"Implemented --apply flag for sync --open. Added identifier module for resolving commits/groups by various identifiers."}
{"id":"spry-c4v","title":"Design better strategy for untitled groups","description":"## Problem\n\nWhen a group is first created (commits with Spry-Group trailer), there's no title stored in ref storage yet. The current workaround uses `getUnitTitle()` to fall back to the first commit subject, but this is a band-aid fix.\n\n## Solution\n\n**Fail sync when creating PR without a stored group title.** Users can override with `--allow-untitled-pr` flag.\n\nThis approach:\n- Makes the user aware they need to set a title\n- Avoids PRs with unexpected/incorrect titles  \n- Explicit opt-in for fallback behavior\n\n## Implementation\n\n1. Created `src/core/title.ts` with unified helpers:\n   - `resolveUnitTitle(unit)` - consistent fallback logic\n   - `hasStoredTitle(unit)` - check if title is stored\n\n2. Added `--allow-untitled-pr` flag to sync command\n\n3. Validation in sync.ts:\n   - Before creating PR for group, check `hasStoredTitle()`\n   - If no stored title and no flag, fail with helpful error\n   - If `--allow-untitled-pr`, use `resolveUnitTitle()` and continue\n\n4. Consolidated all scattered fallback logic to use `resolveUnitTitle()`\n\n## Files Modified\n\n- `src/core/title.ts` - New helper module\n- `src/core/title.test.ts` - Unit tests (9 tests)\n- `src/cli/commands/sync.ts` - Add validation and flag\n- `src/cli/index.ts` - Add CLI option\n- `src/cli/output.ts` - Use resolveUnitTitle()\n- `src/cli/commands/land.ts` - Use resolveUnitTitle()\n- `src/cli/commands/view.test.ts` - Updated test expectation\n- `tests/integration/helpers.ts` - Added allowUntitledPr option\n- `tests/integration/sync.test.ts` - Added untitled group test\n\n## Acceptance Criteria\n\n- [x] Create resolveUnitTitle() helper\n- [x] Create hasStoredTitle() helper\n- [x] Add unit tests for helpers\n- [x] Add --allow-untitled-pr flag\n- [x] Validate group titles in sync\n- [x] Consolidate fallback logic\n- [x] Add integration tests\n\nAll tests passing (386 unit, 4 PR body integration tests)","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-09T21:27:47.989093-05:00","created_by":"don.denton","updated_at":"2026-01-09T21:40:57.028562-05:00","closed_at":"2026-01-09T21:40:57.028562-05:00","close_reason":"Closed"}
{"id":"spry-ce1","title":"Epic 3: Push Stack to GitHub as PRs","description":"## Goal\nCreate GitHub PRs for each PRUnit, with correct stacking (each PR based on the one below it).\n\n## Background\n\n### Stacked PRs Model\nIn a stack of 3 PRUnits (A, B, C from bottom to top):\n- PR for A: base = main, head = branch for A\n- PR for B: base = branch for A, head = branch for B\n- PR for C: base = branch for B, head = branch for C\n\nThis creates a review chain where reviewers see only the changes in each PR, not accumulated changes.\n\n### Branch Naming Convention\n```\n\u003cprefix\u003e/\u003cusername\u003e/\u003cpr-id\u003e\n```\n\nExample: `taspr/msims/a1b2c3d4`\n\nWhere:\n- `prefix`: Configurable via `git config taspr.branchPrefix` (default: \"taspr\")\n- `username`: GitHub username from `gh api user`\n- `pr-id`: The PRUnit's id (commit-id for singles, group-id for groups)\n\nThis naming:\n- Is stable (ID survives rebases)\n- Identifies the owner\n- Groups all taspr branches with a common prefix\n\n### No PR Metadata Storage\nAt this stage, we don't store PR numbers anywhere. We discover them by:\n1. Looking up PRs by branch name\n2. GitHub API: `gh pr list --head \u003cbranch\u003e`\n\nThis keeps the design simple—git trailers remain the single source of truth.\n\n## Workflow\n\n1. User runs `taspr sync --open`\n2. For each PRUnit without an existing PR:\n   - Create/update branch: `git push origin \u003ccommit\u003e:refs/heads/\u003cbranch-name\u003e`\n   - Create PR: `gh pr create --head \u003cbranch\u003e --base \u003cparent-branch\u003e`\n3. Report created PRs\n\n## Deliverable\nRunning `taspr sync --open` creates branches and PRs on GitHub. Each PR's base is the branch of the PR below it (or main for the bottom).\n\n## Dependencies\n- Epic 2 must be complete (commits have IDs)\n\n## Key Technical Decisions\n- Use `gh` CLI for all GitHub operations (leverages user's existing auth)\n- Branch per PRUnit, named by pr-id\n- PRs discovered by branch lookup, not stored in trailers\n\n## Testable Outcome\nPRs appear on GitHub, correctly stacked, with titles from commit/group.","status":"closed","priority":1,"issue_type":"epic","created_at":"2025-12-25T14:26:32.393192-05:00","updated_at":"2026-01-10T00:36:02.168193-05:00","closed_at":"2025-12-26T23:29:29.43508-05:00","close_reason":"All child tasks implemented and tested","dependencies":[{"issue_id":"spry-ce1","depends_on_id":"spry-sbb","type":"blocks","created_at":"2025-12-25T14:26:36.107535-05:00","created_by":"daemon"},{"issue_id":"spry-ce1","depends_on_id":"spry-sbb","type":"depends-on","created_at":"2025-12-25T14:26:36.107535-05:00","created_by":"daemon"}]}
{"id":"spry-ceg","title":"Fetch PR checks status","description":"## Goal\nGet CI check status for PRs.\n\n## Implementation\n\n```typescript\n// src/github/pr.ts\n\ntype ChecksStatus = 'pending' | 'passing' | 'failing';\n\nasync function getPRChecksStatus(prNumber: number): Promise\u003cChecksStatus\u003e {\n  const result = await $\\`gh pr checks \\${prNumber} --json state\\`;\n  const checks = JSON.parse(result.stdout.toString());\n  \n  const states = checks.map((c: any) =\u003e c.state);\n  \n  if (states.some((s: string) =\u003e s === 'FAILURE')) return 'failing';\n  if (states.some((s: string) =\u003e s === 'PENDING')) return 'pending';\n  return 'passing';\n}\n```\n\n## Alternative: gh pr view\n```typescript\nasync function getPRChecksStatus(prNumber: number): Promise\u003cChecksStatus\u003e {\n  const result = await $\\`gh pr view \\${prNumber} --json statusCheckRollup\\`;\n  const data = JSON.parse(result.stdout.toString());\n  \n  // statusCheckRollup contains aggregated status\n  const rollup = data.statusCheckRollup;\n  \n  if (rollup.some((c: any) =\u003e c.conclusion === 'FAILURE')) return 'failing';\n  if (rollup.some((c: any) =\u003e c.status === 'IN_PROGRESS')) return 'pending';\n  return 'passing';\n}\n```\n\n## Testing\n- PR with passing checks\n- PR with failing checks\n- PR with pending checks\n- PR with no checks configured\n\n## Files to Modify\n- src/github/pr.ts\n\n## Acceptance Criteria\n- [ ] Returns passing/failing/pending status\n- [ ] Handles PRs without checks\n- [ ] Works with various CI providers","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-25T14:32:24.225276-05:00","updated_at":"2026-01-10T00:36:02.17154-05:00","closed_at":"2025-12-31T11:37:23.143026-05:00","close_reason":"Implemented getPRChecksStatus function with shared determineChecksStatus helper. Added optional repo parameter for cross-repo queries. Unit tests cover all status states (none, pending, passing, failing). Integration tests verify all four states: passing CI, failing CI, pending CI, and no CI (by removing the workflow file in the PR).","dependencies":[{"issue_id":"spry-ceg","depends_on_id":"spry-7qh","type":"parent-child","created_at":"2025-12-25T14:32:27.950028-05:00","created_by":"daemon"}]}
{"id":"spry-cghw","title":"Dedupe common shell commands into shared functions","description":"## Problem\n\nThere are repeated shell commands scattered throughout the codebase that should be extracted into shared utility functions.\n\n## Examples\n\n- `gh api user --jq .login` - Getting the current GitHub username (seen in src/cli/commands/view.ts:134)\n- Likely other `gh api` calls\n- Possibly other git commands\n\n## Solution\n\n1. Audit the codebase for repeated shell command patterns\n2. Create shared utility functions (e.g., in `src/github/api.ts` or a new `src/utils/` module)\n3. Replace inline commands with function calls\n\n## Benefits\n\n- Single source of truth for command syntax\n- Easier to test and mock\n- Consistent error handling\n- Easier to update if GitHub CLI changes","status":"open","priority":3,"issue_type":"task","owner":"don@happycollision.com","created_at":"2026-01-17T00:11:36.538095-05:00","created_by":"Don Denton","updated_at":"2026-01-17T00:11:36.538095-05:00"}
{"id":"spry-chk","title":"Add alt/option key as temporary mode switch in grouping TUI","description":"Use the alt/option key as a temporary mode switch key in the grouping TUI. It should enter move mode when pressed down and exit move mode when released, allowing quick move operations without explicitly toggling modes.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-02T11:30:14.583351-05:00","updated_at":"2026-01-10T00:36:02.202033-05:00","closed_at":"2026-01-03T14:39:49.295083-05:00","close_reason":"Closed","dependencies":[{"issue_id":"spry-chk","depends_on_id":"spry-do5","type":"parent-child","created_at":"2026-01-02T11:30:14.583969-05:00","created_by":"dondenton"}]}
{"id":"spry-ckz7","title":"PR: Add merge commit disclaimer to PR descriptions","description":"Add informational disclaimer to PR descriptions when merge commits are present, listing which commits are merge commits by subject.\n\n## Context\n\nPRs containing merge commits need a disclaimer to help reviewers understand that merge commits can be ignored during review. The disclaimer should list all merge commits by subject (not assume they're only at the end).\n\n## Changes Required\n\n### 1. Add warning generation function (src/github/pr-body.ts)\n\n```typescript\n// Keep existing ALPHA_WARNING\nexport const ALPHA_WARNING =\n  \"\u003csub\u003eCreated with [Spry](https://github.com/happycollision/spry) (alpha). \" +\n  \"Do not manually merge stacked PRs.\u003c/sub\u003e\";\n\n// NEW: Generate merge commit warning dynamically\nexport function generateMergeCommitWarning(mergeCommitSubjects: string[]): string {\n  return \"\\n\\n\u003e **Note:** This PR contains merge commits that can be ignored during review:\\n\" +\n    mergeCommitSubjects.map(s =\u003e `\u003e - ${s}`).join(\"\\n\") +\n    \"\\n\\n\u003e These are automatically generated to combine branches within the PR.\";\n}\n```\n\n### 2. Update generateInitialPRBody (src/github/pr-body.ts:227-299)\n\n```typescript\nexport function generateInitialPRBody(\n  commits: CommitWithTrailers[],\n  // ... other params\n): string {\n  // ... existing body generation ...\n\n  // NEW: Detect merge commits\n  const mergeCommits = commits.filter(c =\u003e {\n    const mergeParents = c.trailers[\"Spry-Merge-Parents\"];\n    return Array.isArray(mergeParents) \u0026\u0026 mergeParents.length \u003e 0;\n  });\n\n  // Generate footer\n  let footer = generateFooterContent();\n  \n  // Add merge commit warning if present\n  if (mergeCommits.length \u003e 0) {\n    const mergeSubjects = mergeCommits.map(c =\u003e c.subject);\n    footer += generateMergeCommitWarning(mergeSubjects);\n  }\n\n  // ... assemble final body\n}\n```\n\n### 3. Update generateUpdatedPRBody (src/github/pr-body.ts:396-458)\n\n```typescript\nexport function generateUpdatedPRBody(\n  currentBody: string,\n  commits: CommitWithTrailers[],\n  // ... other params\n): string {\n  // ... existing update logic ...\n\n  // NEW: Detect merge commits\n  const mergeCommits = commits.filter(c =\u003e {\n    const mergeParents = c.trailers[\"Spry-Merge-Parents\"];\n    return Array.isArray(mergeParents) \u0026\u0026 mergeParents.length \u003e 0;\n  });\n\n  // Update footer\n  let footer = generateFooterContent();\n  \n  if (mergeCommits.length \u003e 0) {\n    const mergeSubjects = mergeCommits.map(c =\u003e c.subject);\n    footer += generateMergeCommitWarning(mergeSubjects);\n  }\n\n  // ... replace footer section\n}\n```\n\n## Example Output\n\n```markdown\n\u003c!-- spry:footer:begin --\u003e\n\u003csub\u003eCreated with [Spry](https://github.com/happycollision/spry) (alpha). Do not manually merge stacked PRs.\u003c/sub\u003e\n\n\u003e **Note:** This PR contains merge commits that can be ignored during review:\n\u003e - Merge commits 2-3\n\u003e - Merge commits 5-6\n\n\u003e These are automatically generated to combine branches within the PR.\n\u003c!-- spry:footer:end --\u003e\n```\n\n## Detection Logic\n\nMerge commits are identified by presence of `Spry-Merge-Parents` trailer (array with values). This works because:\n1. Phase 1-3 add this trailer to merge commits\n2. Trailer persists across syncs\n3. Multiple merge commits per PR supported\n\n## Verification\n\n1. Unit tests for `generateMergeCommitWarning()`\n2. Integration test: Create PR with merge commits, verify disclaimer present\n3. Test with single merge commit\n4. Test with multiple merge commits\n5. Test PR update preserves/updates disclaimer\n6. Manual testing: Create merge commit PR, view on GitHub\n\n## Files to Modify\n\n- src/github/pr-body.ts\n\n## Dependencies\n\nRequires Phase 1-3 complete (merge commits have `Spry-Merge-Parents` trailer).","status":"open","priority":2,"issue_type":"task","owner":"don.denton@trillianthealth.com","created_at":"2026-01-13T11:39:27.064672-05:00","created_by":"Don Denton","updated_at":"2026-01-13T11:39:27.064672-05:00","dependencies":[{"issue_id":"spry-ckz7","depends_on_id":"spry-xvbw","type":"blocks","created_at":"2026-01-13T11:40:21.172066-05:00","created_by":"Don Denton"}]}
{"id":"spry-configext","title":"Extend SpryConfig with PR body settings","description":"## Goal\nAdd PR body-related settings to `src/git/config.ts`\n\n## New Config Fields\n```typescript\ninterface SpryConfig {\n  // existing...\n  showStackLinks: boolean;       // default true\n  includePrTemplate: boolean;    // default true\n  prTemplateLocation: TemplateLocation; // default \"afterBody\"\n}\n```\n\n## Git Config Keys\n- `spry.showStackLinks` → boolean\n- `spry.includePrTemplate` → boolean\n- `spry.prTemplateLocation` → \"prepend\" | \"afterBody\" | \"afterStackLinks\" | \"append\"\n\n## Implementation\n- Read from git config with defaults\n- Support both --local and --global scopes\n- Validate prTemplateLocation is valid enum value\n\n## Tests\n- Default values when not configured\n- Reading each setting from git config\n- Invalid prTemplateLocation handling","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-09T15:02:00-05:00","updated_at":"2026-01-09T16:26:11.819939-05:00","closed_at":"2026-01-09T16:26:11.819939-05:00","close_reason":"Closed","dependencies":[{"issue_id":"spry-configext","depends_on_id":"spry-prbody-epic","type":"parent-child","created_at":"2026-01-09T15:02:00-05:00","created_by":"claude"}]}
{"id":"spry-cso","title":"Group create command","description":"## Goal\nImplement `taspr group create` to bundle commits into a single PR.\n\n## Implementation\n\n```typescript\n// src/cli/commands/group.ts\n\nexport const groupCommand = new Command('group')\n  .description('Manage commit groups');\n\ngroupCommand\n  .command('create')\n  .description('Create a new group from selected commits')\n  .action(async () =\u003e {\n    // Get current stack\n    const result = await parseStack();\n    if (!result.ok) {\n      console.error(formatValidationError(result));\n      process.exit(1);\n    }\n    \n    // Show commit selection\n    const selected = await selectCommits(result.units);\n    \n    // Validate selection\n    const validation = validateGroupSelection(selected, result.units);\n    if (!validation.ok) {\n      console.error(validation.error);\n      process.exit(1);\n    }\n    \n    // Get PR title\n    const title = await input({ message: 'PR title:' });\n    \n    // Warn about existing PRs\n    await warnAboutExistingPRs(selected);\n    \n    // Confirm\n    const proceed = await confirm({ message: 'Proceed?' });\n    if (!proceed) return;\n    \n    // Add group trailers\n    const groupId = generateId();\n    await addGroupTrailers(selected, groupId, title);\n    \n    console.log(\\`✓ Created group \\${groupId}\\`);\n    console.log(\\`  Title: \"\\${title}\"\\`);\n    console.log(\\`  Run \\`taspr sync --open\\` to create the PR.\\`);\n  });\n```\n\n### Adding Group Trailers\n```typescript\nasync function addGroupTrailers(\n  commits: CommitInfo[],\n  groupId: string,\n  title: string\n): Promise\u003cvoid\u003e {\n  const first = commits[0];\n  const last = commits[commits.length - 1];\n  \n  // Add Start and Title to first commit\n  await addTrailersToCommit(first.hash, {\n    'Taspr-Group-Start': groupId,\n    'Taspr-Group-Title': title,\n  });\n  \n  // Add End to last commit (if different from first)\n  if (last.hash !== first.hash) {\n    await addTrailersToCommit(last.hash, {\n      'Taspr-Group-End': groupId,\n    });\n  }\n}\n```\n\n## Warnings\nIf selected commits have existing PRs:\n```\n⚠ Warning: Commit b2c3d4e5 has open PR #145. \n  Grouping it will close PR #145 when you sync.\n```\n\n## Testing\n- Create group from 2 commits\n- Create group from all commits\n- Validate contiguous requirement\n- Warn about existing PRs\n\n## Files to Create\n- src/cli/commands/group.ts\n- src/core/group.ts\n\n## Acceptance Criteria\n- [ ] Interactive commit selection\n- [ ] Validates contiguous selection\n- [ ] Adds correct trailers to correct commits\n- [ ] Warns about existing PRs\n- [ ] Confirms before making changes","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-25T14:34:15.681194-05:00","updated_at":"2026-01-10T00:36:02.202783-05:00","closed_at":"2026-01-01T22:45:35.437247-05:00","close_reason":"Replaced by unified group TUI - see taspr-7mu for revised plan","dependencies":[{"issue_id":"spry-cso","depends_on_id":"spry-r22","type":"parent-child","created_at":"2025-12-25T14:34:19.387363-05:00","created_by":"daemon"},{"issue_id":"spry-cso","depends_on_id":"spry-gd5","type":"blocks","created_at":"2025-12-25T14:34:19.666321-05:00","created_by":"daemon"},{"issue_id":"spry-cso","depends_on_id":"spry-gd5","type":"depends-on","created_at":"2025-12-25T14:34:19.666321-05:00","created_by":"daemon"}]}
{"id":"spry-d0k","title":"Epic 4: Update PRs After Local Changes","description":"## Goal\nWhen commits change (amend, rebase), update the corresponding GitHub branches to keep PRs in sync.\n\n## Background\n\n### The Update Problem\nAfter commits are amended or rebased:\n- Commit hashes change\n- Local branch diverges from remote\n- PRs show stale code\n\ntaspr needs to detect these changes and force-push updated branches.\n\n### How Changes Are Detected\nCompare local commit hash to remote branch tip:\n```bash\ngit rev-parse taspr/user/a1b2c3d4  # Remote branch tip\ngit rev-parse HEAD~2               # Local commit for that PRUnit\n```\n\nIf they differ, the branch needs updating.\n\n## Workflow\n\n1. User amends a commit or rebases\n2. User runs `taspr sync`\n3. For each PRUnit:\n   - Compare local commit to remote branch\n   - If different, force-push the branch\n4. Report updated branches/PRs\n\n## Implementation Approach\n\n### Change Detection\n```typescript\nasync function getBranchCommit(branchName: string): Promise\u003cstring | null\u003e {\n  const result = await $\\`git rev-parse origin/${branchName}\\`.nothrow();\n  return result.exitCode === 0 ? result.stdout.toString().trim() : null;\n}\n\nasync function needsUpdate(unit: PRUnit, branchName: string): Promise\u003cboolean\u003e {\n  const remote = await getBranchCommit(branchName);\n  const local = unit.commits[unit.commits.length - 1];\n  return remote !== local;\n}\n```\n\n### Force Push\n```typescript\nasync function updateBranch(commitHash: string, branchName: string): Promise\u003cvoid\u003e {\n  await $\\`git push --force origin ${commitHash}:refs/heads/${branchName}\\`;\n}\n```\n\n## Deliverable\nRunning `taspr sync` force-pushes branches where commit hashes changed, keeping PRs in sync with local state.\n\n## Dependencies\n- Epic 3 must be complete (branches and PRs exist)\n\n## MVP Note\nAfter Epic 4, you have a working MVP:\n- Create commits with IDs\n- Push as stacked PRs\n- Update PRs when local commits change\n\n## Testable Outcome\nAmending a commit and running sync updates the PR on GitHub.","status":"closed","priority":1,"issue_type":"epic","created_at":"2025-12-25T14:29:07.59809-05:00","updated_at":"2026-01-10T00:36:02.187612-05:00","closed_at":"2025-12-30T00:25:32.087209-05:00","close_reason":"All child tasks completed: change detection, force push, view command, and git config options are all implemented.","dependencies":[{"issue_id":"spry-d0k","depends_on_id":"spry-ce1","type":"blocks","created_at":"2025-12-25T14:29:12.092882-05:00","created_by":"daemon"},{"issue_id":"spry-d0k","depends_on_id":"spry-ce1","type":"depends-on","created_at":"2025-12-25T14:29:12.092882-05:00","created_by":"daemon"}]}
{"id":"spry-d61","title":"Flag test failures in story output","description":"Test success is implied, but failures should be clearly visible in the story output so they can be quickly identified.\n\nOptions to consider:\n- Add a \"FAILED\" marker to section headings for failed tests\n- Include the failure reason/assertion message\n- Use a different file naming convention for failed tests\n- Add a summary section at the top listing any failures\n\nThe Story API will need a way to capture test failure state, possibly via a `story.fail(reason)` method or by checking test results in `afterAll`.","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-09T12:11:53.874662-05:00","updated_at":"2026-01-10T00:36:02.170428-05:00","closed_at":"2026-01-09T22:57:33.139561-05:00","close_reason":"Closed"}
{"id":"spry-d6j","title":"taspr-inmem-rebase","description":"# In-Memory Rebase (Cherry-Pick Sequence)\n\nImplement true rebasing onto a new base using in-memory merge-tree.\n\n## Function\n\n```typescript\ninterface RebaseResult {\n  ok: true;\n  newTip: string;\n} | {\n  ok: false;\n  conflictCommit: string;\n  conflictInfo: string;\n}\n\nasync function inMemoryRebase(\n  onto: string,\n  commits: string[],  // Commits to replay (oldest first)\n  options: GitOptions = {}\n): Promise\u003cRebaseResult\u003e\n```\n\n## Algorithm\n\n```typescript\nlet currentTip = onto;\n\nfor (const commit of commits) {\n  const parent = await getParent(commit);  // Original parent\n  \n  // Three-way merge: base=original parent, ours=currentTip, theirs=commit\n  const mergeResult = await mergeTree(parent, currentTip, commit);\n  \n  if (!mergeResult.ok) {\n    return { ok: false, conflictCommit: commit, ... };\n  }\n  \n  const message = await getCommitMessage(commit);\n  const env = await getAuthorEnv(commit);  // Author only (committer = now)\n  \n  currentTip = await createCommit(mergeResult.tree, [currentTip], message, env);\n}\n\nreturn { ok: true, newTip: currentTip };\n```\n\n## Key Points\n- Uses `git merge-tree --write-tree` for three-way merge\n- Preserves author info, updates committer (standard rebase behavior)\n- On conflict: returns immediately, nothing modified\n- On success: returns new tip SHA (caller finalizes)\n\n## Usage\n- `rebaseOntoMain`: Rebase stack onto origin/main\n- Future: Rebase with reordering\n\n## Conflict Handling\nWhen conflict detected:\n1. Return error with conflict info\n2. Offer user choice: cancel or fall back to traditional rebase\n3. If fallback: run `git rebase` traditionally for conflict resolution\n\n## Tests\n- Clean rebase (no conflicts)\n- Conflict detection (verify nothing modified)\n- Author info preserved, committer updated","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-08T22:11:01.54538-05:00","updated_at":"2026-01-08T22:46:14.171822-05:00","closed_at":"2026-01-08T22:46:14.171822-05:00","close_reason":"Closed","dependencies":[{"issue_id":"spry-d6j","depends_on_id":"spry-2x9","type":"blocks","created_at":"2026-01-08T22:11:06.168737-05:00","created_by":"don.denton"}]}
{"id":"spry-dcq","title":"Fetch PR comment threads","description":"## Goal\nGet comment thread resolution status for PRs.\n\n## Implementation\n\n```typescript\n// src/github/pr.ts\n\ninterface CommentStatus {\n  total: number;\n  resolved: number;\n}\n\nasync function getPRCommentStatus(prNumber: number): Promise\u003cCommentStatus\u003e {\n  const result = await $\\`gh api repos/{owner}/{repo}/pulls/\\${prNumber}/comments --jq 'length'\\`;\n  const total = parseInt(result.stdout.toString().trim(), 10);\n  \n  // GraphQL needed for resolved count\n  const query = \\`\n    query {\n      repository(owner: \"{owner}\", name: \"{repo}\") {\n        pullRequest(number: \\${prNumber}) {\n          reviewThreads(first: 100) {\n            nodes {\n              isResolved\n            }\n          }\n        }\n      }\n    }\n  \\`;\n  \n  const gqlResult = await $\\`gh api graphql -f query='\\${query}'\\`;\n  const threads = JSON.parse(gqlResult.stdout.toString())\n    .data.repository.pullRequest.reviewThreads.nodes;\n  \n  const resolved = threads.filter((t: any) =\u003e t.isResolved).length;\n  \n  return { total: threads.length, resolved };\n}\n```\n\n## Display\n```\n💬 3/5  # 3 of 5 threads resolved\n```\n\nWhen all resolved, don't show indicator.\n\n## Testing\n- PR with unresolved threads\n- PR with all threads resolved\n- PR with no review threads\n\n## Files to Modify\n- src/github/pr.ts\n\n## Acceptance Criteria\n- [ ] Returns thread count and resolved count\n- [ ] Uses GraphQL API for resolution status\n- [ ] Handles PRs without review threads","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-25T14:32:47.011606-05:00","updated_at":"2026-01-10T00:36:02.171894-05:00","closed_at":"2025-12-31T13:36:01.842102-05:00","close_reason":"Implemented getPRCommentStatus function with GraphQL API, added unit tests for computeCommentStatus, and integration tests for PR comment thread resolution status","dependencies":[{"issue_id":"spry-dcq","depends_on_id":"spry-7qh","type":"parent-child","created_at":"2025-12-25T14:32:50.920704-05:00","created_by":"daemon"}]}
{"id":"spry-ddo","title":"Update sync message to show only changed branches count","description":"Currently sync shows 'Pushing N branch(es)...' where N is the total number of PR units. It should instead show only the count of branches that actually have changes to push, not branches that are already up-to-date.","status":"open","priority":3,"issue_type":"feature","created_at":"2025-12-29T20:42:51.590536-05:00","updated_at":"2026-01-10T00:36:02.165157-05:00"}
{"id":"spry-dfh","title":"Prevent fixup!/amend! commits from auto-reordering during rebases","description":"## Problem\nGit's `rebase --autosquash` automatically reorders `fixup!` and `amend!` commits to be placed after their target commits. This can interfere with our custom rebase operations in the group TUI and other places.\n\n## Solution\nEnsure all our rebasing operations (group rebase, sync rebase, etc.) do NOT use `--autosquash` or explicitly disable it with `--no-autosquash` to prevent unexpected commit reordering.\n\n## Files to Check\n- `src/git/group-rebase.ts` - group reordering rebases\n- Any other files that invoke `git rebase`\n\n## Acceptance Criteria\n- All rebase commands explicitly use `--no-autosquash` \n- Test with a stack containing `fixup! \u003ccommit-msg\u003e` commits to verify they stay in place\n- Document this behavior if needed","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-02T11:20:47.826886-05:00","updated_at":"2026-01-10T00:36:02.201479-05:00","closed_at":"2026-01-02T12:02:33.757385-05:00","close_reason":"Closed","dependencies":[{"issue_id":"spry-dfh","depends_on_id":"spry-r22","type":"parent-child","created_at":"2026-01-02T11:20:56.54861-05:00","created_by":"dondenton"}]}
{"id":"spry-djk","title":"Create Story API and logger","description":"Read the parent epic spry-mbn for full context.\n\n## Task\nCreate the Story API in tests/helpers/story.ts that allows tests to log narratives and command outputs.\n\n## Interface\n\n```\ninterface Story {\n  begin(testName: string): void;\n  narrate(text: string): void;\n  log(result: CommandResult): void;\n  end(): void;\n  flush(): Promise\u003cvoid\u003e;\n}\n```\n\n## Implementation\n\nStoryLogger class that:\n- Checks TASPR_STORY_TEST_LOGGING=1 env var to enable/disable\n- Buffers entries as interleaved narrate/command entries\n- On flush(), writes both .md (ANSI stripped) and .ansi (colors preserved) to test-logs/\n- Uses stripAnsi regex: /\\x1b\\[[0-9;]*m/g\n\n## Test ID Sanitization\n\nThe test fixtures create repos with random IDs (e.g., `humble-panda-zl3`) that appear throughout output. These must be stripped from story logs to create stable, readable documentation.\n\n**What to strip:**\n- Branch names: `feature-humble-panda-zl3` → `feature-{test-id}`\n- Commit messages: `First commit [humble-panda-zl3]` → `First commit`\n- Anywhere else the test ID appears in stdout/stderr\n\n**Implementation approach:**\n- `createStory()` accepts an optional `testId` parameter\n- When set, the Story replaces all occurrences of the test ID with a placeholder or removes it entirely\n- This happens during `log()` before buffering, so both .md and .ansi outputs are clean\n\n**Example transformation:**\n```\nStack: feature-humble-panda-zl3 (3 commits, PRs: 0/2 opened)\n  ○ First grouped commit [humble-panda-zl3] [group-abc]\n```\nbecomes:\n```\nStack: feature-{id} (3 commits, PRs: 0/2 opened)\n  ○ First grouped commit [group-abc]\n```\n\n## Output Format\n\nEach story section in the markdown:\n```\n---\n\n## {testName}\n\n{narrative text}\n\n### `{command}`\n\n```\n{stdout}\n```\n\n---\n```\n\n## Files\n- tests/helpers/story.ts (new file)\n\n## Acceptance\n- Story API works when env var is set\n- No-ops silently when env var is not set\n- Generates readable markdown output\n- Test IDs are sanitized from output when testId is provided","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-05T00:33:10.602497-05:00","updated_at":"2026-01-10T00:36:02.186157-05:00","closed_at":"2026-01-09T10:36:55.852173-05:00","close_reason":"Implemented Story API with test ID sanitization","dependencies":[{"issue_id":"spry-djk","depends_on_id":"spry-wv7","type":"blocks","created_at":"2026-01-05T00:33:48.112626-05:00","created_by":"dondenton"}]}
{"id":"spry-dlc","title":"Add input validation for branch names, PR titles, commit IDs","description":"Branch names with special characters, empty PR titles, or malformed IDs aren't validated - they fail at the git/GitHub API level with unhelpful errors. Validate inputs early with clear messages.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-10T00:28:12.791414-05:00","created_by":"don.denton","updated_at":"2026-01-11T21:47:30.891428-05:00","closed_at":"2026-01-11T21:47:30.891428-05:00","close_reason":"Closed","dependencies":[{"issue_id":"spry-dlc","depends_on_id":"spry-do5","type":"parent-child","created_at":"2026-01-10T01:04:18.481018-05:00","created_by":"don.denton"}]}
{"id":"spry-do5","title":"Epic 9: Polish and Distribution","description":"## Goal\nProduction-ready CLI with good error handling and installation.\n\n## Background\nAfter all features are implemented, this epic focuses on:\n- Consistent, helpful error messages\n- Dependency checks (gh CLI)\n- Cross-platform builds\n- Easy installation\n- Documentation\n\n## Deliverable\ntaspr can be installed and used on a fresh machine without friction.\n\n## Dependencies\n- All previous epics should be complete\n\n## Priority\nP3 - Release prep after features are stable.\n\n## Key Areas\n\n### Error Messages\nEvery error should:\n- Explain what went wrong\n- Suggest how to fix it\n- Include relevant context (commit hashes, PR numbers)\n\n### gh CLI Dependency\ntaspr requires gh CLI for GitHub operations:\n- Check for installation\n- Check for authentication\n- Clear messages if missing\n\n### Cross-Platform\nSupport:\n- macOS (Intel and Apple Silicon)\n- Linux (x64 and ARM64)\n- (Optional) Windows\n\n### Installation\n- `curl | bash` installer for Unix\n- npm package fallback\n- Direct binary download from releases\n\n### Documentation\n- README with quick start\n- Command reference\n- Troubleshooting guide\n- Update CLAUDE.md with real commands","status":"open","priority":3,"issue_type":"epic","created_at":"2025-12-25T14:47:40.093629-05:00","updated_at":"2026-01-10T00:36:02.199275-05:00"}
{"id":"spry-dus","title":"Handle GitHub API pagination for large repos","description":"gh pr list returns only the first page. Repos with 100+ PRs will have missing data during cleanup operations. Need to handle pagination properly.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-10T00:28:12.620863-05:00","created_by":"don.denton","updated_at":"2026-01-11T20:48:07.358625-05:00","closed_at":"2026-01-11T20:48:07.358625-05:00","close_reason":"Added --limit flags to gh pr list calls (500 for batch ops, 100 for single branch)","dependencies":[{"issue_id":"spry-dus","depends_on_id":"spry-do5","type":"parent-child","created_at":"2026-01-10T01:04:18.386497-05:00","created_by":"don.denton"}]}
{"id":"spry-e17","title":"Behind detection (stack vs main)","description":"## Goal\nDetect when the stack is behind origin/main and needs rebasing.\n\n## Implementation\n\n```typescript\n// src/git/rebase.ts\n\nasync function isStackBehindMain(): Promise\u003cboolean\u003e {\n  const defaultBranch = await getDefaultBranch();\n  \n  // Fetch latest\n  await $\\`git fetch origin \\${defaultBranch}\\`;\n  \n  // Get merge-base\n  const mergeBase = await $\\`git merge-base HEAD origin/\\${defaultBranch}\\`.text();\n  \n  // Get current main tip\n  const mainTip = await $\\`git rev-parse origin/\\${defaultBranch}\\`.text();\n  \n  // If merge-base != main tip, we're behind\n  return mergeBase.trim() !== mainTip.trim();\n}\n\nasync function getCommitsBehind(): Promise\u003cnumber\u003e {\n  const defaultBranch = await getDefaultBranch();\n  const result = await $\\`git rev-list HEAD..origin/\\${defaultBranch} --count\\`.text();\n  return parseInt(result.trim(), 10);\n}\n```\n\n## Usage in Sync\n```typescript\nasync function sync() {\n  const behind = await isStackBehindMain();\n  \n  if (behind) {\n    const count = await getCommitsBehind();\n    console.log(\\`Stack is \\${count} commit(s) behind origin/main\\`);\n    \n    // Proceed with rebase...\n  }\n}\n```\n\n## Testing\n- Stack is up to date\n- Stack is behind by N commits\n- Stack has diverged (both ahead and behind)\n\n## Files to Create\n- src/git/rebase.ts\n\n## Acceptance Criteria\n- [ ] Detects when stack is behind\n- [ ] Reports number of commits behind\n- [ ] Fetches latest before checking","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-25T14:36:13.294509-05:00","updated_at":"2026-01-10T00:36:02.175967-05:00","closed_at":"2025-12-31T13:59:29.327102-05:00","close_reason":"Implemented src/git/behind.ts with isStackBehindMain() and getCommitsBehind() functions. All 6 unit tests passing.","dependencies":[{"issue_id":"spry-e17","depends_on_id":"spry-efn","type":"parent-child","created_at":"2025-12-25T14:36:17.346843-05:00","created_by":"daemon"}]}
{"id":"spry-e6uy","title":"Fix hardcoded 'main' in land.ts","description":"## Problem\nThe `land` command has hardcoded 'main' that breaks for repos using master/develop/trunk as default branch.\n\n## Hardcoded locations in land.ts:\n- Line 91: `console.log(\\`✓ Merged PR #${unit.pr.number} to main\\`)`\n- Lines 160-162: `if (currentBase !== \"main\")` and `retargetPR(..., \"main\")`\n- Lines 169-171: Same pattern for next PR retargeting\n- Lines 215-217: Same pattern in single PR landing\n\n## Also in github/pr.ts:\n- Line 540: `landPR(prNumber, targetBranch = \"main\")` - default param\n\n## Fix\nReplace hardcoded 'main' with `(await getSpryConfig()).defaultBranch`\n\nImport needed: `import { getSpryConfig } from \"../../git/config.ts\";`\n\n## Files to modify:\n- src/cli/commands/land.ts\n- src/github/pr.ts (change default param)","status":"open","priority":1,"issue_type":"bug","owner":"don@happycollision.com","created_at":"2026-01-17T00:44:25.389455-05:00","created_by":"Don Denton","updated_at":"2026-01-17T00:44:25.389455-05:00"}
{"id":"spry-ee3","title":"Add documentation for temp commit prefixes","description":"Document the taspr.tempCommitPrefixes git config option in the GitHub wiki/README. Explain:\n- Default prefixes (WIP, fixup!, amend!, squash!)\n- How to customize: git config taspr.tempCommitPrefixes \"WIP,DRAFT\"\n- How to disable: git config taspr.tempCommitPrefixes \"\"\n- Behavior: branches still pushed for stacking, but PRs not created\n- Escape hatch: grouping allows PR creation\n\nAlso: Update TEMP_COMMITS_DOC_URL placeholder in src/cli/commands/sync.ts with the real URL.","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-03T13:43:16.051082-05:00","updated_at":"2026-01-10T00:36:02.166638-05:00","closed_at":"2026-01-03T14:04:47.296143-05:00","close_reason":"Added documentation to README.md under Configuration \u003e Temporary Commits section. Includes config examples, default prefixes, behavior description, and fixup! workflow example. Updated TEMP_COMMITS_DOC_URL placeholder with actual GitHub link."}
{"id":"spry-ef4","title":"taspr-inmem-finalize","description":"# Finalize In-Memory Operations\n\nImplement the finalization step that updates refs and optionally resets working directory.\n\n## Function\n\n```typescript\nasync function finalizeRewrite(\n  branch: string,\n  oldTip: string,\n  newTip: string,\n  options: GitOptions = {}\n): Promise\u003cvoid\u003e\n```\n\n## Algorithm\n\n```typescript\nconst oldTree = await getTree(oldTip);\nconst newTree = await getTree(newTip);\n\n// Update branch ref atomically with compare-and-swap\nawait updateRef(\\`refs/heads/\\${branch}\\`, newTip, oldTip);\n\n// Only reset if tree changed\n// Skip for message-only or trailer-only changes\nif (oldTree !== newTree) {\n  await $\\`git reset --hard HEAD\\`;\n}\n```\n\n## Key Optimization\n**Tree comparison determines reset need:**\n- Message-only changes: Same tree → no reset needed\n- Trailer additions: Same tree → no reset needed\n- Actual content changes (rebase): Different tree → reset needed\n\nThis is why in-memory is so fast for trailer operations - the working directory is never touched.\n\n## Safety\n- Uses compare-and-swap to prevent race conditions\n- Creates reflog entry automatically\n- If reset fails, ref is still updated (safe state)\n\n## Tests\n- Message-only change: verify no reset\n- Content change: verify reset happens\n- Compare-and-swap failure handling","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-08T22:11:01.751182-05:00","updated_at":"2026-01-10T00:36:02.182947-05:00","closed_at":"2026-01-08T22:46:14.175095-05:00","close_reason":"Closed"}
{"id":"spry-efn","title":"Epic 8: Rebase and Conflict Handling","description":"## Goal\nHandle rebasing onto updated main and conflict resolution.\n\n## Background\n\n### The Rebase Problem\nAs main advances, stacks fall behind. `taspr sync` should:\n1. Detect when stack is behind origin/main\n2. Rebase stack onto latest main\n3. Handle conflicts gracefully\n4. Update all affected PR branches\n\n### Conflict Scenarios\n1. **Automatic resolve**: Git handles the conflict automatically\n2. **Manual resolve**: User must fix conflicts\n3. **Stack cascade**: Rebasing bottom changes all commits above\n\n## Workflow\n\n### Normal Rebase\n```\n$ taspr sync\n\n✓ Rebased onto origin/main (4 commits)\n✓ Updated 3 PR branches\n```\n\n### Conflict\n```\n$ taspr sync\n\nRebasing onto origin/main...\n✗ Conflict in src/auth.ts\n\n  Please resolve the conflict and run:\n    git add src/auth.ts\n    git rebase --continue\n    taspr sync\n```\n\n## Deliverable\n`taspr sync` rebases if behind origin/main, with clear conflict handling.\n\n## Dependencies\n- Epic 4 must be complete (branch updates)\n\n## Key Considerations\n- Preserving Taspr-Commit-Id trailers through rebase\n- Updating all affected branches after rebase\n- Clear instructions for manual conflict resolution\n\n## Priority\nP2 - Robustness feature after MVP.","status":"closed","priority":2,"issue_type":"epic","created_at":"2025-12-25T14:35:58.534692-05:00","updated_at":"2026-01-10T00:36:02.175606-05:00","closed_at":"2025-12-31T14:20:52.111538-05:00","close_reason":"Closed","dependencies":[{"issue_id":"spry-efn","depends_on_id":"spry-d0k","type":"blocks","created_at":"2025-12-25T14:36:02.243595-05:00","created_by":"daemon"},{"issue_id":"spry-efn","depends_on_id":"spry-d0k","type":"depends-on","created_at":"2025-12-25T14:36:02.243595-05:00","created_by":"daemon"}]}
{"id":"spry-egg","title":"Sync command (ID injection only)","description":"## Goal\nImplement the `taspr sync` command for Epic 2 scope: adding IDs to commits.\n\n## Background\nAt this stage, sync does one thing: ensure all commits have Taspr-Commit-Id trailers.\n\nLater epics will extend sync to:\n- Push branches to GitHub (Epic 3)\n- Update PR branches (Epic 4)\n- Rebase onto main (Epic 8)\n\n## Command Implementation\n\n```typescript\n// src/cli/commands/sync.ts\nimport { Command } from 'commander';\n\nexport const syncCommand = new Command('sync')\n  .description('Sync stack state (add IDs, push PRs)')\n  .action(async () =\u003e {\n    // Check working tree\n    await requireCleanWorkingTree();\n    \n    // Parse current stack\n    const result = await parseStack();\n    if (!result.ok) {\n      console.error(formatValidationError(result));\n      process.exit(1);\n    }\n    \n    // Find commits without IDs\n    const needsId = result.units\n      .flatMap(u =\u003e u.commits)\n      .filter(c =\u003e !c.trailers['Taspr-Commit-Id']);\n    \n    if (needsId.length === 0) {\n      console.log('✓ All commits have IDs');\n      return;\n    }\n    \n    // Add IDs via rebase\n    console.log(`Adding IDs to ${needsId.length} commit(s)...`);\n    await injectMissingIds();\n    \n    console.log('✓ Added Taspr-Commit-Id to commits');\n  });\n```\n\n## Output\n\n### When IDs added\n```\n$ taspr sync\n\nAdding IDs to 3 commit(s)...\n✓ Added Taspr-Commit-Id to 3 commits:\n  • a1b2c3d4 Add user model\n  • b2c3d4e5 Add login endpoint\n  • c3d4e5f6 Add validation\n```\n\n### When already up to date\n```\n$ taspr sync\n\n✓ All commits have Taspr-Commit-Id\n```\n\n### When dirty\n```\n$ taspr sync\n\n✗ Error: Cannot sync with uncommitted changes\n  ...\n```\n\n## Integration with View\nAfter sync, `taspr view` will show the new IDs:\n\n```\n$ taspr view\n\nStack: feature/auth (3 commits, 3 PRs)\n───────────────────────────────────────────────────────────────────────────\n  ○ Add user model\n    └─ a1b2c3d4\n...\n```\n\n## Testing\n1. Stack with no IDs → adds IDs, reports count\n2. Stack with all IDs → no-op, reports up to date\n3. Dirty working tree → blocks with error\n4. Integration: sync then view shows IDs\n\n## Files to Create/Modify\n- src/cli/commands/sync.ts (create)\n- src/cli/index.ts (modify) - Register sync command\n\n## Acceptance Criteria\n- [ ] Adds IDs to commits without them\n- [ ] Reports how many commits were modified\n- [ ] No-op if all commits have IDs\n- [ ] Blocks on dirty working tree\n- [ ] Has integration tests","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T14:26:05.806801-05:00","updated_at":"2026-01-10T00:36:02.168565-05:00","closed_at":"2025-12-26T21:32:31.055581-05:00","close_reason":"Implemented taspr sync command with 5 integration tests","dependencies":[{"issue_id":"spry-egg","depends_on_id":"spry-sbb","type":"parent-child","created_at":"2025-12-25T14:26:09.683543-05:00","created_by":"daemon"},{"issue_id":"spry-egg","depends_on_id":"spry-laf","type":"blocks","created_at":"2025-12-25T14:26:09.957219-05:00","created_by":"daemon"},{"issue_id":"spry-egg","depends_on_id":"spry-laf","type":"depends-on","created_at":"2025-12-25T14:26:09.957219-05:00","created_by":"daemon"},{"issue_id":"spry-egg","depends_on_id":"spry-toz","type":"depends-on","created_at":"2025-12-25T14:26:10.230538-05:00","created_by":"daemon"},{"issue_id":"spry-egg","depends_on_id":"spry-toz","type":"blocks","created_at":"2025-12-25T14:26:10.230538-05:00","created_by":"daemon"}]}
{"id":"spry-ei6","title":"Fix group integrity when fixup! commits are squashed","description":"## Problem\n\nWhen a group contains a fixup! commit that gets squashed via `git rebase --autosquash`, the group loses a commit and becomes invalid (missing end marker). This causes sync to fail with a group error.\n\n**Example scenario:**\n1. Create commit A (single commit, gets PR)\n2. Create `fixup! A` commit\n3. Group them together (now A has Group-Start, fixup! has Group-End)\n4. Run `git rebase -i --autosquash origin/main` - fixup! squashes into A\n5. Group-End trailer is lost\n6. `taspr sync` fails: unclosed group\n\n## Possible Solutions\n\n1. **All grouped commits get shared ID** - Instead of Start/End markers, all commits in a group share the same Taspr-Commit-Id. Squashing doesn't break anything since the ID persists.\n\n2. **Custom autosquash command** - `taspr squash` that handles group integrity before/after rebase. Knows which commits are grouped and repairs trailers.\n\n3. **Group repair on sync** - Detect orphaned Group-Start without Group-End and auto-repair (convert to single commit).\n\n4. **Warn before breaking operation** - Detect when autosquash would break groups and warn user.\n\n## Related Documentation\n\nThe README documents the fixup! workflow but doesn't mention this edge case. Look for marker:\n`FIXUP_GROUP_DOCS` in README.md - update after resolving this issue.\n\n## Acceptance Criteria\n\n- [ ] Squashing fixup! commits doesn't break group integrity\n- [ ] Clear error or auto-repair when group becomes invalid\n- [ ] Documentation updated (remove FIXUP_GROUP_DOCS marker)","status":"closed","priority":1,"issue_type":"bug","created_at":"2026-01-03T14:15:25.350772-05:00","updated_at":"2026-01-10T00:36:02.184409-05:00","closed_at":"2026-01-03T21:24:33.669761-05:00","close_reason":"Planning complete. Implementation plan created. Solution: Replace Taspr-Group-Start/End markers with Taspr-Group and Taspr-Group-Title on ALL commits in a group for squash resilience.","dependencies":[{"issue_id":"spry-ei6","depends_on_id":"spry-5ky","type":"relates-to","created_at":"2026-01-03T14:18:19.81405-05:00","created_by":"dondenton"}]}
{"id":"spry-esa","title":"Trailer writing (add/update trailers)","description":"## Goal\nAdd the ability to write trailers to commit messages, not just read them.\n\n## Background\nEpic 1 implemented trailer reading. Now we need to write trailers:\n- Add new trailers to commits\n- Preserve existing trailers\n\n## Implementation\n\n### Using git interpret-trailers\n```bash\n# Add a trailer to a message\necho \"commit message\" | git interpret-trailers --trailer \"Taspr-Commit-Id: a1b2c3d4\"\n\n# Add multiple trailers\necho \"commit message\" | git interpret-trailers \\\n  --trailer \"Taspr-Commit-Id: a1b2c3d4\" \\\n  --trailer \"Taspr-Group-Start: f7e8d9c0\"\n```\n\n### Function Signatures\n```typescript\n// src/git/trailers.ts\n\n// Add trailers to a message string\nexport function addTrailers(\n  message: string, \n  trailers: Record\u003cstring, string\u003e\n): Promise\u003cstring\u003e\n\n// Add trailers to a specific commit (amends the commit)\nexport async function addTrailersToCommit(\n  commitHash: string, \n  trailers: Record\u003cstring, string\u003e\n): Promise\u003cvoid\u003e\n```\n\n### Amending a Commit\n```typescript\nasync function addTrailersToCommit(hash: string, trailers: Record\u003cstring, string\u003e) {\n  // Get current message\n  const message = await $`git log -1 --format=%B ${hash}`.text();\n  \n  // Add trailers\n  const newMessage = await addTrailers(message, trailers);\n  \n  // Amend commit (only works for HEAD)\n  // For non-HEAD commits, use rebase\n  await $`git commit --amend --no-edit -m ${newMessage}`;\n}\n```\n\n### Edge Cases\n1. **Message already has the trailer**: Update value or skip\n2. **Message has other trailers**: Preserve them\n3. **Message has no body**: Still works (trailers after blank line)\n\n## Testing\n- Add trailer to message without trailers\n- Add trailer to message with existing trailers\n- Add multiple trailers at once\n- Preserve existing unrelated trailers\n\n## Files to Modify\n- src/git/trailers.ts\n\n## Acceptance Criteria\n- [ ] Can add single trailer to message\n- [ ] Can add multiple trailers to message\n- [ ] Preserves existing trailers\n- [ ] Uses git interpret-trailers for correctness\n- [ ] Has tests for various scenarios","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T14:25:02.634601-05:00","updated_at":"2026-01-10T00:36:02.169614-05:00","closed_at":"2025-12-26T21:20:05.129066-05:00","close_reason":"Implemented addTrailers in src/git/trailers.ts with 6 tests","dependencies":[{"issue_id":"spry-esa","depends_on_id":"spry-sbb","type":"parent-child","created_at":"2025-12-25T14:25:06.604931-05:00","created_by":"daemon"},{"issue_id":"spry-esa","depends_on_id":"spry-44e","type":"blocks","created_at":"2025-12-25T14:25:06.875423-05:00","created_by":"daemon"},{"issue_id":"spry-esa","depends_on_id":"spry-44e","type":"depends-on","created_at":"2025-12-25T14:25:06.875423-05:00","created_by":"daemon"}]}
{"id":"spry-euc","title":"Add story logging to sync.test.ts","description":"Read the parent epic spry-ww0 for full context.\n\n## Task\nAdd story logging annotations to tests/integration/sync.test.ts as the first integration test file.\n\n## Pattern\n\n1. Import and create story at describe level:\n```\nimport { createStory } from \"../helpers/story.ts\";\n\ndescribe(\"sync command\", () =\u003e {\n  const story = createStory(\"sync.test.ts\");\n\n  afterAll(async () =\u003e {\n    await story.flush();\n  });\n  ...\n});\n```\n\n2. For each test, add story annotations:\n```\ntest(\"test name\", async () =\u003e {\n  story.begin(\"test name\");\n  story.narrate(\"Plain English description of the scenario...\");\n\n  // ... test setup (no logging needed) ...\n\n  const result = await runSync(repo.path, { open: true });\n  story.log(result);\n  story.end();\n\n  // ... assertions ...\n});\n```\n\n## Guidelines\n- Narratives describe scenarios contextually, not mechanically\n- Focus on what is being demonstrated\n- Err on showing less - only log the key command output\n- Setup steps dont need to be logged unless they add clarity\n\n## Files\n- tests/integration/sync.test.ts\n\n## Acceptance\n- All tests in sync.test.ts have story annotations\n- Running TASPR_STORY_TEST_LOGGING=1 bun test tests/integration/sync.test.ts produces test-logs/sync.md and test-logs/sync.ansi","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-05T00:33:20.666806-05:00","updated_at":"2026-01-09T11:24:03.834833-05:00","closed_at":"2026-01-09T11:24:03.834833-05:00","close_reason":"Added story logging to sync.test.ts","dependencies":[{"issue_id":"spry-euc","depends_on_id":"spry-ycg","type":"blocks","created_at":"2026-01-05T00:33:48.15932-05:00","created_by":"dondenton"}]}
{"id":"spry-f0m","title":"Git config options","description":"## Goal\nSupport configuration via git config for branch prefix and default branch.\n\n## Configuration Options\n\n### taspr.branchPrefix\nCustom prefix for branch names (default: \"taspr\"):\n```bash\ngit config taspr.branchPrefix jaspr\n# Produces: jaspr/msims/a1b2c3d4 instead of taspr/msims/a1b2c3d4\n```\n\n### taspr.defaultBranch\nDefault branch to stack on (default: auto-detect from origin):\n```bash\ngit config taspr.defaultBranch main\n```\n\n## Implementation\n\n```typescript\n// src/git/config.ts\n\ninterface TasprConfig {\n  branchPrefix: string;\n  defaultBranch: string;\n}\n\nasync function getTasprConfig(): Promise\u003cTasprConfig\u003e {\n  const [prefixResult, defaultResult] = await Promise.all([\n    $\\`git config --get taspr.branchPrefix\\`.nothrow(),\n    $\\`git config --get taspr.defaultBranch\\`.nothrow(),\n  ]);\n  \n  const prefix = prefixResult.exitCode === 0 \n    ? prefixResult.stdout.toString().trim() \n    : 'taspr';\n    \n  let defaultBranch: string;\n  if (defaultResult.exitCode === 0) {\n    defaultBranch = defaultResult.stdout.toString().trim();\n  } else {\n    // Auto-detect from origin\n    defaultBranch = await detectDefaultBranch();\n  }\n  \n  return { branchPrefix: prefix, defaultBranch };\n}\n\nasync function detectDefaultBranch(): Promise\u003cstring\u003e {\n  // Method 1: Check remote HEAD\n  const result = await $\\`git symbolic-ref refs/remotes/origin/HEAD\\`.nothrow();\n  if (result.exitCode === 0) {\n    const ref = result.stdout.toString().trim();\n    return ref.replace('refs/remotes/origin/', '');\n  }\n  \n  // Method 2: Common defaults\n  for (const branch of ['main', 'master']) {\n    const exists = await $\\`git rev-parse --verify origin/\\${branch}\\`.nothrow();\n    if (exists.exitCode === 0) return branch;\n  }\n  \n  throw new Error('Could not detect default branch. Set it with: git config taspr.defaultBranch \u003cbranch\u003e');\n}\n```\n\n### Usage\n```typescript\nconst config = await getTasprConfig();\nconst branchName = \\`\\${config.branchPrefix}/\\${username}/\\${prId}\\`;\nconst baseBranch = config.defaultBranch;\n```\n\n## Testing\n- Default prefix → \"taspr\"\n- Custom prefix → uses custom value\n- Default branch auto-detection\n- Custom default branch\n\n## Files to Create/Modify\n- src/git/config.ts (may already exist)\n\n## Acceptance Criteria\n- [ ] Reads branchPrefix from git config\n- [ ] Falls back to \"taspr\" if not set\n- [ ] Reads defaultBranch from git config\n- [ ] Auto-detects default branch from origin if not set\n- [ ] Clear error if can't detect default branch","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T14:30:16.504099-05:00","updated_at":"2026-01-10T00:36:02.164881-05:00","closed_at":"2025-12-29T20:59:08.647802-05:00","close_reason":"Implemented git config options for branchPrefix and defaultBranch. Created src/git/config.ts with getTasprConfig(), detectDefaultBranch(), and getDefaultBranchRef() functions. Updated commands.ts to use configurable default branch instead of hardcoded origin/main. Updated output.ts to display the configured default branch. All 86 tests pass.","dependencies":[{"issue_id":"spry-f0m","depends_on_id":"spry-d0k","type":"parent-child","created_at":"2025-12-25T14:30:20.288564-05:00","created_by":"daemon"}]}
{"id":"spry-ffp","title":"Add story logging to remaining integration tests","description":"Read the parent epic spry-ww0 for full context.\n\n## Task\nAdd story logging to the remaining integration test files, following the pattern established in sync.test.ts (spry-euc).\n\n## Files to Update\n- tests/integration/land.test.ts\n- tests/integration/clean.test.ts  \n- tests/integration/group-fix.test.ts\n- tests/integration/pr-status.test.ts\n\n## Pattern\nSame as sync.test.ts - see spry-euc for the exact pattern.\n\n## Acceptance\n- All integration test files have story annotations\n- Running TASPR_STORY_TEST_LOGGING=1 bun test tests/integration/ produces markdown files for each test file","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-05T00:33:28.022045-05:00","updated_at":"2026-01-09T11:58:17.363085-05:00","closed_at":"2026-01-09T11:58:17.363085-05:00","close_reason":"Closed","dependencies":[{"issue_id":"spry-ffp","depends_on_id":"spry-euc","type":"blocks","created_at":"2026-01-05T00:33:48.205808-05:00","created_by":"dondenton"}]}
{"id":"spry-fgm","title":"taspr-migrate-group","description":"# Migrate group-rebase.ts to In-Memory Operations\n\nReplace traditional rebase operations in \\`src/git/group-rebase.ts\\` with in-memory equivalents.\n\n## Functions to Migrate\n\n### 1. \\`applyGroupSpec\\`\n**Current**: Builds todo list, runs \\`git rebase -i\\` with exec commands\n\n**New Approach**:\n1. Build list of commits needing message changes\n2. Optionally reorder using in-memory rebase if order changed\n3. Rewrite messages for trailer changes\n4. Finalize once at end\n\n### 2. \\`dissolveGroup\\`\n**Current**: Rebase with exec to remove trailers\n\n**New**: Use \\`rewriteCommitChain\\` for message-only changes\n\n### 3. \\`addGroupTrailers\\` / \\`removeGroupTrailers\\`\n**Current**: Rebase with single exec command\n\n**New**: Use \\`rewriteCommitChain\\` for targeted message change\n\n### 4. \\`mergeSplitGroup\\`\n**Current**: Reorders via \\`applyGroupSpec\\`\n\n**New**: Use \\`inMemoryRebase\\` for reorder + message changes\n\n### 5. \\`removeAllGroupTrailers\\`\n**Current**: Rebase with exec on each commit with trailers\n\n**New**: Use \\`rewriteCommitChain\\` to strip all trailers\n\n## Complexity Notes\n- Most operations are message-only → very fast, no reset needed\n- Reordering requires actual merge-tree calls\n- Group spec validation still needed before rewrite\n\n## Tests\n- All existing tests must pass\n- Verify no working directory access for message-only operations","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-08T22:11:23.143816-05:00","updated_at":"2026-01-08T22:56:31.150459-05:00","closed_at":"2026-01-08T22:56:31.150459-05:00","close_reason":"Closed","dependencies":[{"issue_id":"spry-fgm","depends_on_id":"spry-3dn","type":"blocks","created_at":"2026-01-08T22:11:27.836725-05:00","created_by":"don.denton"},{"issue_id":"spry-fgm","depends_on_id":"spry-d6j","type":"blocks","created_at":"2026-01-08T22:11:27.892204-05:00","created_by":"don.denton"}]}
{"id":"spry-fgr","title":"Add test-logs/ to .gitignore","description":"Read the parent epic spry-mbn for full context.\n\n## Task\nAdd test-logs/ directory to .gitignore so generated story logs are not committed.\n\n## Files\n- .gitignore\n\n## Note\nThis is a simple one-liner but listed as a separate task for completeness. Can be done alongside any other task.","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-05T00:33:33.499913-05:00","updated_at":"2026-01-10T00:36:02.202509-05:00","closed_at":"2026-01-09T10:36:55.856335-05:00","close_reason":"Implemented Story API with test ID sanitization","dependencies":[{"issue_id":"spry-fgr","depends_on_id":"spry-mbn","type":"parent-child","created_at":"2026-01-05T00:33:43.981899-05:00","created_by":"dondenton"}]}
{"id":"spry-fx7","title":"Group rebase logic","description":"## Goal\nImplement the rebase logic that reorders commits and adds group trailers after the user confirms their arrangement in the TUI.\n\n## Context\nThis is part of Epic 7: Group Management. After the user arranges commits and assigns groups in the TUI, this module performs the actual git operations:\n1. Reorder commits via interactive rebase\n2. Add group trailers (Taspr-Group-Start, Taspr-Group-Title, Taspr-Group-End) to appropriate commits\n\n## Implementation\n\n### Main Function\n```typescript\ninterface GroupAssignment {\n  commits: string[];  // Commit hashes in this group\n  name: string;       // User-provided group name\n}\n\ninterface ReorderResult {\n  success: boolean;\n  error?: string;\n  conflictFile?: string;\n}\n\nasync function reorderAndGroup(\n  originalOrder: string[],      // Original commit hashes (oldest first)\n  newOrder: string[],           // New commit order\n  groups: GroupAssignment[],    // Groups with their commits and names\n  options: GitOptions = {}\n): Promise\u003cReorderResult\u003e {\n  // 1. Check if reorder is needed\n  const needsReorder = !arraysEqual(originalOrder, newOrder);\n  \n  // 2. Perform rebase to reorder (if needed)\n  if (needsReorder) {\n    const rebaseResult = await rebaseToReorder(originalOrder, newOrder, options);\n    if (!rebaseResult.success) {\n      return rebaseResult;\n    }\n  }\n  \n  // 3. Add group trailers\n  for (const group of groups) {\n    await addGroupTrailers(group.commits, group.name, options);\n  }\n  \n  return { success: true };\n}\n```\n\n### Reordering via Interactive Rebase\n```typescript\nasync function rebaseToReorder(\n  originalOrder: string[],\n  newOrder: string[],\n  options: GitOptions = {}\n): Promise\u003cReorderResult\u003e {\n  const { cwd } = options;\n  const mergeBase = await getMergeBase(options);\n  \n  // Create a sequence editor script that outputs the new order\n  const todoScript = createReorderTodoScript(newOrder);\n  const scriptPath = join(tmpdir(), \\`taspr-reorder-\\${Date.now()}.sh\\`);\n  \n  try {\n    await writeFile(scriptPath, todoScript);\n    await chmod(scriptPath, '755');\n    \n    // Run interactive rebase with custom sequence editor\n    const result = cwd\n      ? await \\$\\`GIT_SEQUENCE_EDITOR=\\${scriptPath} git -C \\${cwd} rebase -i \\${mergeBase}\\`\n          .quiet().nothrow()\n      : await \\$\\`GIT_SEQUENCE_EDITOR=\\${scriptPath} git rebase -i \\${mergeBase}\\`\n          .quiet().nothrow();\n    \n    if (result.exitCode !== 0) {\n      // Check for conflict\n      const conflictInfo = await getConflictInfo(options);\n      if (conflictInfo) {\n        return { \n          success: false, \n          error: 'Rebase conflict',\n          conflictFile: conflictInfo.files[0]\n        };\n      }\n      return { success: false, error: result.stderr.toString() };\n    }\n    \n    return { success: true };\n  } finally {\n    await unlink(scriptPath).catch(() =\u003e {});\n  }\n}\n\nfunction createReorderTodoScript(newOrder: string[]): string {\n  // Script that rewrites the todo file with commits in new order\n  return \\`#!/bin/bash\nset -e\nTODO_FILE=\"\\$1\"\n\n# Write new order\ncat \u003e \"\\$TODO_FILE\" \u003c\u003c 'TODOEOF'\n\\${newOrder.map(hash =\u003e \\`pick \\${hash}\\`).join('\\n')}\nTODOEOF\n\\`;\n}\n```\n\n### Adding Group Trailers\n```typescript\nasync function addGroupTrailers(\n  commits: string[],\n  groupName: string,\n  options: GitOptions = {}\n): Promise\u003cvoid\u003e {\n  const groupId = generateId();  // 8-char hex like existing Taspr-Commit-Id\n  \n  const first = commits[0];\n  const last = commits[commits.length - 1];\n  \n  // Add Start and Title to first commit\n  await addTrailersToCommit(first, {\n    'Taspr-Group-Start': groupId,\n    'Taspr-Group-Title': groupName,\n  }, options);\n  \n  // Add End to last commit (handles single-commit groups too)\n  await addTrailersToCommit(last, {\n    'Taspr-Group-End': groupId,\n  }, options);\n}\n\nasync function addTrailersToCommit(\n  hash: string,\n  trailers: Record\u003cstring, string\u003e,\n  options: GitOptions = {}\n): Promise\u003cvoid\u003e {\n  // Use git rebase --exec to amend the specific commit\n  // Pattern from src/git/rebase.ts injectMissingIds()\n}\n```\n\n## Group Trailers Format\n- First commit in group: \\`Taspr-Group-Start: \u003cid\u003e\\`, \\`Taspr-Group-Title: \u003cname\u003e\\`\n- Last commit in group: \\`Taspr-Group-End: \u003cid\u003e\\`\n- Single-commit groups: both Start/Title and End on same commit\n\n## Existing Patterns to Follow\nSee `src/git/rebase.ts`:\n- `injectMissingIds()` - pattern for `git rebase -i --exec` with temp scripts\n- `rebaseOntoMain()` - pattern for rebase with conflict detection\n- `getConflictInfo()` - pattern for detecting rebase conflicts\n\n## Files to Create\n- src/git/group-rebase.ts\n\n## Testing\n- Unit tests for reorder detection\n- Unit tests for todo script generation\n- Integration tests for actual rebase operations\n- Test single-commit groups\n- Test conflict handling (abort and restore)\n\n## Edge Cases\n1. **No reorder needed**: Skip rebase, just add trailers\n2. **Single-commit group**: Both Start and End on same commit\n3. **Rebase conflict**: Abort rebase, restore original state, return error\n4. **Empty groups**: Should not happen (TUI prevents), but handle gracefully\n\n## Acceptance Criteria\n- [ ] Reorders commits via interactive rebase\n- [ ] Adds correct trailers to correct commits\n- [ ] Handles single-commit groups\n- [ ] Detects and reports rebase conflicts\n- [ ] Aborts cleanly on failure\n- [ ] Preserves existing Taspr-Commit-Id trailers","notes":"## Testing Workflow\nAfter completing implementation:\n1. Run `bun run build` to build the CLI\n2. Run `bun test --no-coverage` to verify all tests pass\n3. Tell the user to run `bun run scenario` and select one of these scenarios for manual testing:\n   - **multiCommitStack** - 3 commits on feature branch (best for testing reorder)\n   - **withTasprIds** - 2 commits with existing Taspr-Commit-Id trailers\n   - **mixedTrailerStack** - some commits have IDs, some don't\n\n## Scenario Usage\nThe `bun run scenario` command spawns a shell in a temp git repo with `taspr` in PATH. Use this to manually verify the rebase logic works correctly. After testing, type `exit` to clean up.\n\n## New Scenarios Needed\nIf testing reveals gaps, consider adding scenarios to `src/scenario/definitions.ts`:\n- A scenario with existing group trailers (for testing group modification)","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-01T22:48:40.229535-05:00","updated_at":"2026-01-10T00:36:02.178851-05:00","closed_at":"2026-01-02T10:33:48.807287-05:00","close_reason":"Closed","dependencies":[{"issue_id":"spry-fx7","depends_on_id":"spry-r22","type":"parent-child","created_at":"2026-01-01T22:48:51.95459-05:00","created_by":"daemon"}]}
{"id":"spry-gd5","title":"Interactive commit selection UI","description":"## Goal\nCreate a checkbox-style UI for selecting commits.\n\n## Implementation Options\n\n### Option 1: @inquirer/prompts (recommended)\n```typescript\nimport { checkbox } from '@inquirer/prompts';\n\nconst selected = await checkbox({\n  message: 'Select commits to group',\n  choices: commits.map((c, i) =\u003e ({\n    name: \\`\\${c.hash.slice(0, 8)} \\${c.subject}\\`,\n    value: i,\n    checked: false,\n  })),\n});\n```\n\n### Option 2: @clack/prompts\n```typescript\nimport { multiselect } from '@clack/prompts';\n\nconst selected = await multiselect({\n  message: 'Select commits to group',\n  options: commits.map((c, i) =\u003e ({\n    label: \\`\\${c.hash.slice(0, 8)} \\${c.subject}\\`,\n    value: i,\n  })),\n});\n```\n\n### Option 3: Custom with keypress\nFor full control, handle stdin directly:\n```typescript\nimport { emitKeypressEvents } from 'readline';\n// Custom implementation\n```\n\n## Validation\n- Selection must be contiguous\n- At least 2 commits for a group\n- Cannot overlap existing groups\n\n```typescript\nfunction validateSelection(indices: number[], commits: CommitInfo[]): ValidationResult {\n  // Check contiguous\n  const sorted = [...indices].sort((a, b) =\u003e a - b);\n  for (let i = 1; i \u003c sorted.length; i++) {\n    if (sorted[i] !== sorted[i - 1] + 1) {\n      return { ok: false, error: 'Selection must be contiguous' };\n    }\n  }\n  \n  // Check not overlapping existing groups\n  // ...\n  \n  return { ok: true };\n}\n```\n\n## Testing\n- Mock stdin for automated tests\n- Manual testing for UX\n\n## Files to Create\n- src/cli/prompts.ts\n\n## Acceptance Criteria\n- [ ] Checkbox selection works\n- [ ] Validates contiguous selection\n- [ ] Shows existing group status\n- [ ] Works in terminal environments","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-25T14:33:58.215597-05:00","updated_at":"2026-01-10T00:36:02.173112-05:00","closed_at":"2026-01-01T22:45:50.811341-05:00","close_reason":"Replaced by unified group TUI - see taspr-7mu for revised plan","dependencies":[{"issue_id":"spry-gd5","depends_on_id":"spry-r22","type":"parent-child","created_at":"2025-12-25T14:34:01.994481-05:00","created_by":"daemon"}]}
{"id":"spry-gx3","title":"Group validation in sync","description":"## Goal\nEnforce group validation during sync: no overlapping groups, no unclosed groups.\n\n## Context\nThis is part of Epic 7: Group Management. Group validation was implemented in Epic 1 for the view command. This task ensures sync also validates and blocks on invalid groups.\n\n## Implementation\n\n```typescript\n// In sync command, after parsing stack\nasync function syncCommand() {\n  const result = await parseStack();\n  \n  if (!result.ok) {\n    console.error(formatValidationError(result));\n    \n    // Provide actionable guidance\n    if (result.error === 'overlapping-groups') {\n      console.error('\\nTo fix, run \\`taspr group\\` to adjust the group boundaries.');\n    } else if (result.error === 'unclosed-group') {\n      console.error('\\nTo fix, either:');\n      console.error('  1. Run \\`taspr group\\` to set the group boundaries');\n      console.error('  2. Run \\`taspr group dissolve\\` to remove the incomplete group');\n    }\n    \n    process.exit(1);\n  }\n  \n  // Continue with sync...\n}\n```\n\n## Error Messages\n\n### Overlapping Groups\n```\n✗ Error: Overlapping groups detected\n\n  Group \"Auth feature\" (f7e8d9c0):\n    starts at b2c3d4e5\n\n  Group \"Login flow\" (a9b8c7d6):\n    starts at c3d4e5f6 (inside \"Auth feature\")\n\n  To fix, run \\`taspr group\\` to adjust the group boundaries.\n```\n\n### Unclosed Group\n```\n✗ Error: Unclosed group starting at commit b2c3d4e5\n\n  Group f7e8d9c0 (\"Auth feature\") has Taspr-Group-Start but no \n  matching Taspr-Group-End was found in subsequent commits.\n  \n  To fix, either:\n    1. Run \\`taspr group\\` to set the group boundaries\n    2. Run \\`taspr group dissolve\\` to remove the incomplete group\n```\n\n## Files to Modify\n- src/cli/commands/sync.ts\n- src/cli/output.ts\n\n## Testing\n- Sync with valid groups passes\n- Sync with overlapping groups fails with actionable message\n- Sync with unclosed group fails with actionable message\n\n## Acceptance Criteria\n- [ ] Sync blocks on overlapping groups\n- [ ] Sync blocks on unclosed groups\n- [ ] Error messages include fix instructions\n- [ ] Points to \\`taspr group\\` and \\`taspr group dissolve\\` commands","notes":"## Testing Workflow\nAfter completing implementation:\n1. Run `bun run build` to build the CLI\n2. Run `bun test --no-coverage` to verify all tests pass\n3. Tell the user to run `bun run scenario` and select one of these scenarios for manual testing:\n   - **withTasprIds** - 2 commits with IDs (test sync with valid stack)\n   - **emptyStack** - Test empty stack handling\n\n## Scenario Usage\nThe `bun run scenario` command spawns a shell in a temp git repo with `taspr` in PATH. After testing, type `exit` to clean up.\n\n## New Scenarios Needed\nAdd to `src/scenario/definitions.ts` for testing validation errors:\n- **unclosedGroup** - Stack with Taspr-Group-Start but no Taspr-Group-End (test sync blocking)\n- **overlappingGroups** - Stack with overlapping group trailers (test sync blocking)","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-25T14:35:38.666664-05:00","updated_at":"2026-01-10T00:36:02.175276-05:00","closed_at":"2026-01-02T11:09:22.507118-05:00","close_reason":"Implemented group validation in sync: uses formatValidationError() for actionable errors pointing to taspr group --fix. Added unclosedGroup and overlappingGroups test scenarios."}
{"id":"spry-hi9","title":"Add GitHub API rate limiting and retry logic","description":"Large stacks or repos with many PRs can hit GitHub rate limits. Operations fail without retry logic or helpful messaging. Add exponential backoff and circuit breaker for GitHub API calls.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-10T00:28:12.5442-05:00","created_by":"don.denton","updated_at":"2026-01-11T14:35:59.991149-05:00","closed_at":"2026-01-11T14:35:59.991149-05:00","close_reason":"Implemented retry wrapper with exponential backoff, jitter, rate limit detection, and concurrency limiting (5 concurrent calls max). All gh CLI calls in pr.ts and api.ts now use ghExecWithLimit.","dependencies":[{"issue_id":"spry-hi9","depends_on_id":"spry-do5","type":"parent-child","created_at":"2026-01-10T01:04:18.341723-05:00","created_by":"don.denton"},{"issue_id":"spry-hi9","depends_on_id":"spry-6yt","type":"blocks","created_at":"2026-01-10T14:57:40.646385-05:00","created_by":"dondenton"}],"comments":[{"id":2,"issue_id":"spry-hi9","author":"dondenton","text":"Analysis of current GitHub API usage:\n\n**Where calls are made:** All centralized in src/github/pr.ts (18 functions wrapping gh CLI). Good refactoring target.\n\n**Current error handling:** Minimal - uses .nothrow() and checks stderr for specific errors. NO retry logic, NO rate limit handling, NO backoff.\n\n**Parallel call patterns (rate limit risk):**\n- sp view: 3 parallel calls per PR (checks, reviews, comments) via Promise.all\n- sp land: Batch fetches merge status for all open PRs in parallel\n- sp sync: Sequential PR creation but parallel cleanup\n\n**What a fix involves:**\n1. Retry wrapper (~100 lines) - exponential backoff for gh calls\n2. Concurrency throttle (~80 lines) - limit to 3-5 concurrent calls  \n3. Update pr.ts (~50 lines) - route calls through wrapper\n4. User messaging for rate limit waits\n\nEstimated: 400-600 lines including tests.\n\nNOTE: The n×n call pattern in sp view is a separate issue (spry-xxx) that should be fixed first to reduce API call volume.","created_at":"2026-01-10T19:57:26Z"}]}
{"id":"spry-hqg","title":"Make story section titles documentation-style","description":"Section titles currently read like test names (e.g., \"reports valid stack when no issues found\"). They should read more like documentation headings.\n\nExample transformation:\n- Before: \"reports valid stack when no issues found\"\n- After: \"Valid stack with no issues\"\n\nThis may require updating the `story.begin()` calls in tests to use documentation-style titles, or adding a transformation in the Story API.","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-09T12:11:53.48154-05:00","updated_at":"2026-01-10T00:36:02.169229-05:00","closed_at":"2026-01-09T22:57:33.047372-05:00","close_reason":"Closed"}
{"id":"spry-hsz","title":"Land --all flag","description":"## Goal\nImplement `taspr land --all` to merge all consecutive ready PRs.\n\n## Behavior\nMerge PRs from the bottom up, stopping at the first non-ready PR.\n\n```\nStack: [#142 ready] → [#143 ready] → [#144 not ready] → [#145 ready]\n\ntaspr land --all merges #142 and #143, then stops at #144.\n```\n\n## Implementation\n\n```typescript\nasync function landAll() {\n  const units = await getEnrichedPRUnits();\n  \n  let merged = 0;\n  \n  for (const unit of units) {\n    if (unit.pr?.state !== 'open') continue;\n    \n    const status = await getPRMergeStatus(unit.pr.number);\n    \n    if (!status.mergeable) {\n      if (merged \u003e 0) {\n        console.log(\\`\\\\nStopping at PR #\\${unit.pr.number} (not ready)\\`);\n      }\n      break;\n    }\n    \n    console.log(\\`Merging PR #\\${unit.pr.number} (\\${unit.title})...\\`);\n    await mergePR(unit.pr.number);\n    console.log(\\`✓ Merged PR #\\${unit.pr.number} to main\\\\n\\`);\n    merged++;\n    \n    // Brief pause for GitHub to update\n    await sleep(1000);\n  }\n  \n  if (merged === 0) {\n    console.log('No ready PRs to merge');\n  } else {\n    console.log(\\`\\\\n✓ Merged \\${merged} PR(s)\\`);\n  }\n}\n```\n\n## Output\n```\n$ taspr land --all\n\nMerging PR #142 (Add user model)...\n✓ Merged PR #142 to main\n\nMerging PR #143 (Add authentication)...\n✓ Merged PR #143 to main\n\nStopping at PR #144 (not ready: CI failing)\n\n✓ Merged 2 PR(s)\n```\n\n## Testing\n- All ready → merges all\n- Some ready → merges until non-ready\n- None ready → reports nothing to merge\n\n## Files to Modify\n- src/cli/commands/land.ts\n\n## Acceptance Criteria\n- [ ] Merges consecutive ready PRs\n- [ ] Stops at first non-ready PR\n- [ ] Reports total merged\n- [ ] Pauses between merges for GitHub sync","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T14:31:44.165633-05:00","updated_at":"2026-01-10T00:36:02.187262-05:00","closed_at":"2025-12-31T00:15:48.111291-05:00","close_reason":"Fully implemented - land command supports --all flag with consecutive PR merging, retargeting, and cleanup","dependencies":[{"issue_id":"spry-hsz","depends_on_id":"spry-oef","type":"parent-child","created_at":"2025-12-25T14:31:51.536244-05:00","created_by":"daemon"},{"issue_id":"spry-hsz","depends_on_id":"spry-4dq","type":"blocks","created_at":"2025-12-25T14:31:51.81248-05:00","created_by":"daemon"},{"issue_id":"spry-hsz","depends_on_id":"spry-4dq","type":"depends-on","created_at":"2025-12-25T14:31:51.81248-05:00","created_by":"daemon"}]}
{"id":"spry-hvk","title":"Pin git version for dev and CI testing","description":"## Context\n\nspry requires Git 2.40+ for `git merge-tree --merge-base` support. Apple Git (even version 2.39.5) doesn't include this feature despite the version number.\n\nCurrently we have a version check test in `src/git/plumbing.test.ts` that fails with a helpful message, but we should be able to:\n1. Pin a specific git version for development\n2. Test against multiple git versions in CI\n3. Test the \"version too old\" error message with an older git\n\n## Research\n\n**The short answer: there's no elegant solution.** Unlike Node.js (nvm) or Python (pyenv), no widely-adopted version manager exists specifically for Git.\n\n### Why Git version management is different\n\nGit maintains strong backward compatibility—most workflows work identically across Git 2.30 through 2.45. Few developers need version switching, which explains the sparse tooling.\n\n### mise/asdf: technically possible, rarely practical\n\nAn asdf-git plugin exists at `gitlab.com/jcaigitlab/asdf-git`, but it's essentially abandoned (15 commits since October 2021). Every installation compiles Git from source (5-10 minutes per version), requiring gcc, make, libcurl-dev, zlib-dev, openssl-dev.\n\n### Docker containers: the pragmatic choice\n\nFor testing against multiple Git versions, Docker provides the cleanest isolation:\n\n```bash\ndocker run --rm alpine/git:v2.40.0 --version\ndocker run -v $(pwd):/git -w /git alpine/git:v2.40.0 status\n```\n\nFor CI, a GitHub Actions matrix strategy:\n\n```yaml\njobs:\n  test:\n    strategy:\n      matrix:\n        git-version: ['2.38.0', '2.40.0', '2.43.0']\n    container: alpine/git:v${{ matrix.git-version }}\n```\n\n### What git tool developers actually do\n\nMost don't extensively test across Git versions. They:\n- Test against the single Git version on CI runners\n- Document minimum supported version requirements\n- Use `git --version` parsing to conditionally enable features\n\n## Recommendation\n\nUse Docker containers with `alpine/git` for CI testing. For local dev, just ensure developers have Git 2.40+ installed (brew install git on macOS).\n\n## Acceptance criteria\n\n- [ ] CI tests against minimum supported git version (2.40) via Docker\n- [ ] CI verifies the error message works when git is too old (2.39)\n- [ ] Document Git 2.40+ requirement in README","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-10T21:11:20.047632-05:00","created_by":"dondenton","updated_at":"2026-01-11T00:28:33.948898-05:00","closed_at":"2026-01-11T00:28:33.948898-05:00","close_reason":"Implemented CI workflow with git 2.40/2.38 testing, Docker dev environment, and CLI version check"}
{"id":"spry-ij4","title":"Implement sp wt new command","description":"Create worktree with automatic branch creation.\n\nUsage: sp wt new \u003cname\u003e [options]\n\nBehavior:\n- Creates worktree in ../\u003crepo\u003e.worktrees/\u003cname\u003e/ by default\n- Auto-creates branch from origin/main (or spry.tree.defaultBranch)\n- Runs setup script automatically if configured\n\nFlags:\n- -e, --existing - Use existing branch instead of creating new\n- -i, --initial-ref \u003cref\u003e - Start new branch from specific ref\n- -s, --skip-setup - Skip automatic setup script\n- -d, --dir \u003cpath\u003e - Custom worktrees directory (supports tokens)\n- -o, --open \u003ccmd\u003e - Run command after creation (e.g., 'code')\n- -O, --no-open - Skip default open command\n\nSafety checks:\n- Refuse if branch name already exists (without -e)\n- Refuse if creating worktree for currently checked out branch\n- Refuse if worktree directory already exists\n\nReference: ~/dotfiles/bin/git-ht cmd_create()","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-10T15:23:04.871692-05:00","created_by":"dondenton","updated_at":"2026-01-10T20:46:56.190179-05:00","dependencies":[{"issue_id":"spry-ij4","depends_on_id":"spry-ra3","type":"parent-child","created_at":"2026-01-10T15:23:12.901471-05:00","created_by":"dondenton"},{"issue_id":"spry-ij4","depends_on_id":"spry-s4y","type":"blocks","created_at":"2026-01-10T15:26:17.473108-05:00","created_by":"dondenton"}]}
{"id":"spry-izr","title":"Conflict detection and reporting","description":"## Goal\nDetect rebase conflicts and provide clear instructions for resolution.\n\n## Implementation\n\n```typescript\n// src/git/rebase.ts\n\ninterface ConflictInfo {\n  files: string[];\n  currentCommit: string;\n  currentSubject: string;\n}\n\nasync function getConflictInfo(): Promise\u003cConflictInfo | null\u003e {\n  // Check if we're in a rebase\n  const rebaseDir = await $\\`git rev-parse --git-path rebase-merge\\`.text();\n  const exists = await Bun.file(rebaseDir.trim()).exists();\n  \n  if (!exists) return null;\n  \n  // Get conflicting files\n  const status = await $\\`git status --porcelain\\`.text();\n  const conflicts = status\n    .split('\\n')\n    .filter(line =\u003e line.startsWith('UU ') || line.startsWith('AA '))\n    .map(line =\u003e line.slice(3));\n  \n  // Get current commit being rebased\n  const head = await $\\`git rev-parse HEAD\\`.text();\n  const subject = await $\\`git log -1 --format=%s HEAD\\`.text();\n  \n  return {\n    files: conflicts,\n    currentCommit: head.trim().slice(0, 8),\n    currentSubject: subject.trim(),\n  };\n}\n```\n\n### Error Message\n```typescript\nfunction formatConflictError(info: ConflictInfo): string {\n  return \\`\n✗ Rebase conflict while applying commit \\${info.currentCommit}\n  \"\\${info.currentSubject}\"\n\nConflicting files:\n\\${info.files.map(f =\u003e \\`  • \\${f}\\`).join('\\n')}\n\nTo resolve:\n  1. Edit the conflicting files\n  2. git add \u003cfixed files\u003e\n  3. git rebase --continue\n  4. taspr sync\n\nTo abort:\n  git rebase --abort\n\\`.trim();\n}\n```\n\n## Testing\n- Detect conflict in progress\n- List all conflicting files\n- Clear resolution instructions\n\n## Files to Modify\n- src/git/rebase.ts\n- src/cli/output.ts\n\n## Acceptance Criteria\n- [ ] Detects ongoing rebase conflict\n- [ ] Lists conflicting files\n- [ ] Shows which commit is being applied\n- [ ] Provides clear resolution steps","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-25T14:36:43.502623-05:00","updated_at":"2026-01-10T00:36:02.160945-05:00","closed_at":"2025-12-31T14:12:02.338606-05:00","close_reason":"Added getConflictInfo() and formatConflictError() functions. All 4 new tests passing.","dependencies":[{"issue_id":"spry-izr","depends_on_id":"spry-efn","type":"parent-child","created_at":"2025-12-25T14:36:47.54253-05:00","created_by":"daemon"},{"issue_id":"spry-izr","depends_on_id":"spry-08w","type":"blocks","created_at":"2025-12-25T14:36:47.822256-05:00","created_by":"daemon"},{"issue_id":"spry-izr","depends_on_id":"spry-08w","type":"depends-on","created_at":"2025-12-25T14:36:47.822256-05:00","created_by":"daemon"}]}
{"id":"spry-j90","title":"Reevaluate necessity of pushing branches to origin before PR","description":"Review whether we need to push branches to origin when a PR hasn't been opened yet. Consider if this adds unnecessary remote clutter or if there are valid reasons to keep this behavior (e.g., backup, collaboration, CI triggers).","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-02T23:44:16.218254-05:00","updated_at":"2026-01-10T00:36:02.180664-05:00","closed_at":"2026-01-02T23:51:55.453529-05:00","close_reason":"Closed"}
{"id":"spry-laf","title":"Rebase orchestration for ID injection","description":"## Goal\nImplement the rebase logic to add Taspr-Commit-Id trailers to multiple commits in a stack.\n\n## Background\nWhen commits don't have IDs, we need to add them via rebase. This is non-trivial because:\n- Multiple commits may need IDs\n- We want to preserve existing IDs\n- We need to handle the rebase cleanly\n\n## Approach: GIT_SEQUENCE_EDITOR + exec\n\n### Option 1: Rebase with --exec\n```bash\ngit rebase -i --exec './add-id-if-missing.sh' \u003cmerge-base\u003e\n```\n\nThe script checks each commit and adds ID only if missing:\n```bash\n#!/bin/bash\nif ! git log -1 --format=%B | grep -q \"^Taspr-Commit-Id:\"; then\n  # Add ID\n  NEW_MSG=$(git log -1 --format=%B | git interpret-trailers --trailer \"Taspr-Commit-Id: $(openssl rand -hex 4)\")\n  git commit --amend --no-edit -m \"$NEW_MSG\"\nfi\n```\n\n### Option 2: Programmatic Rebase\nMore control but more complex:\n1. Generate todo list manually\n2. For each commit needing ID, mark as \"edit\"\n3. Use GIT_SEQUENCE_EDITOR to inject todo\n4. Handle each \"edit\" stop to add trailer\n\n### Recommended: Option 1\nSimpler and handles edge cases well. The --exec runs after each pick.\n\n## Implementation\n\n```typescript\n// src/core/sync.ts\n\nasync function injectMissingIds(): Promise\u003c{ modifiedCommits: string[] }\u003e {\n  const commits = await getStackCommits();\n  \n  // Find commits without IDs\n  const needsId = commits.filter(c =\u003e !c.trailers['Taspr-Commit-Id']);\n  \n  if (needsId.length === 0) {\n    return { modifiedCommits: [] };\n  }\n  \n  // Create temp script for --exec\n  const script = createIdInjectionScript();\n  await writeFile(scriptPath, script);\n  await chmod(scriptPath, '755');\n  \n  // Run rebase\n  const mergeBase = await getMergeBase();\n  await $`git rebase -i --exec ${scriptPath} ${mergeBase}`;\n  \n  // Clean up\n  await unlink(scriptPath);\n  \n  return { modifiedCommits: needsId.map(c =\u003e c.hash) };\n}\n```\n\n## Challenges\n\n### Non-interactive rebase\nWe want this to run without user intervention. Using `--exec` with a script achieves this—no editor opens.\n\n### Preserving existing IDs\nThe script only adds ID if missing, so existing IDs are preserved.\n\n### Rebase conflicts\nIf there's a conflict, the rebase stops. This is handled by a separate task in Epic 8.\n\n## Testing\n1. Stack with no IDs → all get IDs\n2. Stack with some IDs → only missing ones get IDs\n3. Stack with all IDs → no rebase happens (no-op)\n4. Verify IDs survive subsequent rebases\n\n## Files to Create/Modify\n- src/core/sync.ts (create)\n- src/git/rebase.ts (create) - Rebase utilities\n\n## Acceptance Criteria\n- [ ] Adds IDs to commits missing them\n- [ ] Preserves existing IDs\n- [ ] No-op if all commits have IDs\n- [ ] Works without user interaction\n- [ ] Has integration tests with real git repos","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T14:25:29.162547-05:00","updated_at":"2026-01-10T00:36:02.198251-05:00","closed_at":"2025-12-26T21:25:42.040572-05:00","close_reason":"Implemented injectMissingIds in src/git/rebase.ts with 9 integration tests","dependencies":[{"issue_id":"spry-laf","depends_on_id":"spry-sbb","type":"parent-child","created_at":"2025-12-25T14:25:33.539927-05:00","created_by":"daemon"},{"issue_id":"spry-laf","depends_on_id":"spry-esa","type":"blocks","created_at":"2025-12-25T14:25:33.82023-05:00","created_by":"daemon"},{"issue_id":"spry-laf","depends_on_id":"spry-esa","type":"depends-on","created_at":"2025-12-25T14:25:33.82023-05:00","created_by":"daemon"}]}
{"id":"spry-lgg","title":"Remove horizontal rule separators from story output","description":"The story output currently uses `---` horizontal rules between sections. Since markdown headings already provide visual separation, these are redundant.\n\nRemove the `---` separators from `formatSection()` in `tests/helpers/story.ts`.","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-09T12:11:53.630462-05:00","updated_at":"2026-01-10T00:36:02.169928-05:00","closed_at":"2026-01-09T22:57:33.094674-05:00","close_reason":"Closed"}
{"id":"spry-lrhb","title":"Update user feedback from 'spry' to 'sp' in commands","description":"The CLI has been renamed from 'spry' to 'sp', but some user-facing messages still reference the old name.\n\n**Example:**\n```\n% sp land\n✗ PR #1194 is not ready to land:\n  • CI checks are still running\n\nRun 'spry view' to see status.\n```\n\nShould say: `Run 'sp view' to see status.`\n\n**Scope:**\n- `sp land` command (confirmed)\n- Other commands may have similar issues\n- Need to audit all user-facing error messages and help text\n\n**Fix:**\nSearch for hardcoded 'spry' references in error messages, help text, and user feedback strings.","status":"closed","priority":2,"issue_type":"bug","owner":"don.denton@trillianthealth.com","created_at":"2026-01-13T09:26:36.639-05:00","created_by":"Don Denton","updated_at":"2026-01-13T21:15:14.188936-05:00","closed_at":"2026-01-13T21:15:14.188936-05:00","close_reason":"Closed"}
{"id":"spry-m8q","title":"Optimize TUI redrawing to avoid creating excessive output lines","description":"Evaluate how we are redrawing the TUI on each state change. Currently, the TUI may be creating more and more lines of output instead of redrawing in place. Investigate and optimize to use proper terminal control sequences for in-place updates.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-02T11:52:41.606296-05:00","updated_at":"2026-01-10T00:36:02.199033-05:00","dependencies":[{"issue_id":"spry-m8q","depends_on_id":"spry-do5","type":"parent-child","created_at":"2026-01-02T11:52:41.606988-05:00","created_by":"dondenton"}]}
{"id":"spry-mac","title":"Test spry prefix again","description":"Just testing","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-09T13:36:26.987207-05:00","updated_at":"2026-01-09T13:36:30.540121-05:00","closed_at":"2026-01-09T13:36:30.540121-05:00","close_reason":"Closed"}
{"id":"spry-mbn","title":"Story test logging for integration tests","description":"Create narrative markdown files during integration test runs that tell the story of each test scenario in plain English, followed by the CLI output. This enables UI state review and potential documentation generation.\n\n## Design Decisions\n- **File structure**: One MD file per test file (e.g., `test-logs/sync.md`)\n- **Color handling**: Generate both `.md` (clean) and `.ansi` (colored) versions\n- **Activation**: Opt-in via `TASPR_STORY_TEST_LOGGING=1` environment variable\n- **Narrative source**: Manual annotations in test code using a story API\n- **Context style**: Describe scenarios contextually (\"If you are on a feature branch...\") not mechanically (\"Create a feature branch\")\n\n## Technical Approach\n\n### 1. Enhance Run Helpers (`tests/integration/helpers.ts`)\nExtend `TasprResult` to `CommandResult` which includes the exact command string:\n\n```typescript\nexport interface CommandResult {\n  command: string;  // e.g., \"taspr sync --open\"\n  stdout: string;\n  stderr: string;\n  exitCode: number;\n}\n```\n\nThe `runTaspr()` function builds and returns the command string, eliminating sync issues between what's logged and what's run.\n\n### 2. Story API (`tests/helpers/story.ts`)\n\n```typescript\nexport interface Story {\n  begin(testName: string): void;\n  narrate(text: string): void;\n  log(result: CommandResult): void;\n  end(): void;\n  flush(): Promise\u003cvoid\u003e;\n}\n```\n\nInternally uses interleaved entries:\n```typescript\ntype StoryEntry =\n  | { type: \"narrate\"; text: string }\n  | { type: \"command\"; result: CommandResult };\n```\n\n### 3. Output Format Example\n\n**test-logs/sync.md**:\n```markdown\n# Sync Command Stories\n\n---\n\n## skips PR creation for WIP commits\n\nIf you have a commit prefixed with 'WIP:', taspr will skip creating a PR for it.\n\n### `taspr sync --open`\n\n\\`\\`\\`\nSkipped PR for 1 temporary commit\n  - WIP: work in progress\n\\`\\`\\`\n\n---\n```\n\n### 4. Test Integration Example\n\n```typescript\nimport { createStory } from \"../helpers/story.ts\";\n\ndescribe(\"sync command\", () =\u003e {\n  const story = createStory(\"sync.test.ts\");\n\n  afterAll(async () =\u003e {\n    await story.flush();\n  });\n\n  test(\"skips PR creation for WIP commits\", async () =\u003e {\n    story.begin(\"skips PR creation for WIP commits\");\n    story.narrate(\"If you have a commit prefixed with 'WIP:', taspr will skip creating a PR for it.\");\n\n    const repo = await repos.clone({ testName: \"wip-skip\" });\n    await repo.branch(\"feature/wip-test\");\n    await repo.commit({ message: \"WIP: work in progress\" });\n\n    const result = await runSync(repo.path, { open: true });\n    story.log(result);\n    story.end();\n\n    expect(result.exitCode).toBe(0);\n  });\n});\n```\n\n## Key Principles\n- Stories focus on what's being demonstrated, not mechanical setup steps\n- Err on the side of showing less; add git output only if it adds clarity for a specific test\n- No generic `runGit()` wrapper needed; tests continue using existing git interaction patterns","status":"closed","priority":2,"issue_type":"epic","created_at":"2026-01-05T00:32:39.570413-05:00","updated_at":"2026-01-10T00:44:09.946279-05:00","closed_at":"2026-01-10T00:44:09.946279-05:00","close_reason":"Closed","dependencies":[{"issue_id":"spry-mbn","depends_on_id":"spry-hqg","type":"blocks","created_at":"2026-01-09T12:11:58.254214-05:00","created_by":"don.denton"},{"issue_id":"spry-mbn","depends_on_id":"spry-lgg","type":"blocks","created_at":"2026-01-09T12:11:58.313527-05:00","created_by":"don.denton"},{"issue_id":"spry-mbn","depends_on_id":"spry-a2y","type":"blocks","created_at":"2026-01-09T12:11:58.370693-05:00","created_by":"don.denton"},{"issue_id":"spry-mbn","depends_on_id":"spry-d61","type":"blocks","created_at":"2026-01-09T12:11:58.429159-05:00","created_by":"don.denton"}]}
{"id":"spry-mhlg","title":"view --all should show all branches with spry commits, not just open PRs","description":"## Problem\n\nThe `view --all` command currently only shows open PRs. However, the intended behavior is to:\n\n1. Find all branches that have spry commits (commits created by spry)\n2. Show each branch as a separate stack\n3. Include branches regardless of whether they have open PRs or not\n\n## Current Behavior\n\nThe command filters to only show branches with open PRs.\n\n## Expected Behavior\n\nShow all branches with spry commits as separate stacks, including:\n- Branches with open PRs\n- Branches with closed/merged PRs\n- Branches with no PRs yet (local only or pushed but no PR created)\n\n## Related Code\n\nSee `src/cli/commands/view.ts` - the current implementation likely filters based on PR status rather than detecting spry commits on branches.","status":"open","priority":2,"issue_type":"bug","owner":"don@happycollision.com","created_at":"2026-01-17T00:10:18.312785-05:00","created_by":"Don Denton","updated_at":"2026-01-17T00:10:24.735376-05:00"}
{"id":"spry-mk7","title":"Post-rebase sync (update all branches)","description":"## Goal\nAfter rebasing, update all affected PR branches.\n\n## Background\nAfter a rebase:\n- All commit hashes in the stack have changed\n- All remote branches point to old hashes\n- All branches need force-pushing\n\n## Implementation\n\n```typescript\n// src/core/sync.ts\n\nasync function syncAfterRebase(units: PRUnit[]): Promise\u003cvoid\u003e {\n  const config = await getBranchNameConfig();\n  \n  console.log('Updating PR branches...');\n  \n  let updated = 0;\n  \n  for (const unit of units) {\n    const branch = getBranchName(unit.id, config);\n    const localCommit = unit.commits[unit.commits.length - 1];\n    \n    // Force push regardless of whether we think it changed\n    // After rebase, everything has changed\n    await forcePushBranch(localCommit, branch);\n    updated++;\n    \n    console.log(\\`  ✓ \\${branch}\\`);\n  }\n  \n  console.log(\\`\\\\n✓ Updated \\${updated} PR branch(es)\\`);\n}\n```\n\n### Full Sync Flow\n```typescript\nasync function sync(options: { open?: boolean }) {\n  // 1. Check for dirty state\n  await requireCleanWorkingTree();\n  \n  // 2. Check for ongoing conflict\n  if (await getConflictInfo()) {\n    // Exit with instructions\n  }\n  \n  // 3. Inject missing IDs\n  await injectMissingIds();\n  \n  // 4. Parse stack\n  const result = await parseStack();\n  \n  // 5. Rebase if behind\n  if (await isStackBehindMain()) {\n    const rebaseResult = await rebaseOntoMain();\n    if (!rebaseResult.success) {\n      // Conflict - exit\n    }\n    \n    // Re-parse after rebase (hashes changed)\n    result = await parseStack();\n  }\n  \n  // 6. Update branches\n  await syncAfterRebase(result.units);\n  \n  // 7. Create PRs if --open\n  if (options.open) {\n    await createMissingPRs(result.units);\n  }\n}\n```\n\n## Testing\n- After rebase, all branches updated\n- PR commits match local stack\n- Force push succeeds\n\n## Files to Modify\n- src/core/sync.ts\n- src/cli/commands/sync.ts\n\n## Acceptance Criteria\n- [ ] Updates all branches after rebase\n- [ ] Force pushes to overwrite old commits\n- [ ] Reports each updated branch\n- [ ] Handles partial failures gracefully","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-25T14:37:18.394819-05:00","updated_at":"2026-01-10T00:36:02.194721-05:00","closed_at":"2025-12-31T14:20:28.635035-05:00","close_reason":"Closed","dependencies":[{"issue_id":"spry-mk7","depends_on_id":"spry-efn","type":"parent-child","created_at":"2025-12-25T14:37:23.410645-05:00","created_by":"daemon"},{"issue_id":"spry-mk7","depends_on_id":"spry-blj","type":"blocks","created_at":"2025-12-25T14:37:23.676459-05:00","created_by":"daemon"},{"issue_id":"spry-mk7","depends_on_id":"spry-blj","type":"depends-on","created_at":"2025-12-25T14:37:23.676459-05:00","created_by":"daemon"}]}
{"id":"spry-ms6","title":"Install and configure oxformat","description":"Install oxformat (Oxc's fast JavaScript/TypeScript formatter) and configure it for the project. This includes adding the package, creating configuration files, and setting up npm scripts.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-26T01:04:41.62418-05:00","updated_at":"2026-01-10T00:36:02.203612-05:00","closed_at":"2025-12-26T01:37:47.487903-05:00","close_reason":"Installed oxfmt v0.20.0 and configured with default settings. Added format script to package.json."}
{"id":"spry-muh","title":"Sync command with PR creation (--open flag)","description":"## Goal\nExtend the sync command to create PRs with the --open flag.\n\n## Current State (from Epic 2)\n`taspr sync` currently:\n- Checks for dirty working tree\n- Adds Taspr-Commit-Id to commits without them\n\n## New Behavior\n`taspr sync --open` also:\n- Pushes branches for all PRUnits\n- Creates PRs for units that don't have them\n- Reports created/existing PRs\n\n## Implementation\n\n```typescript\n// src/cli/commands/sync.ts\n\nexport const syncCommand = new Command('sync')\n  .description('Sync stack state with GitHub')\n  .option('--open', 'Create PRs for units without them')\n  .action(async (options) =\u003e {\n    await requireCleanWorkingTree();\n    \n    // Parse and validate stack\n    const result = await parseStack();\n    if (!result.ok) {\n      console.error(formatValidationError(result));\n      process.exit(1);\n    }\n    \n    // Inject missing IDs\n    const idResult = await injectMissingIds();\n    if (idResult.modifiedCommits.length \u003e 0) {\n      console.log(\\`✓ Added IDs to \\${idResult.modifiedCommits.length} commit(s)\\`);\n      // Re-parse after rebase\n      result = await parseStack();\n    }\n    \n    if (!options.open) {\n      console.log('✓ Stack synced (use --open to create PRs)');\n      return;\n    }\n    \n    // Push branches and create PRs\n    const config = await getBranchNameConfig();\n    const defaultBranch = await getDefaultBranch();\n    \n    let baseBranch = defaultBranch;\n    const created: PRInfo[] = [];\n    const existing: PRInfo[] = [];\n    \n    for (const unit of result.units) {\n      const headBranch = getBranchName(unit.id, config);\n      \n      // Push branch\n      await pushBranch(unit.commits[unit.commits.length - 1], headBranch);\n      \n      // Check for existing PR\n      const existingPR = await findPRByBranch(headBranch);\n      \n      if (existingPR) {\n        existing.push(existingPR);\n      } else {\n        const pr = await createPR({\n          title: unit.title,\n          head: headBranch,\n          base: baseBranch,\n        });\n        created.push(pr);\n      }\n      \n      baseBranch = headBranch;\n    }\n    \n    // Report results\n    if (created.length \u003e 0) {\n      console.log(\\`\\\\n✓ Created \\${created.length} PR(s):\\`);\n      for (const pr of created) {\n        console.log(\\`  #\\${pr.number} \\${pr.url}\\`);\n      }\n    }\n    \n    if (existing.length \u003e 0) {\n      console.log(\\`\\\\n✓ \\${existing.length} PR(s) already exist\\`);\n    }\n  });\n```\n\n## Output\n\n### First sync with --open\n```\n$ taspr sync --open\n\n✓ Added IDs to 3 commit(s)\n✓ Pushed 3 branch(es)\n\n✓ Created 3 PR(s):\n  #142 https://github.com/org/repo/pull/142\n  #143 https://github.com/org/repo/pull/143\n  #144 https://github.com/org/repo/pull/144\n```\n\n### Subsequent sync with --open (PRs exist)\n```\n$ taspr sync --open\n\n✓ All commits have IDs\n✓ Pushed 3 branch(es)\n✓ 3 PR(s) already exist\n```\n\n### Sync without --open\n```\n$ taspr sync\n\n✓ All commits have IDs\n✓ Stack synced (use --open to create PRs)\n```\n\n## Testing\n1. Sync --open creates PRs\n2. Sync --open with existing PRs doesn't duplicate\n3. Sync without --open doesn't touch GitHub\n4. Integration test with real GitHub (or mocked)\n\n## Files to Modify\n- src/cli/commands/sync.ts\n\n## Acceptance Criteria\n- [ ] --open flag creates PRs for units without them\n- [ ] Doesn't create duplicate PRs\n- [ ] Reports created vs existing PRs\n- [ ] Without --open, no GitHub interaction\n- [ ] PRs form correct stack structure","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T14:28:34.89184-05:00","updated_at":"2026-01-10T00:36:02.20418-05:00","closed_at":"2025-12-26T23:29:21.531433-05:00","close_reason":"Implemented and tested","dependencies":[{"issue_id":"spry-muh","depends_on_id":"spry-ce1","type":"parent-child","created_at":"2025-12-25T14:28:38.862039-05:00","created_by":"daemon"},{"issue_id":"spry-muh","depends_on_id":"spry-wpm","type":"blocks","created_at":"2025-12-25T14:28:39.14537-05:00","created_by":"daemon"},{"issue_id":"spry-muh","depends_on_id":"spry-wpm","type":"depends-on","created_at":"2025-12-25T14:28:39.14537-05:00","created_by":"daemon"},{"issue_id":"spry-muh","depends_on_id":"spry-ab6","type":"depends-on","created_at":"2025-12-25T14:28:39.430517-05:00","created_by":"daemon"},{"issue_id":"spry-muh","depends_on_id":"spry-ab6","type":"blocks","created_at":"2025-12-25T14:28:39.430517-05:00","created_by":"daemon"}]}
{"id":"spry-mvdj","title":"Detect non-GitHub origins and disable GitHub-specific tasks","description":"Currently, spry assumes all git repositories have GitHub as their origin. This causes issues when working with repos hosted on GitLab, Bitbucket, or other platforms.\n\nWe should:\n1. Detect if the origin remote URL is a github.com repository\n2. Disable or skip GitHub-specific commands (like PR operations) when the origin is not GitHub\n3. Provide clear feedback to users when they attempt GitHub-specific operations on non-GitHub repos\n\nThis will make spry more robust and work better with diverse git hosting platforms.","status":"closed","priority":2,"issue_type":"feature","owner":"don.denton@trillianthealth.com","created_at":"2026-01-15T16:33:19.824753-05:00","created_by":"Don Denton","updated_at":"2026-01-17T00:23:57.014886-05:00","closed_at":"2026-01-17T00:23:57.014886-05:00","close_reason":"Implemented origin detection with requireGitHubOrigin() guard for GitHub-specific commands (sync --open, land) and graceful degradation for view"}
{"id":"spry-my0","title":"Group dissolve command","description":"## Goal\nImplement `taspr group dissolve` to break a group back into individual commits.\n\n## Context\nThis is part of Epic 7: Group Management. The main group functionality is handled by a unified TUI (`taspr group`), but dissolve remains as a separate simple command for quick ungrouping.\n\n## Implementation\n\n```typescript\n// src/cli/commands/group.ts\n\ngroupCommand\n  .command('dissolve')\n  .argument('[group-id]', 'Group to dissolve')\n  .description('Dissolve a group back into individual commits')\n  .action(async (groupId?: string) =\u003e {\n    const result = await parseStack();\n    \n    const groups = result.units.filter(u =\u003e u.type === 'group');\n    if (groups.length === 0) {\n      console.log('No groups in current stack');\n      return;\n    }\n    \n    // If no group-id provided, prompt for selection\n    let group: PRUnit;\n    if (groupId) {\n      group = groups.find(g =\u003e g.id === groupId);\n      if (!group) {\n        console.error(`Group '${groupId}' not found`);\n        process.exit(1);\n      }\n    } else {\n      group = await select({\n        message: 'Select group to dissolve',\n        choices: groups.map(g =\u003e ({\n          name: `${g.title} (${g.commits.length} commits)`,\n          value: g,\n        })),\n      });\n    }\n    \n    // Warn about PR closure\n    const pr = await findPRForGroup(group);\n    if (pr) {\n      console.log(`⚠ Warning: This will close PR #${pr.number}.`);\n      console.log('  Each commit will become its own PR when you sync --open.');\n    }\n    \n    const proceed = await confirm({ message: 'Proceed?' });\n    if (!proceed) return;\n    \n    // Remove group trailers\n    await removeGroupTrailers(group);\n    \n    console.log(`✓ Dissolved group \"${group.title}\"`);\n    console.log('  Run \\`taspr sync --open\\` to create individual PRs.');\n  });\n```\n\n### Removing Group Trailers\n```typescript\nasync function removeGroupTrailers(group: PRUnit): Promise\u003cvoid\u003e {\n  const first = group.commits[0];\n  const last = group.commits[group.commits.length - 1];\n  \n  // Remove Start and Title from first commit\n  await removeTrailersFromCommit(first, [\n    'Taspr-Group-Start',\n    'Taspr-Group-Title',\n  ]);\n  \n  // Remove End from last commit\n  if (last !== first) {\n    await removeTrailersFromCommit(last, ['Taspr-Group-End']);\n  }\n}\n```\n\n## Files to Modify\n- src/cli/commands/group.ts (add dissolve subcommand)\n\n## Testing\n- Dissolve single group\n- Dissolve with PR warning\n- Cancel dissolve\n- Dissolve by group-id argument\n\n## Acceptance Criteria\n- [ ] Lists existing groups if no argument provided\n- [ ] Accepts group-id as optional argument\n- [ ] Warns about PR closure\n- [ ] Removes all group trailers (Start, Title, End)\n- [ ] Confirms before changes\n- [ ] Works with single-commit groups","notes":"## Testing Workflow\nAfter completing implementation:\n1. Run `bun run build` to build the CLI\n2. Run `bun test --no-coverage` to verify all tests pass\n3. Tell the user to run `bun run scenario` and select a scenario for manual testing\n\n## Scenario Usage\nThe `bun run scenario` command spawns a shell in a temp git repo with `taspr` in PATH. After testing, type `exit` to clean up.\n\n## New Scenarios Needed\nThis task REQUIRES a new scenario. Add to `src/scenario/definitions.ts`:\n- **withGroups** - Stack with existing group trailers (Taspr-Group-Start/End/Title) for testing dissolve command\n\nThe agent should create this scenario before implementing the dissolve command, as it's needed for both unit tests and manual testing.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-25T14:35:21.688433-05:00","updated_at":"2026-01-10T00:36:02.173852-05:00","closed_at":"2026-01-02T11:01:08.152403-05:00","close_reason":"Implemented dissolve command with interactive multi-select, fixed detectPRUnits bug for single-commit groups, fixed dissolveGroup to only remove trailers for target group","dependencies":[{"issue_id":"spry-my0","depends_on_id":"spry-r22","type":"parent-child","created_at":"2025-12-25T14:35:26.08024-05:00","created_by":"daemon"},{"issue_id":"spry-my0","depends_on_id":"spry-cso","type":"blocks","created_at":"2025-12-25T14:35:26.356701-05:00","created_by":"daemon"},{"issue_id":"spry-my0","depends_on_id":"spry-cso","type":"depends-on","created_at":"2025-12-25T14:35:26.356701-05:00","created_by":"daemon"}]}
{"id":"spry-n1i","title":"Add story logging to all major command tests","description":"Currently only some test files generate story output. All major commands and options should be represented in the documentation.\n\nAudit which test files are missing story logging and add it. The goal is comprehensive documentation of:\n- All CLI commands (sync, land, clean, view, group, etc.)\n- Important command options and flags\n- Edge cases and error scenarios","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-09T12:11:53.749786-05:00","updated_at":"2026-01-09T12:11:53.749786-05:00"}
{"id":"spry-n6r","title":"taspr-inmem","description":"# Migrate to In-Memory Git Operations\n\n## Problem\nTraditional `git rebase` touches the working directory at each commit during replay, causing \"untracked working tree files would be overwritten\" errors when files were tracked in history, later removed and gitignored, then recreated as untracked files.\n\n## Solution\nReplace all `git rebase -i` operations with in-memory git plumbing commands:\n- `git commit-tree` for creating new commits\n- `git merge-tree --write-tree` for computing merged trees (Git 2.38+)\n- `git update-ref` for moving branch pointers atomically\n\n## Benefits\n- Working directory never touched during intermediate states\n- 10-150x performance improvement\n- Conflict detection without modification\n- Single reset at end when tree actually changes\n\n## Scope\nMigrate these operations:\n1. **Message rewrites** - Use `git commit-tree` with same tree, new message\n2. **Trailer injection** - Rewrite message with `git interpret-trailers`, commit via `commit-tree`\n3. **Group operations** - All trailer modifications use in-memory approach\n4. **Rebase onto main** - Use `git merge-tree --write-tree` for cherry-pick sequence\n\n## Files to Migrate\n- `src/git/rebase.ts` - `injectMissingIds`, `rebaseOntoMain`\n- `src/git/group-rebase.ts` - All functions using `runInteractiveRebase`\n\n## Requirements\n- Git 2.38+ (for `git merge-tree --write-tree`)\n- Add version check with helpful error message","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-08T22:10:09.54718-05:00","updated_at":"2026-01-08T22:59:20.921131-05:00","closed_at":"2026-01-08T22:59:20.921131-05:00","close_reason":"Epic complete\\! All 8 tasks finished. Migrated from git rebase -i with exec commands to in-memory git operations using plumbing commands. This provides 10-150x performance improvement for message-only operations and eliminates 'untracked working tree files would be overwritten' errors."}
{"id":"spry-nhq","title":"Implement sp wt setup command","description":"Setup script initialization and execution.\n\nUsage:\n- sp wt setup --init [path] - Create template setup script\n- sp wt setup [branch-name] - Run setup for worktree\n\n--init mode:\n- Creates template bash script at path (default: setup-worktree.sh)\n- Sets spry.tree.setupScript config\n- Template receives $1=repo_root, $2=worktree_root\n- Non-.sh extensions get modified template with manual instructions\n\nRun mode:\n- If branch provided: find worktree for that branch, run setup\n- If no branch: must be inside linked worktree, run setup for current\n- Expand tokens in setupScript path before execution\n\nToken expansion in paths:\n- \u003crepo_root\u003e - absolute path to main repository\n- \u003crepo_name\u003e - basename of repository\n- \u003cworktree_root\u003e - absolute path to target worktree\n\nReference: ~/dotfiles/bin/git-ht cmd_setup()","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-10T15:23:05.756462-05:00","created_by":"dondenton","updated_at":"2026-01-10T20:46:57.099422-05:00","dependencies":[{"issue_id":"spry-nhq","depends_on_id":"spry-ra3","type":"parent-child","created_at":"2026-01-10T15:23:13.072441-05:00","created_by":"dondenton"},{"issue_id":"spry-nhq","depends_on_id":"spry-s4y","type":"blocks","created_at":"2026-01-10T15:26:17.65404-05:00","created_by":"dondenton"}]}
{"id":"spry-oef","title":"Epic 5: Land PRs (Merge to Main)","description":"## Goal\nMerge the bottom PR to main, completing the PR lifecycle.\n\n## Background\n\n### Landing Strategy\nWhen a PR is ready (approved, CI passing), land it by merging to main. The merge strategy depends on repo settings:\n- Fast-forward (if possible)\n- Squash merge\n- Merge commit\n\ntaspr uses GitHub's merge API, which respects repo settings.\n\n### Stack Behavior After Landing\nWhen the bottom PR merges:\n1. GitHub automatically retargets child PRs to new base (main)\n2. No action needed from taspr for retargeting\n3. Next `taspr sync` will clean up merged PR from local tracking\n\n### What \"Ready\" Means\nA PR is ready to land when:\n- Approved by required reviewers\n- CI checks passing\n- No merge conflicts\n\n## Workflow\n\n1. User runs `taspr land`\n2. Find bottom unmerged PR\n3. Check if it's ready (API call)\n4. Merge via GitHub API\n5. Report success\n\n## Deliverable\nRunning `taspr land` merges the bottom PR. GitHub handles retargeting child PRs.\n\n## Dependencies\n- Epic 4 must be complete (PRs exist and are synced)\n\n## Commands\n\n### taspr land\nMerge the bottom ready PR:\n```\n$ taspr land\n\nMerging PR #142 (Add user model)...\n✓ Merged PR #142 to main\n```\n\n### taspr land --all\nMerge all consecutive ready PRs:\n```\n$ taspr land --all\n\nMerging PR #142 (Add user model)...\n✓ Merged PR #142 to main\n\nMerging PR #143 (Add auth)...\n✓ Merged PR #143 to main\n\nStopping at PR #144 (not ready: CI failing)\n```\n\n## Testable Outcome\nLanding a PR merges it to main. GitHub retargets child PRs automatically.","status":"closed","priority":1,"issue_type":"epic","created_at":"2025-12-25T14:30:38.632223-05:00","updated_at":"2026-01-10T00:36:02.196185-05:00","closed_at":"2025-12-31T10:55:35.747715-05:00","close_reason":"All child tasks completed: PR merge API, land command, land --all flag, and merged PR detection/cleanup are all implemented.","dependencies":[{"issue_id":"spry-oef","depends_on_id":"spry-d0k","type":"blocks","created_at":"2025-12-25T14:30:43.99553-05:00","created_by":"daemon"},{"issue_id":"spry-oef","depends_on_id":"spry-d0k","type":"depends-on","created_at":"2025-12-25T14:30:43.99553-05:00","created_by":"daemon"}]}
{"id":"spry-prbody-epic","title":"PR Content Manipulation Epic","description":"## Overview\n\nAdd comprehensive PR body management to Spry:\n- Auto-generate PR bodies from commit messages\n- Support user-editable content between granular Spry markers\n- Optional stack links showing all PRs in order (using GitHub native PR refs)\n- Alpha warning footer\n- Update bodies on sync when content changes\n- PR template support with configurable placement\n\n## PR Body Structure\n\n```\n\u003c!-- spry:info - Your edits outside of spry markers will be preserved on sync. --\u003e\n[User prepended content]\n\u003c!-- spry:body:begin --\u003e\n[Commit message / group list]\n\u003c!-- spry:body:end --\u003e\n[PR template + user content]\n\u003c!-- spry:stack-links:begin --\u003e\n**Stack** (oldest → newest, targeting `main`):\n- #123\n- #124 ← this PR\n- #125\n\u003c!-- spry:stack-links:end --\u003e\n[User content]\n\u003c!-- spry:footer:begin --\u003e\n\u003csub\u003eAlpha warning\u003c/sub\u003e\n\u003c!-- spry:footer:end --\u003e\n[User appended content]\n```\n\n## Key Features\n- Hidden info comment explains edit preservation\n- Native GitHub PR references for stack links\n- Target branch shown in stack links header\n- Two-pass creation for stack links (create PRs → update with links)\n- Configurable settings with 3-level override (global → repo → per-stack)\n\n## Settings\n| Setting | Default | Description |\n|---------|---------|-------------|\n| showStackLinks | true | Show/hide stack links |\n| includePrTemplate | true | Include PR template |\n| prTemplateLocation | afterBody | Where to place template |\n\n## Plan File\nSee: .claude/plans/linked-sleeping-whale.md","status":"closed","priority":1,"issue_type":"epic","created_at":"2026-01-09T15:00:00-05:00","updated_at":"2026-01-09T16:40:07.397789-05:00","closed_at":"2026-01-09T16:40:07.397789-05:00","close_reason":"Closed"}
{"id":"spry-prbody-epic.1","title":"Add PR body API functions to pr.ts","description":"Add updatePRBody() and getPRBody() functions to src/github/pr.ts. Also modify findPRsByBranches to include body in returned data.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-09T15:52:27.051879-05:00","created_by":"don.denton","updated_at":"2026-01-09T16:26:11.929264-05:00","closed_at":"2026-01-09T16:26:11.929264-05:00","close_reason":"Closed","dependencies":[{"issue_id":"spry-prbody-epic.1","depends_on_id":"spry-prbody-epic","type":"parent-child","created_at":"2026-01-09T15:52:27.052518-05:00","created_by":"don.denton"}]}
{"id":"spry-prbody-epic.2","title":"Integrate two-pass body updates into sync.ts","description":"Modify src/cli/commands/sync.ts to:\n1. Find PR template at start\n2. Pass 1: Create new PRs with template, without stack links\n3. Pass 2: Update ALL PRs with complete stack links (if enabled and multiple PRs)\n4. Track content hashes to avoid unnecessary updates\n5. Push stack settings at end","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-09T15:52:27.181948-05:00","created_by":"don.denton","updated_at":"2026-01-09T16:32:34.036261-05:00","closed_at":"2026-01-09T16:32:34.036261-05:00","close_reason":"Closed","dependencies":[{"issue_id":"spry-prbody-epic.2","depends_on_id":"spry-prbody-epic","type":"parent-child","created_at":"2026-01-09T15:52:27.182608-05:00","created_by":"don.denton"},{"issue_id":"spry-prbody-epic.2","depends_on_id":"spry-stacksettings","type":"blocks","created_at":"2026-01-09T15:52:38.293607-05:00","created_by":"don.denton"},{"issue_id":"spry-prbody-epic.2","depends_on_id":"spry-configext","type":"blocks","created_at":"2026-01-09T15:52:38.394856-05:00","created_by":"don.denton"},{"issue_id":"spry-prbody-epic.2","depends_on_id":"spry-prbodygen","type":"blocks","created_at":"2026-01-09T15:52:38.502205-05:00","created_by":"don.denton"},{"issue_id":"spry-prbody-epic.2","depends_on_id":"spry-prbody-epic.1","type":"blocks","created_at":"2026-01-09T15:52:38.606737-05:00","created_by":"don.denton"}]}
{"id":"spry-prbody-epic.3","title":"Unit tests for stack-settings.ts","description":"Create src/git/stack-settings.test.ts with tests for:\n- Read/write settings\n- Per-stack config operations\n- Content hash tracking\n- Orphan cleanup","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-09T15:52:27.306895-05:00","created_by":"don.denton","updated_at":"2026-01-09T16:36:19.816837-05:00","closed_at":"2026-01-09T16:36:19.816837-05:00","close_reason":"Closed","dependencies":[{"issue_id":"spry-prbody-epic.3","depends_on_id":"spry-prbody-epic","type":"parent-child","created_at":"2026-01-09T15:52:27.307816-05:00","created_by":"don.denton"},{"issue_id":"spry-prbody-epic.3","depends_on_id":"spry-stacksettings","type":"blocks","created_at":"2026-01-09T15:52:38.71554-05:00","created_by":"don.denton"}]}
{"id":"spry-prbody-epic.4","title":"Unit tests for pr-body.ts","description":"Create src/github/pr-body.test.ts with tests for:\n- Trailer stripping\n- PR template discovery\n- Single commit body generation\n- Grouped commits body generation (bullet list)\n- Stack links formatting with 'this PR' marker\n- User content preservation between all marker pairs\n- Hash calculation\n- Empty body handling","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-09T15:52:27.425114-05:00","created_by":"don.denton","updated_at":"2026-01-09T16:36:19.921934-05:00","closed_at":"2026-01-09T16:36:19.921934-05:00","close_reason":"Closed","dependencies":[{"issue_id":"spry-prbody-epic.4","depends_on_id":"spry-prbody-epic","type":"parent-child","created_at":"2026-01-09T15:52:27.425793-05:00","created_by":"don.denton"},{"issue_id":"spry-prbody-epic.4","depends_on_id":"spry-prbodygen","type":"blocks","created_at":"2026-01-09T15:52:38.814542-05:00","created_by":"don.denton"}]}
{"id":"spry-prbody-epic.5","title":"Integration tests for PR body sync","description":"Add integration tests to tests/integration/sync.test.ts:\n- PR body set on creation\n- Body updates when commit changes\n- User content preserved on update in all gaps\n- Stack links appear/hidden based on config\n- Groups show commit list\n- PR template included when present\n- Two-pass works for new PRs","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-09T15:52:27.547004-05:00","created_by":"don.denton","updated_at":"2026-01-09T16:39:59.375092-05:00","closed_at":"2026-01-09T16:39:59.375092-05:00","close_reason":"Closed","dependencies":[{"issue_id":"spry-prbody-epic.5","depends_on_id":"spry-prbody-epic","type":"parent-child","created_at":"2026-01-09T15:52:27.547686-05:00","created_by":"don.denton"},{"issue_id":"spry-prbody-epic.5","depends_on_id":"spry-prbody-epic.2","type":"blocks","created_at":"2026-01-09T15:52:38.91562-05:00","created_by":"don.denton"}]}
{"id":"spry-prbodygen","title":"Create pr-body.ts for PR body generation and parsing","description":"## Goal\nCreate `src/github/pr-body.ts` with PR body generation and parsing utilities.\n\n## Constants\n```typescript\nconst MARKERS = {\n  INFO: \"\u003c!-- spry:info - Your edits outside of spry markers will be preserved on sync. --\u003e\",\n  BODY_BEGIN: \"\u003c!-- spry:body:begin --\u003e\",\n  BODY_END: \"\u003c!-- spry:body:end --\u003e\",\n  STACK_LINKS_BEGIN: \"\u003c!-- spry:stack-links:begin --\u003e\",\n  STACK_LINKS_END: \"\u003c!-- spry:stack-links:end --\u003e\",\n  FOOTER_BEGIN: \"\u003c!-- spry:footer:begin --\u003e\",\n  FOOTER_END: \"\u003c!-- spry:footer:end --\u003e\",\n};\n\nconst ALPHA_WARNING = `\u003csub\u003eCreated with [Spry](https://github.com/happycollision/spry) (alpha). Do not manually merge stacked PRs.\u003c/sub\u003e`;\n```\n\n## Key Types\n- `PRBodyParts` - parsed sections from existing body\n- `StackPRInfo` - PR number/title for stack links\n- `GenerateInitialPRBodyOptions` - options for new PR creation\n- `UpdatePRBodyOptions` - options for updating existing PR\n\n## Functions\n- `stripTrailersFromBody(body)` - Remove git trailers\n- `findPRTemplate()` - Find PR template in standard locations\n- `generateBodyContent(options)` - Commit message content\n- `generateStackLinksContent(stackPRs, currentIndex, targetBranch)` - Stack links using native GH refs (#123)\n- `generateFooterContent()` - Alpha warning\n- `generateInitialPRBody(options)` - Full body for new PR (includes info comment, template placement)\n- `generateUpdatedPRBody(options)` - Updated body preserving user content in all gaps\n- `parsePRBody(body)` - Extract PRBodyParts\n- `calculateContentHash(bodyContent, stackLinksContent)` - For change detection\n\n## Stack Links Format\n```markdown\n**Stack** (oldest → newest, targeting `main`):\n- #123\n- #124 ← this PR\n- #125\n```\nUses GitHub native PR references - GitHub auto-renders title/status/icon.\n\n## Info Comment\nHidden comment at top of freshly opened PRs:\n`\u003c!-- spry:info - Your edits outside of spry markers will be preserved on sync. --\u003e`\n\n## Tests\n- Trailer stripping\n- PR template discovery\n- Body generation (single + groups)\n- Stack links formatting\n- User content preservation\n- Hash calculation","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-09T15:03:00-05:00","updated_at":"2026-01-09T16:29:42.954799-05:00","closed_at":"2026-01-09T16:29:42.954799-05:00","close_reason":"Closed","dependencies":[{"issue_id":"spry-prbodygen","depends_on_id":"spry-prbody-epic","type":"parent-child","created_at":"2026-01-09T15:03:00-05:00","created_by":"claude"},{"issue_id":"spry-prbodygen","depends_on_id":"spry-configext","type":"depends-on","created_at":"2026-01-09T15:03:00-05:00","created_by":"claude"},{"issue_id":"spry-prbodygen","depends_on_id":"spry-configext","type":"blocks","created_at":"2026-01-09T15:52:38.192832-05:00","created_by":"don.denton"}]}
{"id":"spry-puc","title":"Trailer parsing","description":"## Goal\nExtract taspr-specific trailers from commit messages.\n\n## Background\nGit trailers are key-value pairs at the end of commit messages, following a specific format:\n```\nfeat: add user authentication\n\nImplements login flow with session management.\n\nTaspr-Commit-Id: a1b2c3d4\nTaspr-Group-Start: f7e8d9c0\nTaspr-Group-Title: Authentication feature\n```\n\ntaspr uses these trailers:\n- `Taspr-Commit-Id`: 8 hex chars, unique ID for each commit (survives rebases)\n- `Taspr-Group-Start`: 8 hex chars, marks the first commit of a group\n- `Taspr-Group-Title`: String, PR title for the group\n- `Taspr-Group-End`: 8 hex chars (same as Group-Start), marks the last commit of a group\n\n## Implementation\n\n### Using git interpret-trailers\n```bash\ngit interpret-trailers --parse \u003c\u003c\u003c \"commit message body\"\n```\n\nThis outputs:\n```\nTaspr-Commit-Id: a1b2c3d4\nTaspr-Group-Start: f7e8d9c0\n```\n\n### Function Signatures\n```typescript\ninterface CommitTrailers {\n  'Taspr-Commit-Id'?: string;\n  'Taspr-Group-Start'?: string;\n  'Taspr-Group-Title'?: string;\n  'Taspr-Group-End'?: string;\n  [key: string]: string | undefined;  // Allow other trailers\n}\n\nasync function parseTrailers(commitBody: string): Promise\u003cCommitTrailers\u003e\n\n// Convenience function to get trailers for a commit\nasync function getCommitTrailers(commitHash: string): Promise\u003cCommitTrailers\u003e\n```\n\n### Edge Cases\n1. **No trailers**: Return empty object\n2. **Non-taspr trailers**: Include them (e.g., Co-authored-by)\n3. **Malformed trailers**: Let git interpret-trailers handle\n4. **Multiple values for same key**: Use last value (git's behavior)\n\n## Testing Strategy\nTest with various commit message formats:\n1. No trailers\n2. Single trailer\n3. Multiple trailers\n4. Mixed taspr and other trailers\n5. Trailers with special characters in values\n\n## Files to Create/Modify\n- src/git/trailers.ts (create)\n\n## Acceptance Criteria\n- [ ] Correctly parses all taspr trailer types\n- [ ] Handles commits without trailers\n- [ ] Uses git interpret-trailers for correct parsing\n- [ ] Has unit tests for various message formats","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T14:22:49.259548-05:00","updated_at":"2026-01-10T00:36:02.200081-05:00","closed_at":"2025-12-26T01:07:19.162812-05:00","close_reason":"Implemented parseTrailers() and getCommitTrailers() in src/git/trailers.ts with 13 passing tests","dependencies":[{"issue_id":"spry-puc","depends_on_id":"spry-67b","type":"parent-child","created_at":"2025-12-25T14:22:53.156159-05:00","created_by":"daemon"},{"issue_id":"spry-puc","depends_on_id":"spry-4lh","type":"depends-on","created_at":"2025-12-25T14:22:53.429839-05:00","created_by":"daemon"},{"issue_id":"spry-puc","depends_on_id":"spry-4lh","type":"blocks","created_at":"2025-12-25T14:22:53.429839-05:00","created_by":"daemon"}]}
{"id":"spry-qsy","title":"Rework taspr view to handle groups","description":"## Goal\nUpdate `taspr view` to properly display groups in the stack visualization.\n\n## Current Behavior\nThe `taspr view` command shows individual commits but doesn't visually distinguish grouped commits or show group boundaries.\n\n## Desired Behavior\n- Show group boundaries clearly in the stack view\n- Display group title/name for grouped commits\n- Indicate which commits belong to which group\n- Show group status (e.g., if group has a PR)\n- Consider collapsible group view for large groups\n\n## Acceptance Criteria\n- [ ] Groups are visually distinguishable from individual commits\n- [ ] Group title is displayed\n- [ ] Group boundaries are clear (start/end)\n- [ ] Works with both single-commit and multi-commit groups\n- [ ] Maintains readability for mixed stacks (groups + singles)","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-02T10:58:54.158241-05:00","updated_at":"2026-01-10T00:36:02.197413-05:00","closed_at":"2026-01-02T21:16:20.499157-05:00","close_reason":"Closed","dependencies":[{"issue_id":"spry-qsy","depends_on_id":"spry-r22","type":"parent-child","created_at":"2026-01-02T10:58:54.158903-05:00","created_by":"dondenton"}]}
{"id":"spry-r0bq","title":"Test support for non-standard default branches and remote names","description":"Currently spry claims to support custom default branches (e.g., 'master', 'development') and custom remote names (e.g., 'github', 'upstream'), but we haven't verified this with tests.\n\nWe need to:\n1. Add test scenarios for repositories with default branches other than 'main' (e.g., 'master', 'development', 'develop')\n2. Add test scenarios for repositories with remote names other than 'origin' (e.g., 'github', 'upstream', 'fork')\n3. Verify all spry commands work correctly with these variations\n4. Fix any issues discovered during testing\n\nThis will ensure spry truly supports diverse git configurations as documented.","status":"open","priority":2,"issue_type":"epic","owner":"don.denton@trillianthealth.com","created_at":"2026-01-15T16:35:23.297319-05:00","created_by":"Don Denton","updated_at":"2026-01-17T00:43:51.866168-05:00"}
{"id":"spry-r0j","title":"Add taspr group --fix command to repair invalid group trailers","description":"After resolving rebase conflicts (especially when commits at group boundaries are removed), group trailers can become invalid. Add a --fix flag to taspr group that:\n\n1. Detects invalid group trailer states:\n   - Taspr-Group-Start without matching Taspr-Group-End\n   - Taspr-Group-End without matching Taspr-Group-Start\n   - Orphaned Taspr-Group-Title trailers\n   \n2. Offers repair options:\n   - Remove all group trailers from affected commits (reset to ungrouped)\n   - Attempt to repair by finding the closest valid group boundary\n   \n3. Can run non-interactively with --fix=remove or --fix=repair\n\nThis helps users recover after conflict resolution without needing to manually edit commit messages.","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-02T10:18:12.109801-05:00","updated_at":"2026-01-10T00:36:02.179155-05:00","closed_at":"2026-01-02T11:19:48.724327-05:00","close_reason":"Implemented taspr group --fix command: detects invalid groups (unclosed, overlapping, orphan ends) and removes all group trailers to repair. Added 5 integration tests."}
{"id":"spry-r22","title":"Epic 7: Group Management","description":"## Goal\nInteractive creation and management of commit groups (multi-commit PRs) via a unified TUI.\n\n## Background\n\n### Groups\nBy default, each commit becomes its own PR. Groups let you bundle multiple commits into a single PR.\n\nGroups are defined by trailers:\n- `Taspr-Group-Start: \u003cgroup-id\u003e` on first commit\n- `Taspr-Group-Title: \u003ctitle\u003e` on first commit (PR title)\n- `Taspr-Group-End: \u003cgroup-id\u003e` on last commit\n\n### Use Cases\n- Related changes that should be reviewed together\n- Work-in-progress commits that will be squashed\n- Logical feature that spans multiple commits\n\n## Revised Plan (January 2026)\n\nThe original plan for separate `group create/edit/dissolve` commands has been replaced with a **unified interactive TUI**.\n\n### taspr group\nLaunches a full-screen terminal UI that allows:\n- **Reordering commits** via move mode (Space to enter, Up/Down to swap)\n- **Assigning groups** via Left/Right arrows (cycles through A, B, C, ... Z, ungrouped)\n- **Conflict prediction** warns when moves would cause merge conflicts\n- **Single-commit groups** are allowed\n\nControls:\n- Up/Down: navigate (normal) / swap position (move mode)\n- Space: toggle move mode\n- Left/Right: cycle group assignment\n- Enter: confirm → name groups → rebase\n- Esc: cancel\n\n### taspr group dissolve\nSimple command to remove a group's trailers and break it back into individual commits.\n\n## Deliverables\n1. **Unified group TUI** (spry-6q3) - main interactive interface\n2. **Conflict prediction** (spry-0bl) - hybrid file-overlap + git merge-tree\n3. **Group rebase logic** (spry-fx7) - reordering and trailer injection\n4. **Group dissolve** (spry-my0) - remove group trailers\n5. **Sync validation** (spry-gx3) - block sync on invalid groups\n\n## Dependencies\n- Epic 2 must be complete (commits have IDs)\n\n## Validation\nGroups must not overlap and must be closed (Start has matching End).\n\n## Priority\nP2 - Enhancement after basic workflow is complete.","notes":"## Scenario-Based Testing Workflow\n\nAll tasks in this epic should follow this testing workflow:\n\n### After Implementation\n1. Run `bun run build` to build the CLI\n2. Run `bun test --no-coverage` to verify all tests pass\n3. Tell the user which scenario to run for manual testing\n\n### Available Scenarios\nRun `bun run scenario --help` or `bun run scenario` for interactive selection:\n- **emptyStack** - Just main branch, no feature work\n- **singleCommit** - One commit on feature branch (no ID)\n- **multiCommitStack** - 3 commits stacked on feature branch\n- **divergedMain** - Feature branch + upstream changes (needs rebase)\n- **withTasprIds** - 2 commits with Taspr-Commit-Id trailers\n- **mixedTrailerStack** - Some commits have IDs, some don't\n- **conflictScenario** - Setup that will conflict on rebase\n- **multipleBranches** - Two independent feature branches\n\n### New Scenarios Needed for Group Management\nAdd these to `src/scenario/definitions.ts` as tasks are implemented:\n- **withGroups** - Stack with existing group trailers (Group-Start/End/Title)\n- **unclosedGroup** - Stack with Group-Start but no Group-End\n- **overlappingGroups** - Stack with overlapping group trailers\n\n### Scenario Definition Location\n`src/scenario/definitions.ts` - add new scenarios following the existing pattern","status":"closed","priority":2,"issue_type":"epic","created_at":"2025-12-25T14:33:41.928419-05:00","updated_at":"2026-01-10T00:36:02.196774-05:00","closed_at":"2026-01-02T23:40:45.865844-05:00","close_reason":"Closed","dependencies":[{"issue_id":"spry-r22","depends_on_id":"spry-sbb","type":"depends-on","created_at":"2025-12-25T14:33:46.040656-05:00","created_by":"daemon"},{"issue_id":"spry-r22","depends_on_id":"spry-sbb","type":"blocks","created_at":"2025-12-25T14:33:46.040656-05:00","created_by":"daemon"}]}
{"id":"spry-ra3","title":"Add sp wt command (Happy Trees worktree management)","description":"Port git-ht (Happy Trees) worktree management to spry. Enables parallel Claude Code sessions via convenient worktree creation/removal.\n\nReference implementation: ~/dotfiles/bin/git-ht\n\nCommands:\n- sp wt new \u003cname\u003e - Create worktree + branch\n- sp wt rm \u003cname\u003e - Remove worktree + branches\n- sp wt setup - Setup script management\n- sp wt list - List worktrees\n\nConfig namespace: spry.tree.*\nImplementation: Full TypeScript port (no shell to git-ht)","status":"open","priority":2,"issue_type":"epic","created_at":"2026-01-10T15:22:56.66469-05:00","created_by":"dondenton","updated_at":"2026-01-10T20:46:55.264385-05:00"}
{"id":"spry-s4y","title":"Core infrastructure: wt command file, config helpers, path token expansion","description":"Create foundation for sp wt command.\n\nFiles to create:\n- src/cli/commands/wt.ts - Main command file with subcommands\n- src/git/wt-config.ts - Config helpers for spry.tree.* namespace\n- src/git/worktree.ts - Git worktree operations wrapper\n\nConfig keys to support:\n- spry.tree.dir (default: \u003crepo_root\u003e/../\u003crepo_name\u003e.worktrees)\n- spry.tree.defaultBranch (default: auto-detect from origin)\n- spry.tree.openWith - Default open command\n- spry.tree.setupScript - Setup script location\n\nPath token expansion utility for: \u003crepo_root\u003e, \u003crepo_name\u003e, \u003cworktree_root\u003e\n\nRegister wt command in src/cli/index.ts","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-10T15:23:04.414717-05:00","created_by":"dondenton","updated_at":"2026-01-10T20:46:55.739274-05:00","dependencies":[{"issue_id":"spry-s4y","depends_on_id":"spry-ra3","type":"parent-child","created_at":"2026-01-10T15:23:12.809289-05:00","created_by":"dondenton"}]}
{"id":"spry-sbb","title":"Epic 2: Initialize Commits for Tracking","description":"## Goal\nAdd `Taspr-Commit-Id` trailers to commits that don't have them, enabling stable tracking across rebases.\n\n## Background\n\n### The Tracking Problem\nGit commit hashes change whenever a commit is rebased, amended, or cherry-picked. taspr needs a stable identifier that survives these operations.\n\n### The Solution: Commit ID Trailers\nEvery commit gets a `Taspr-Commit-Id` trailer—an 8-character hex string that becomes part of the commit message:\n\n```\nfeat: add user authentication\n\nImplements login flow.\n\nTaspr-Commit-Id: a1b2c3d4\n```\n\nThis ID:\n- Survives rebases (message is preserved)\n- Links commits to branches and PRs\n- Enables tracking across history rewrites\n\n### ID Format\n- 8 hexadecimal characters (32 bits)\n- Generated via crypto.randomBytes(4).toString('hex')\n- Example: `a1b2c3d4`, `f7e8d9c0`\n\nWith 8 hex chars, collision probability is negligible for a typical stack (\u003c 50 commits). Once PRs merge, their commits leave the active tracking set.\n\n## Workflow\n\n1. User has commits without IDs\n2. Run `taspr sync`\n3. taspr identifies commits missing `Taspr-Commit-Id`\n4. taspr performs a rebase to add trailers to those commits\n5. Existing IDs are preserved; only missing ones are added\n\n## Implementation Approach\n\n### Interactive Rebase with exec\n```bash\ngit rebase -i --exec 'git commit --amend --no-edit -m \"$(git log -1 --format=%B | git interpret-trailers --trailer \"Taspr-Commit-Id: $(openssl rand -hex 4)\")\"' \u003cmerge-base\u003e\n```\n\nOr, more cleanly with a custom script that:\n1. Checks if commit already has Taspr-Commit-Id\n2. Only adds if missing\n3. Preserves all existing trailers\n\n### Sequence\n1. Check for dirty working tree (block if dirty)\n2. Find commits without Taspr-Commit-Id\n3. If none, no-op\n4. Rebase from merge-base, adding IDs to commits that need them\n5. Report which commits got IDs\n\n## Deliverable\nRunning `taspr sync` adds stable IDs to all commits in the stack via rebase, making them trackable.\n\n## Dependencies\n- Epic 1 must be complete (stack reading, trailer parsing)\n\n## Files to Create/Modify\n- src/core/sync.ts (create) - Sync orchestration\n- src/git/trailers.ts (modify) - Add trailer writing\n- src/cli/commands/sync.ts (create) - Sync command\n\n## Testable Outcome\n- New commits get IDs\n- Existing IDs are preserved through rebase\n- Dirty working tree blocks sync with clear message","status":"closed","priority":1,"issue_type":"epic","created_at":"2025-12-25T14:24:34.266966-05:00","updated_at":"2026-01-10T00:36:02.19712-05:00","closed_at":"2025-12-26T21:39:56.779724-05:00","close_reason":"All 5 child tasks complete. taspr sync now adds Taspr-Commit-Id trailers to commits.","dependencies":[{"issue_id":"spry-sbb","depends_on_id":"spry-67b","type":"blocks","created_at":"2025-12-25T14:24:37.974238-05:00","created_by":"daemon"},{"issue_id":"spry-sbb","depends_on_id":"spry-67b","type":"depends-on","created_at":"2025-12-25T14:24:37.974238-05:00","created_by":"daemon"}]}
{"id":"spry-sfux","title":"Integration: Make merge commits real in git","description":"Connect the TUI placeholder merge commits to actual git merge commit creation. This makes the indented branches real in the git DAG.\n\n## Context\n\nPhase 4 created placeholder merge commits in the TUI that are filtered out before git operations. Now we need to actually create real git merge commits when applying the group spec.\n\n## Changes Required\n\n### 1. Update applyGroupSpec to handle merge commits (src/git/group-rebase.ts)\n\nAdd logic to detect indented commits and create corresponding merge commits:\n\n```typescript\nexport async function applyGroupSpec(\n  spec: GroupSpec,\n  options: GitOptions = {},\n): Promise\u003cReorderResult\u003e {\n  await assertNotDetachedHead(options);\n\n  // NEW: Pre-operation validation\n  const validation = await validateMergeParents(options);\n  if (!validation.valid) {\n    return {\n      success: false,\n      error: `Invalid merge commit structure:\\n${validation.errors.join(\"\\n\")}`,\n    };\n  }\n\n  // ... existing order and group processing ...\n\n  // NEW: Detect indented sections from TUI state\n  // For each merge commit placeholder in the spec:\n  // 1. Find the parent commit (commit before first indented)\n  // 2. Find all indented commits\n  // 3. Create actual merge commit with:\n  //    - Parent 1: the parent commit\n  //    - Parent 2: last indented commit\n  //    - Tree: from last indented commit\n  //    - Message: auto-generated\n\n  // Use rebasePlumbing with the commits including merge commits\n  const result = await rebasePlumbing(baseRef, commitsWithMerges, options);\n\n  // NEW: Post-operation validation\n  const postValidation = await validateMergeParents(options);\n  if (!postValidation.valid) {\n    console.warn(\"Warning: Merge validation failed after operation:\", postValidation.errors);\n  }\n\n  // ... finalize and return\n}\n```\n\n### 2. Pass indent information through group spec\n\nUpdate the group spec format to include indent levels:\n\n```typescript\nexport interface GroupSpec {\n  order?: string[];  // Commit references\n  groups?: Map\u003cstring, string | null\u003e;  // hash -\u003e group ID\n  indents?: Map\u003cstring, number\u003e;  // NEW: hash -\u003e indent level (0 or 1)\n  mergeCommits?: MergeCommitSpec[];  // NEW: merge commit definitions\n}\n\nexport interface MergeCommitSpec {\n  position: number;  // Where in order\n  parentCommit: string;  // Hash of parent\n  branchCommits: string[];  // Hashes of indented commits\n  groupId: string;  // Group assignment\n}\n```\n\n### 3. Update group editor to pass indent info (src/tui/group-editor.ts)\n\n```typescript\n// When building the group spec to apply:\nconst indents = new Map\u003cstring, number\u003e();\nfor (const [idx, level] of finalState.indentLevels) {\n  const commit = finalState.commits[idx];\n  if (commit \u0026\u0026 !commit.isMergeCommit) {\n    indents.set(commit.hash, level);\n  }\n}\n\nconst mergeCommits: MergeCommitSpec[] = [];\nfor (const [idx, mergeInfo] of finalState.mergeCommits) {\n  // Build merge commit spec from placeholder\n  // Find parent and branch commits\n  const parentIdx = idx - 1;  // Merge comes after indented commits\n  const parentCommit = finalState.commits[parentIdx];\n  \n  const branchCommits: string[] = [];\n  // Find all indented commits between parent and merge\n  for (let i = parentIdx + 1; i \u003c idx; i++) {\n    const level = finalState.indentLevels.get(i);\n    if (level === 1) {\n      branchCommits.push(finalState.commits[i].hash);\n    }\n  }\n\n  mergeCommits.push({\n    position: idx,\n    parentCommit: parentCommit.hash,\n    branchCommits,\n    groupId: finalState.groups.get(idx) ?? \"A\",\n  });\n}\n\nconst spec: GroupSpec = { order, groups, indents, mergeCommits };\n```\n\n### 4. Create merge commits using git plumbing\n\nIn `applyGroupSpec`, when processing merge commit specs:\n\n```typescript\n// For each merge commit spec:\nconst parentHash = spec.parentCommit;  // Will be mapped to new hash after rebase\nconst lastBranchHash = spec.branchCommits[spec.branchCommits.length - 1];\n\n// After rebasing branch commits, create merge:\nconst tree = await getTree(lastBranchHash, options);  // Use branch tip tree\nconst message = `Merge: ${spec.groupId}\\n\\n${spec.branchCommits.map(h =\u003e commits.find(c =\u003e c.hash === h)?.subject).join(\"\\n- \")}`;\n\n// Add trailers\nconst trailers = {\n  \"Spry-Group\": spec.groupId,\n  \"Spry-Commit-Id\": generateCommitId(),\n  \"Spry-Merge-Parents\": [\n    getCommitId(parentHash),\n    getCommitId(lastBranchHash),\n  ],\n};\n\nconst messageWithTrailers = await addTrailers(message, trailers);\n\n// Create merge commit with two parents\nconst env = await getAuthorEnv(lastBranchHash, options);  // Use branch author\nconst mergeHash = await createCommit(tree, [parentHashNew, lastBranchHashNew], messageWithTrailers, env, options);\n```\n\n## Merge Commit Message Format\n\n```\nMerge: \u003cgroup-title\u003e (\u003ccommit-range\u003e)\n\nMerging commits:\n- \u003ccommit1-subject\u003e\n- \u003ccommit2-subject\u003e\n\nSpry-Group: \u003cgroup-id\u003e\nSpry-Commit-Id: \u003cmerge-commit-id\u003e\nSpry-Merge-Parents: \u003cparent1-id\u003e\nSpry-Merge-Parents: \u003cparent2-id\u003e\n```\n\n## Verification\n\n1. End-to-end test: Indent commits in TUI, verify real merge commit created\n2. Test with multiple branch-and-merge sections in one group\n3. Verify merge commit has correct parents (git log --graph)\n4. Verify merge commit has correct trailers\n5. Test moving commits works after merge created\n6. Test sync/rebase preserves merge structure\n\n## Files to Modify\n\n- src/git/group-rebase.ts\n- src/tui/group-editor.ts\n- src/types.ts (if adding GroupSpec fields)\n\n## Dependencies\n\nRequires Phase 1-4 complete (data model, rebase operations, UI, validation).","status":"open","priority":2,"issue_type":"task","owner":"don.denton@trillianthealth.com","created_at":"2026-01-13T11:39:30.427919-05:00","created_by":"Don Denton","updated_at":"2026-01-13T11:39:30.427919-05:00","dependencies":[{"issue_id":"spry-sfux","depends_on_id":"spry-x0bw","type":"blocks","created_at":"2026-01-13T11:40:21.240285-05:00","created_by":"Don Denton"},{"issue_id":"spry-sfux","depends_on_id":"spry-y2tt","type":"blocks","created_at":"2026-01-13T11:40:21.311031-05:00","created_by":"Don Denton"},{"issue_id":"spry-sfux","depends_on_id":"spry-ckz7","type":"blocks","created_at":"2026-01-13T11:40:21.379935-05:00","created_by":"Don Denton"}]}
{"id":"spry-sicu","title":"'sp sync' should fast-forward local main if behind origin","description":"When running 'sp sync', we should automatically fast-forward the user's local main branch (or equivalent default branch) if it is behind the remote version.\n\nWe need to:\n1. Check if local main is behind origin/main\n2. If it can be fast-forwarded (no divergence), automatically update it\n3. Print a clear warning if the local main cannot be fast-forwarded (e.g., has local commits, diverged history)\n4. Handle the user's configured default branch name (main, master, development, etc.)\n5. Handle the user's configured remote name (origin, upstream, etc.)\n\nThis keeps the local main branch in sync with the remote automatically, making 'sp sync' more convenient and reducing the chance of stale local branches.","status":"open","priority":2,"issue_type":"feature","owner":"don.denton@trillianthealth.com","created_at":"2026-01-16T12:35:44.423872-05:00","created_by":"Don Denton","updated_at":"2026-01-16T12:35:44.423872-05:00","dependencies":[{"issue_id":"spry-sicu","depends_on_id":"spry-75b4","type":"relates-to","created_at":"2026-01-16T12:36:31.458436-05:00","created_by":"Don Denton"}]}
{"id":"spry-stacksettings","title":"Create stack-settings.ts for per-stack configuration","description":"## Goal\nCreate `src/git/stack-settings.ts` to store per-stack settings following the `group-titles.ts` pattern.\n\n## Storage Location\n`refs/spry/\u003cusername\u003e/stack-settings` - JSON blob via git hash-object/update-ref\n\n## Data Structure\n```typescript\ninterface StackSettings {\n  stacks: Record\u003cstring, StackConfig\u003e;  // keyed by stack root unit ID\n  contentHashes: Record\u003cstring, string\u003e; // keyed by unit ID\n}\n\ninterface StackConfig {\n  showStackLinks?: boolean;\n  includePrTemplate?: boolean;\n  prTemplateLocation?: TemplateLocation;\n}\n\ntype TemplateLocation = \"prepend\" | \"afterBody\" | \"afterStackLinks\" | \"append\";\n```\n\n## Functions\n- `readStackSettings()` / `writeStackSettings()`\n- `getStackConfig(stackRootId)` / `setStackConfig(stackRootId, config)`\n- `getContentHash(unitId)` / `setContentHash(unitId, hash)`\n- `fetchStackSettings()` / `pushStackSettings()`\n- `purgeOrphanedSettings(currentUnitIds)`\n\n## Pattern to Follow\nModel after `src/git/group-titles.ts`\n\n## Tests\n- Read/write settings\n- Per-stack config operations\n- Content hash tracking\n- Orphan cleanup","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-09T15:01:00-05:00","updated_at":"2026-01-09T16:26:11.975678-05:00","closed_at":"2026-01-09T16:26:11.975678-05:00","close_reason":"Closed","dependencies":[{"issue_id":"spry-stacksettings","depends_on_id":"spry-prbody-epic","type":"parent-child","created_at":"2026-01-09T15:01:00-05:00","created_by":"claude"}]}
{"id":"spry-suj","title":"Change detection (local vs remote)","description":"## Goal\nDetect when local commits have changed relative to their remote branches.\n\n## Implementation\n\n```typescript\n// src/git/remote.ts\n\nasync function getRemoteBranchCommit(branchName: string): Promise\u003cstring | null\u003e {\n  // Fetch latest (optional - can skip for performance)\n  // await $\\`git fetch origin ${branchName}\\`.nothrow();\n  \n  const result = await $\\`git rev-parse origin/${branchName}\\`.nothrow();\n  if (result.exitCode !== 0) {\n    return null; // Branch doesn't exist on remote\n  }\n  return result.stdout.toString().trim();\n}\n\ninterface SyncStatus {\n  branchName: string;\n  localCommit: string;\n  remoteCommit: string | null;\n  needsUpdate: boolean;\n  needsCreate: boolean;\n}\n\nasync function getSyncStatus(unit: PRUnit, branchName: string): Promise\u003cSyncStatus\u003e {\n  const localCommit = unit.commits[unit.commits.length - 1];\n  const remoteCommit = await getRemoteBranchCommit(branchName);\n  \n  return {\n    branchName,\n    localCommit,\n    remoteCommit,\n    needsUpdate: remoteCommit !== null \u0026\u0026 remoteCommit !== localCommit,\n    needsCreate: remoteCommit === null,\n  };\n}\n```\n\n### Batch Status Check\n```typescript\nasync function getAllSyncStatuses(\n  units: PRUnit[], \n  config: BranchNameConfig\n): Promise\u003cMap\u003cstring, SyncStatus\u003e\u003e {\n  const statuses = new Map();\n  \n  for (const unit of units) {\n    const branch = getBranchName(unit.id, config);\n    const status = await getSyncStatus(unit, branch);\n    statuses.set(unit.id, status);\n  }\n  \n  return statuses;\n}\n```\n\n## Usage in Sync\n```typescript\nconst statuses = await getAllSyncStatuses(units, config);\n\nfor (const [id, status] of statuses) {\n  if (status.needsCreate) {\n    // Push new branch, create PR\n  } else if (status.needsUpdate) {\n    // Force push updated branch\n  } else {\n    // No change needed\n  }\n}\n```\n\n## Edge Cases\n1. **Branch doesn't exist**: needsCreate = true\n2. **Branch up to date**: needsUpdate = false\n3. **Branch behind**: needsUpdate = true\n\n## Testing\n- Local matches remote → no update needed\n- Local differs from remote → update needed\n- Remote branch doesn't exist → create needed\n\n## Files to Create\n- src/git/remote.ts\n\n## Acceptance Criteria\n- [ ] Detects when local differs from remote\n- [ ] Detects when branch doesn't exist\n- [ ] Handles fetch errors gracefully","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T14:29:23.93778-05:00","updated_at":"2026-01-10T00:36:02.165745-05:00","closed_at":"2025-12-29T20:55:34.614876-05:00","dependencies":[{"issue_id":"spry-suj","depends_on_id":"spry-d0k","type":"parent-child","created_at":"2025-12-25T14:29:27.510279-05:00","created_by":"daemon"}]}
{"id":"spry-t9z","title":"Detect and handle shallow clones","description":"Commands like getMergeBase() fail on shallow clones with cryptic messages. Add detection and clear error explaining the limitation.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-10T00:28:12.958182-05:00","created_by":"don.denton","updated_at":"2026-01-10T00:28:12.958182-05:00","dependencies":[{"issue_id":"spry-t9z","depends_on_id":"spry-do5","type":"parent-child","created_at":"2026-01-10T01:04:18.568938-05:00","created_by":"don.denton"}]}
{"id":"spry-tew","title":"Evaluate PR inheritance behavior","description":"Test the new PR inheritance features:\n1. Group commits with existing PRs - verify adoption prompt works\n2. Dissolve group with open PR - verify inheritance prompt works\n3. Dissolve group without PR - verify donor keeps ID\n4. Non-interactive mode - verify --inherit and --no-inherit flags work\n5. Verify superseded PRs are closed correctly","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-04T15:32:06.363871-05:00","updated_at":"2026-01-10T00:36:02.195336-05:00"}
{"id":"spry-tov","title":"Audit tests for surprising default behaviors","description":"Review all tests to identify surprising or potentially harmful default behaviors that may have been implemented by the LLM.\n\nKnown examples:\n- `group --fix` in non-TTY mode automatically dissolves problematic groups (data loss!)\n\nGoals:\n- Find other cases where defaults could cause unexpected data loss\n- Identify overly aggressive automatic behaviors\n- Document and fix any surprising behaviors found","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-03T23:28:18.845034-05:00","updated_at":"2026-01-10T00:36:02.183579-05:00"}
{"id":"spry-toz","title":"Dirty state detection","description":"## Goal\nBlock sync operations when there are uncommitted changes.\n\n## Background\nRebasing with uncommitted changes can cause problems:\n- Changes get lost\n- Conflicts are harder to resolve\n- State becomes confusing\n\ntaspr should detect and block this upfront with a clear message.\n\n## Implementation\n\n```typescript\n// src/git/status.ts\n\ninterface WorkingTreeStatus {\n  isDirty: boolean;\n  hasUnstagedChanges: boolean;\n  hasStagedChanges: boolean;\n  hasUntrackedFiles: boolean;\n}\n\nasync function getWorkingTreeStatus(): Promise\u003cWorkingTreeStatus\u003e {\n  // Check for any changes\n  const status = await $`git status --porcelain`.text();\n  \n  const lines = status.trim().split('\\n').filter(Boolean);\n  \n  return {\n    isDirty: lines.length \u003e 0,\n    hasUnstagedChanges: lines.some(l =\u003e l[1] !== ' '),\n    hasStagedChanges: lines.some(l =\u003e l[0] !== ' ' \u0026\u0026 l[0] !== '?'),\n    hasUntrackedFiles: lines.some(l =\u003e l.startsWith('??')),\n  };\n}\n\nasync function requireCleanWorkingTree(): Promise\u003cvoid\u003e {\n  const status = await getWorkingTreeStatus();\n  \n  if (status.hasStagedChanges || status.hasUnstagedChanges) {\n    throw new DirtyWorkingTreeError(status);\n  }\n  \n  // Note: Untracked files are okay—they don't affect rebase\n}\n```\n\n### Error Message\n```\n✗ Error: Cannot sync with uncommitted changes\n\n  You have:\n    • 2 staged changes\n    • 3 unstaged changes\n\n  Please commit or stash your changes first:\n    git stash        # Temporarily save changes\n    taspr sync       # Run sync\n    git stash pop    # Restore changes\n```\n\n## Usage in Sync\n\n```typescript\nasync function sync(options: SyncOptions) {\n  // First check: working tree must be clean\n  await requireCleanWorkingTree();\n  \n  // Now safe to proceed with rebase operations\n  ...\n}\n```\n\n## Testing\n1. Clean working tree → passes\n2. Staged changes → blocks\n3. Unstaged changes → blocks\n4. Only untracked files → passes (untracked don't affect rebase)\n\n## Files to Create\n- src/git/status.ts\n\n## Acceptance Criteria\n- [ ] Detects staged changes\n- [ ] Detects unstaged changes\n- [ ] Allows untracked files\n- [ ] Provides clear error message\n- [ ] Suggests git stash as workaround","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T14:25:46.906529-05:00","updated_at":"2026-01-10T00:36:02.19443-05:00","closed_at":"2025-12-26T21:12:09.239717-05:00","close_reason":"Implemented getWorkingTreeStatus and requireCleanWorkingTree in src/git/status.ts","dependencies":[{"issue_id":"spry-toz","depends_on_id":"spry-sbb","type":"parent-child","created_at":"2025-12-25T14:25:50.62641-05:00","created_by":"daemon"}]}
{"id":"spry-v1c","title":"Flaky test: land retargets next PR to main","description":"## Failed Test\n```\nGitHub Integration: land \u003e retargets next PR to main after landing\n```\n\n## How to Run\n```bash\nGITHUB_INTEGRATION_TESTS=1 bun test tests/integration/land.test.ts -t 'retargets next PR'\n```\n\n## Error\n```\nExpected to contain: \"✓ Merged PR #92 to main\"\nReceived: \"Merging PR #90 (retarget 1 [cosmic-heron-ter])...\\n✓ Merged PR #90 to main\\n...\"\n```\n\n## Analysis\nThe test creates 3 commits, syncs to create 3 PRs (#90, #91, #92), then lands the first one.\n\n**Root cause suspicion:** The test uses `repo.findPRs(repo.uniqueId)` and assumes `prs[0]` is the first/bottom PR. But `findPRs` likely returns PRs in creation order (newest first) or some other order, not stack order.\n\nSo `firstPr` gets #92 (the last created), but `sp land` correctly merges #90 (the actual bottom of stack).\n\n**Fix approach:** Sort PRs by number ascending before assigning to firstPr/secondPr/thirdPr, or use a more explicit lookup.\n\n## Location\ntests/integration/land.test.ts:91","status":"closed","priority":0,"issue_type":"bug","created_at":"2026-01-10T15:26:15.095178-05:00","created_by":"dondenton","updated_at":"2026-01-10T16:14:48.164386-05:00","closed_at":"2026-01-10T16:14:48.164386-05:00","close_reason":"Fixed: see commit"}
{"id":"spry-v4b","title":"Install and configure oxlint","description":"Install oxlint (Oxc's fast JavaScript/TypeScript linter) and configure it for the project. This includes adding the package, creating configuration files, and setting up npm scripts.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-26T01:04:38.694306-05:00","updated_at":"2026-01-10T00:36:02.17754-05:00","closed_at":"2025-12-26T01:24:31.975995-05:00","close_reason":"Installed oxlint v1.35.0 and configured with default rules. Added lint script to package.json."}
{"id":"spry-vap","title":"Windows compatibility - paths, line endings, shell escaping","description":"Path separators, line endings (CRLF), and shell escaping assume Unix. Windows users will hit failures. Need proper escaping and cross-platform path handling.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-10T00:28:12.874561-05:00","created_by":"don.denton","updated_at":"2026-01-10T00:28:12.874561-05:00","dependencies":[{"issue_id":"spry-vap","depends_on_id":"spry-do5","type":"parent-child","created_at":"2026-01-10T01:04:18.524945-05:00","created_by":"don.denton"}]}
{"id":"spry-vc7","title":"Add process locking to prevent concurrent operations","description":"Multiple sp commands running simultaneously can corrupt state - last write to refs wins silently. Implement .spry/lock file mechanism to prevent concurrent operations.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-10T00:28:12.372493-05:00","created_by":"don.denton","updated_at":"2026-01-10T14:26:45.942081-05:00","closed_at":"2026-01-10T14:26:45.942081-05:00","close_reason":"Punted - will document that users should not run concurrent sp commands in the same repo instead of implementing locking","dependencies":[{"issue_id":"spry-vc7","depends_on_id":"spry-do5","type":"parent-child","created_at":"2026-01-10T01:04:18.243697-05:00","created_by":"don.denton"}]}
{"id":"spry-vpx","title":"Add command field to TasprResult interface","description":"Read the parent epic spry-ww0 for full context.\n\n## Task\nExtend the TasprResult interface in tests/integration/helpers.ts to include the exact command that was executed.\n\n## Changes\n\n1. Rename TasprResult to CommandResult (or keep both with CommandResult extending TasprResult)\n\n2. Add command field to the interface\n\n3. Update runTaspr() to build and return the command string by constructing it from the command and args parameters\n\n4. The convenience wrappers (runSync, runView, runLand, runClean) already call runTaspr so they will automatically return the new type.\n\n## Files\n- tests/integration/helpers.ts\n\n## Acceptance\n- All existing tests still pass\n- CommandResult includes the command field with the exact CLI invocation","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-05T00:33:02.064802-05:00","updated_at":"2026-01-09T00:40:32.020717-05:00","closed_at":"2026-01-09T00:40:32.020717-05:00","close_reason":"Closed"}
{"id":"spry-vu6","title":"Interactive group repair mode for --fix","description":"The current `taspr group --fix` just removes all group trailers, which is a destructive 'nuclear option'. Instead, it should launch an interactive TUI that:\n\n1. Shows the detected error (unclosed group, overlapping groups, orphan end)\n2. Visualizes the problematic commits and their current group trailers\n3. Offers repair options:\n   - For unclosed groups: select which commit should be the group end\n   - For overlapping groups: choose which group to keep, or adjust boundaries\n   - For orphan ends: select which commit should be the group start, or remove the orphan\n4. Allows dissolving as a last resort (current behavior)\n\nThe TUI should reuse the existing group-editor infrastructure where possible.\n\n## Acceptance Criteria\n- [ ] Interactive mode shows the specific error clearly\n- [ ] User can select repair action (not just dissolve)\n- [ ] For unclosed groups: can pick the end commit\n- [ ] For overlapping groups: can adjust which commits belong to which group\n- [ ] For orphan ends: can pick the start commit or remove\n- [ ] Non-interactive fallback with `--fix=dissolve` preserves current behavior","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-02T11:23:37.164774-05:00","updated_at":"2026-01-10T00:36:02.180205-05:00","closed_at":"2026-01-02T11:55:37.693697-05:00","close_reason":"Closed"}
{"id":"spry-vx7","title":"View --all flag for all stacks","description":"## Goal\nShow all known stacks across branches with `taspr view --all`.\n\n## Implementation\n\n```typescript\n// src/cli/commands/view.ts\n\nasync function viewAll() {\n  // Find all branches with taspr prefix\n  const config = await getBranchNameConfig();\n  const prefix = config.branchPrefix;\n  \n  const result = await $\\`git branch -r --list 'origin/\\${prefix}/*'\\`;\n  const branches = result.stdout.toString().trim().split('\\n')\n    .map(b =\u003e b.trim().replace('origin/', ''));\n  \n  // Group by user\n  const byUser = groupBy(branches, b =\u003e b.split('/')[1]);\n  \n  // Display each stack\n  for (const [user, userBranches] of Object.entries(byUser)) {\n    console.log(\\`\\\\n### \\${user}'s stacks\\\\n\\`);\n    \n    // Group by local branch (if we can determine it)\n    // For now, just list all PRs\n    for (const branch of userBranches) {\n      const pr = await findPRByBranch(branch);\n      if (pr) {\n        console.log(\\`  \\${getPRStatusIcon(pr)} #\\${pr.number} \\${pr.title}\\`);\n      }\n    }\n  }\n}\n```\n\n## Output\n```\n$ taspr view --all\n\n### msims's stacks\n\nfeature/auth (3 PRs)\n  ✓ #142 Add user model\n  ◐ #143 Authentication feature\n  ◐ #144 Add admin dashboard\n\nfeature/api (2 PRs)\n  ◐ #145 Add REST endpoints\n  ○ Add GraphQL\n\n### other-user's stacks\n...\n```\n\n## Challenges\n- Determining which branches belong to which \"stack\"\n- May require local state to track stack groupings\n\n## Simpler Alternative\nJust list all PRs owned by current user:\n```typescript\nasync function viewAll() {\n  const username = await getGitHubUsername();\n  const result = await $\\`gh pr list --author \\${username} --json number,title,state,headRefName\\`;\n  // Display all user's PRs\n}\n```\n\n## Files to Modify\n- src/cli/commands/view.ts\n\n## Acceptance Criteria\n- [ ] Lists all stacks/PRs with --all flag\n- [ ] Groups by user or branch\n- [ ] Shows status for each","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-25T14:33:18.747309-05:00","updated_at":"2026-01-10T00:36:02.198801-05:00","closed_at":"2025-12-31T14:28:25.392643-05:00","close_reason":"Implemented --all flag for view command that lists all PRs authored by the current user, grouped by state (Open/Merged/Closed)","dependencies":[{"issue_id":"spry-vx7","depends_on_id":"spry-7qh","type":"parent-child","created_at":"2025-12-25T14:33:23.016339-05:00","created_by":"daemon"},{"issue_id":"spry-vx7","depends_on_id":"spry-7a5","type":"blocks","created_at":"2025-12-25T14:33:23.289568-05:00","created_by":"daemon"},{"issue_id":"spry-vx7","depends_on_id":"spry-7a5","type":"depends-on","created_at":"2025-12-25T14:33:23.289568-05:00","created_by":"daemon"}]}
{"id":"spry-w74","title":"Add story logging to sync.test.ts","description":"Read the parent epic spry-mbn for full context.\n\n## Task\nAdd story logging annotations to tests/integration/sync.test.ts as the first integration test file.\n\n## Pattern\n\n1. Import and create story at describe level:\n```\nimport { createStory } from \"../helpers/story.ts\";\n\ndescribe(\"sync command\", () =\u003e {\n  const story = createStory(\"sync.test.ts\");\n\n  afterAll(async () =\u003e {\n    await story.flush();\n  });\n  ...\n});\n```\n\n2. For each test, add story annotations:\n```\ntest(\"test name\", async () =\u003e {\n  story.begin(\"test name\");\n  story.narrate(\"Plain English description of the scenario...\");\n\n  // ... test setup (no logging needed) ...\n\n  const result = await runSync(repo.path, { open: true });\n  story.log(result);\n  story.end();\n\n  // ... assertions ...\n});\n```\n\n## Guidelines\n- Narratives describe scenarios contextually, not mechanically\n- Focus on what is being demonstrated\n- Err on showing less - only log the key command output\n- Setup steps dont need to be logged unless they add clarity\n\n## Files\n- tests/integration/sync.test.ts\n\n## Acceptance\n- All tests in sync.test.ts have story annotations\n- Running TASPR_STORY_TEST_LOGGING=1 bun test tests/integration/sync.test.ts produces test-logs/sync.md and test-logs/sync.ansi","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-05T00:33:20.666806-05:00","updated_at":"2026-01-10T00:36:02.185777-05:00","closed_at":"2026-01-09T11:24:03.834833-05:00","close_reason":"Added story logging to sync.test.ts","dependencies":[{"issue_id":"spry-w74","depends_on_id":"spry-djk","type":"blocks","created_at":"2026-01-05T00:33:48.15932-05:00","created_by":"dondenton"}]}
{"id":"spry-wpm","title":"PR creation via gh CLI","description":"## Goal\nCreate GitHub PRs for PRUnits using the gh CLI.\n\n## Implementation\n\n```typescript\n// src/github/pr.ts\n\ninterface CreatePROptions {\n  title: string;\n  head: string;      // Branch name for this PR\n  base: string;      // Parent branch or main\n  body?: string;\n}\n\nasync function createPR(options: CreatePROptions): Promise\u003c{ number: number; url: string }\u003e {\n  const result = await $\\`gh pr create \n    --title ${options.title}\n    --head ${options.head}\n    --base ${options.base}\n    --body ${options.body || ''}\n  \\`.json();\n  \n  return {\n    number: result.number,\n    url: result.url,\n  };\n}\n```\n\n### Stack Structure\nFor a stack [A, B, C] (bottom to top):\n```\nPR for A: base = main,     head = taspr/user/a-id\nPR for B: base = A's head, head = taspr/user/b-id\nPR for C: base = B's head, head = taspr/user/c-id\n```\n\n```typescript\nasync function createStackPRs(\n  units: PRUnit[], \n  branches: Map\u003cstring, string\u003e,\n  defaultBranch: string\n): Promise\u003cMap\u003cstring, { number: number; url: string }\u003e\u003e {\n  const prs = new Map();\n  \n  let baseBranch = defaultBranch;\n  \n  for (const unit of units) {\n    const headBranch = branches.get(unit.id)!;\n    \n    const pr = await createPR({\n      title: unit.title,\n      head: headBranch,\n      base: baseBranch,\n    });\n    \n    prs.set(unit.id, pr);\n    baseBranch = headBranch; // Next PR bases on this one\n  }\n  \n  return prs;\n}\n```\n\n### Default Branch Detection\n```typescript\nasync function getDefaultBranch(): Promise\u003cstring\u003e {\n  // Try git config first\n  const configResult = await $\\`git config --get taspr.defaultBranch\\`.nothrow();\n  if (configResult.exitCode === 0) {\n    return configResult.stdout.toString().trim();\n  }\n  \n  // Fall back to origin's default\n  const remote = await $\\`git remote show origin\\`.text();\n  const match = remote.match(/HEAD branch: (\\S+)/);\n  return match?.[1] || 'main';\n}\n```\n\n### PR Body\nFor now, minimal body. Later can add stack visualization:\n\n```typescript\nfunction generatePRBody(unit: PRUnit): string {\n  if (unit.type === 'single') {\n    return ''; // Use commit message\n  }\n  \n  // For groups, list commits\n  return `## Commits\\n${unit.commits.map(c =\u003e `- ${c}`).join('\\n')}`;\n}\n```\n\n## Edge Cases\n1. **PR already exists**: Don't create duplicate (handled by lookup task)\n2. **Base branch doesn't exist**: Error (shouldn't happen if we push in order)\n3. **Rate limiting**: Retry logic\n\n## Testing\n- Create single PR\n- Create stacked PRs with correct base/head\n- Verify titles match PRUnit titles\n\n## Files to Create\n- src/github/pr.ts\n\n## Acceptance Criteria\n- [ ] Creates PR with correct title\n- [ ] Sets correct base/head branches\n- [ ] Returns PR number and URL\n- [ ] PRs form correct stack (each bases on previous)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T14:27:38.225862-05:00","updated_at":"2026-01-10T00:36:02.1669-05:00","closed_at":"2025-12-26T23:29:21.528274-05:00","close_reason":"Implemented and tested","dependencies":[{"issue_id":"spry-wpm","depends_on_id":"spry-ce1","type":"parent-child","created_at":"2025-12-25T14:27:41.917963-05:00","created_by":"daemon"},{"issue_id":"spry-wpm","depends_on_id":"spry-xnl","type":"blocks","created_at":"2025-12-25T14:27:42.19973-05:00","created_by":"daemon"},{"issue_id":"spry-wpm","depends_on_id":"spry-xnl","type":"depends-on","created_at":"2025-12-25T14:27:42.19973-05:00","created_by":"daemon"}]}
{"id":"spry-wv7","title":"Add command field to TasprResult interface","description":"Read the parent epic spry-mbn for full context.\n\n## Task\nExtend the TasprResult interface in tests/integration/helpers.ts to include the exact command that was executed.\n\n## Changes\n\n1. Rename TasprResult to CommandResult (or keep both with CommandResult extending TasprResult)\n\n2. Add command field to the interface\n\n3. Update runTaspr() to build and return the command string by constructing it from the command and args parameters\n\n4. The convenience wrappers (runSync, runView, runLand, runClean) already call runTaspr so they will automatically return the new type.\n\n## Files\n- tests/integration/helpers.ts\n\n## Acceptance\n- All existing tests still pass\n- CommandResult includes the command field with the exact CLI invocation","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-05T00:33:02.064802-05:00","updated_at":"2026-01-10T00:36:02.184676-05:00","closed_at":"2026-01-09T00:40:32.020717-05:00","close_reason":"Closed"}
{"id":"spry-x0bw","title":"Git operations: Preserve merge commits in rebase operations","description":"Update all rebase plumbing operations to preserve merge commit structure, including parent relationships and tree content.\n\n## Context\n\nCurrently, rebase operations assume single-parent commits. When rebasing a merge commit, only the first parent is used and the merge structure is lost. We need to preserve all parent relationships and the merge resolution tree.\n\n**Key insight:** The plumbing layer already supports merge commits - `getParents()` returns all parents and `createCommit()` accepts multiple parents. We just need to use them correctly.\n\n## Changes Required\n\n### 1. Update rewriteCommitChain (src/git/plumbing.ts:430-465)\n\nTrack and map all parents during message rewrites:\n\n```typescript\nexport async function rewriteCommitChain(\n  commits: string[],\n  rewrites: Map\u003cstring, string\u003e,\n  options: GitOptions = {},\n): Promise\u003cChainRewriteResult\u003e {\n  const mapping = new Map\u003cstring, string\u003e();\n\n  for (const originalHash of commits) {\n    const tree = await getTree(originalHash, options);\n    const env = await getAuthorAndCommitterEnv(originalHash, options);\n    const originalParents = await getParents(originalHash, options);  // Use getParents (all)\n\n    const newMessage = rewrites.get(originalHash) ?? \n      (await getCommitMessage(originalHash, options));\n\n    // Map parents: if parent was rewritten, use new hash\n    const newParents: string[] = [];\n    for (const origParent of originalParents) {\n      const mappedParent = mapping.get(origParent);\n      if (mappedParent) {\n        newParents.push(mappedParent);  // In our chain, rewritten\n      } else {\n        newParents.push(origParent);  // Outside chain, keep original\n      }\n    }\n\n    // Create with all mapped parents\n    const newHash = await createCommit(tree, newParents, newMessage, env, options);\n    mapping.set(originalHash, newHash);\n  }\n  // ... return result\n}\n```\n\n### 2. Update rebasePlumbing (src/git/plumbing.ts:507-549)\n\nDetect and handle merge commits during cherry-pick:\n\n```typescript\nexport async function rebasePlumbing(\n  onto: string,\n  commits: string[],\n  options: GitOptions = {},\n): Promise\u003cPlumbingRebaseResult\u003e {\n  const mapping = new Map\u003cstring, string\u003e();\n  let currentTip = onto;\n\n  for (const commit of commits) {\n    const originalParents = await getParents(commit, options);\n    const isMergeCommit = originalParents.length \u003e 1;\n\n    if (isMergeCommit) {\n      // MERGE COMMIT: Map all parents and preserve tree\n      const newParents: string[] = [];\n      for (const originalParent of originalParents) {\n        const newParent = mapping.get(originalParent);\n        if (newParent) {\n          newParents.push(newParent);  // Parent in rebase chain\n        } else {\n          newParents.push(originalParent);  // Parent outside chain\n        }\n      }\n\n      // Preserve merge tree exactly (no re-merge)\n      const tree = await getTree(commit, options);\n      const message = await getCommitMessage(commit, options);\n      const env = await getAuthorEnv(commit, options);\n\n      const newHash = await createCommit(tree, newParents, message, env, options);\n      mapping.set(commit, newHash);\n      currentTip = newHash;\n\n    } else {\n      // REGULAR COMMIT: Three-way merge (existing logic)\n      const originalParent = originalParents[0] || onto;\n      const mergeResult = await mergeTree(originalParent, currentTip, commit, options);\n      \n      if (!mergeResult.ok) {\n        return {\n          ok: false,\n          conflictCommit: commit,\n          conflictInfo: mergeResult.conflictInfo,\n        };\n      }\n\n      const message = await getCommitMessage(commit, options);\n      const env = await getAuthorEnv(commit, options);\n      const newHash = await createCommit(mergeResult.tree, [currentTip], message, env, options);\n      \n      mapping.set(commit, newHash);\n      currentTip = newHash;\n    }\n  }\n\n  return { ok: true, newTip: currentTip, mapping };\n}\n```\n\n### 3. Update injectMissingIds (src/git/rebase.ts)\n\nAdd `Spry-Merge-Parents` trailers to merge commits:\n\n```typescript\n// When adding ID to a merge commit:\nif (commit.parents.length \u003e 1) {\n  const parentIds: string[] = [];\n  \n  for (const parentHash of commit.parents) {\n    const parentCommit = commits.find(c =\u003e c.hash === parentHash);\n    if (parentCommit) {\n      const parentId = parentCommit.trailers[\"Spry-Commit-Id\"];\n      if (parentId) {\n        parentIds.push(parentId);\n      }\n    }\n    // Note: Don't include parents outside the stack\n  }\n\n  if (parentIds.length \u003e 0) {\n    trailersToAdd[\"Spry-Merge-Parents\"] = parentIds;\n  }\n}\n```\n\n### 4. Create merge validation module (src/git/merge-validation.ts - NEW)\n\n```typescript\nexport interface MergeValidationResult {\n  valid: boolean;\n  errors: string[];\n}\n\nexport async function validateMergeParents(\n  options: GitOptions = {}\n): Promise\u003cMergeValidationResult\u003e {\n  const commits = await getStackCommitsWithTrailers(options);\n  \n  const idToHash = new Map\u003cstring, string\u003e();\n  for (const commit of commits) {\n    const id = commit.trailers[\"Spry-Commit-Id\"];\n    if (id) idToHash.set(id, commit.hash);\n  }\n\n  const errors: string[] = [];\n\n  for (const commit of commits) {\n    const mergeParents = commit.trailers[\"Spry-Merge-Parents\"];\n    if (!Array.isArray(mergeParents) || mergeParents.length === 0) continue;\n\n    // Check actual parent count matches\n    if (commit.parents.length \u003c 2) {\n      errors.push(`Commit ${commit.hash.slice(0, 8)} has Spry-Merge-Parents but only ${commit.parents.length} parent(s)`);\n    }\n\n    // Check all merge parent IDs are reachable\n    for (const parentId of mergeParents) {\n      if (!idToHash.has(parentId)) {\n        errors.push(`Commit ${commit.hash.slice(0, 8)} references unreachable merge parent: ${parentId}`);\n      }\n    }\n  }\n\n  return { valid: errors.length === 0, errors };\n}\n```\n\n### 5. Add validation hooks to operations\n\nCall `validateMergeParents()` before and after operations in:\n- `applyGroupSpec()` (src/git/group-rebase.ts)\n- Other rebase operations\n\n## Design Rationale\n\n**Why preserve tree instead of re-merge?**\n- No new merge conflicts introduced\n- Merge resolution preserved exactly\n- Better performance (no merge computation)\n\n**Why use commit IDs instead of hashes?**\n- Hashes change on rebase\n- Commit IDs are stable identifiers\n\n## Verification\n\n1. Unit tests for `rewriteCommitChain` with merge commits\n2. Unit tests for `rebasePlumbing` with merge commits\n3. Integration tests for ID injection with merges\n4. Test validation catches invalid merge structures\n5. Create merge commit, rebase, verify structure preserved\n\n## Files to Modify\n\n- src/git/plumbing.ts\n- src/git/rebase.ts\n- src/git/merge-validation.ts (NEW)\n- src/git/group-rebase.ts (add validation hooks)","status":"open","priority":2,"issue_type":"task","owner":"don.denton@trillianthealth.com","created_at":"2026-01-13T11:39:22.415537-05:00","created_by":"Don Denton","updated_at":"2026-01-13T11:39:22.415537-05:00","dependencies":[{"issue_id":"spry-x0bw","depends_on_id":"spry-xvbw","type":"blocks","created_at":"2026-01-13T11:40:20.924793-05:00","created_by":"Don Denton"}]}
{"id":"spry-x2d","title":"VCR-style testing for GitHub API calls","description":"## Goal\nImplement VCR-style (record/replay) testing infrastructure for testing code that calls the GitHub API via the `gh` CLI.\n\n## Background\nThe sync command with `--open` flag makes calls to:\n- `gh api user --jq .login` (get username)\n- `gh pr list --head \u003cbranch\u003e` (find existing PRs)  \n- `gh pr create` (create new PRs)\n\nThese calls can't be tested in CI without real GitHub auth. VCR-style testing records real CLI outputs and replays them in tests.\n\n## Approach: Shell Executor Abstraction\n\nAfter researching HTTP-level options (nock, MSW), we determined CLI-level recording is the right approach because:\n- The code shells out to `gh` CLI, not HTTP directly\n- HTTP mocking would require proxying subprocess traffic (complex)\n- CLI-level captures real responses with simpler implementation\n- No battle-tested CLI VCR library exists, so we build our own\n\n## Architecture\n\n### Key Interfaces\n\n```typescript\ninterface ShellResult {\n  stdout: Buffer;\n  stderr: Buffer;\n  exitCode: number;\n}\n\ninterface ShellExecutor {\n  exec(command: string, args: string[]): Promise\u003cShellResult\u003e;\n}\n\ninterface Cassette {\n  name: string;\n  entries: FixtureEntry[];  // {command, args, stdout, stderr, exitCode}\n  recordedAt: string;\n}\n```\n\n### Three Executor Implementations\n\n1. **RealExecutor** - Runs actual commands via Bun's `$`\n2. **RecordingExecutor** - Wraps RealExecutor, saves responses to cassette file\n3. **ReplayExecutor** - Reads from cassette file, matches command+args exactly\n\n### Cassette Format (JSON)\n```json\n{\n  \"name\": \"github-auth\",\n  \"entries\": [\n    {\n      \"command\": \"gh\",\n      \"args\": [\"api\", \"user\", \"--jq\", \".login\"],\n      \"stdout\": \"base64-encoded-output\",\n      \"stderr\": \"\",\n      \"exitCode\": 0\n    }\n  ],\n  \"recordedAt\": \"2024-12-27T20:00:00.000Z\"\n}\n```\n\n## File Structure\n\n```\nsrc/testing/vcr/\n  types.ts          # ShellResult, ShellExecutor, Cassette interfaces\n  executor.ts       # RealExecutor, RecordingExecutor, ReplayExecutor\n  index.ts          # Public exports\n  executor.test.ts  # Self-tests using echo/sh commands (not gh!)\n\ntests/\n  fixtures/cassettes/     # JSON cassette files\n  helpers/vcr-fixture.ts  # withVCR() test helper\n```\n\n## Implementation Phases\n\n### Phase 1: Core VCR Library (test with echo/sh, not gh)\n1. Create `src/testing/vcr/types.ts` - interfaces\n2. Create `src/testing/vcr/executor.ts` - three executor implementations\n3. Create `src/testing/vcr/index.ts` - exports\n4. Create `src/testing/vcr/executor.test.ts` - self-tests\n\n### Phase 2: Test Helper\n1. Create `tests/fixtures/cassettes/` directory\n2. Create `tests/helpers/vcr-fixture.ts` with `withVCR()` helper\n\n### Phase 3: Refactor GitHub Module\nAdd optional `executor` parameter (backward compatible):\n1. `src/github/api.ts` - getGitHubUsername(), getDefaultBranch()\n2. `src/github/pr.ts` - findPRByBranch(), createPR()\n3. `src/github/branches.ts` - getBranchNameConfig()\n\n### Phase 4: Record Fixtures \u0026 Add Tests\n1. Run in record mode against real GitHub to create cassettes\n2. Add VCR tests for `--open` flag in `sync.test.ts`\n\n## Files to Modify\n- src/github/api.ts - add executor injection\n- src/github/pr.ts - add executor injection\n- src/github/branches.ts - add executor injection\n- src/cli/commands/sync.test.ts - add --open tests (has TODO comment)\n\n## Files to Create\n- src/testing/vcr/types.ts\n- src/testing/vcr/executor.ts\n- src/testing/vcr/index.ts\n- src/testing/vcr/executor.test.ts\n- tests/helpers/vcr-fixture.ts\n- tests/fixtures/cassettes/*.json\n\n## Testing Strategy for VCR Library Itself\nThe VCR library must be tested without circular dependencies. Use predictable shell commands:\n- `echo hello` → captures stdout\n- `sh -c 'exit 42'` → captures exit codes\n- `sh -c 'echo error \u003e\u00262'` → captures stderr\n\n## Acceptance Criteria\n- [ ] VCR library has passing self-tests (executor.test.ts)\n- [ ] GitHub functions accept optional executor parameter\n- [ ] Recording mode captures real gh responses to cassettes\n- [ ] Replay mode uses recorded fixtures (no network)\n- [ ] sync --open has comprehensive tests using VCR","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-26T23:41:07.092299-05:00","updated_at":"2026-01-10T00:36:02.177816-05:00"}
{"id":"spry-xnf","title":"Fetch PR review status","description":"## Goal\nGet review approval status for PRs.\n\n## Implementation\n\n```typescript\n// src/github/pr.ts\n\ntype ReviewStatus = 'approved' | 'changes_requested' | 'pending';\n\nasync function getPRReviewStatus(prNumber: number): Promise\u003cReviewStatus\u003e {\n  const result = await $\\`gh pr view \\${prNumber} --json reviewDecision\\`;\n  const data = JSON.parse(result.stdout.toString());\n  \n  switch (data.reviewDecision) {\n    case 'APPROVED': return 'approved';\n    case 'CHANGES_REQUESTED': return 'changes_requested';\n    default: return 'pending';\n  }\n}\n```\n\n## Review Decision Values\n- `APPROVED` - Required reviewers approved\n- `CHANGES_REQUESTED` - Reviewer requested changes\n- `REVIEW_REQUIRED` - Waiting for reviews\n- `null` - No reviews required\n\n## Testing\n- PR with approved reviews\n- PR with changes requested\n- PR awaiting review\n- PR with no review requirements\n\n## Files to Modify\n- src/github/pr.ts\n\n## Acceptance Criteria\n- [ ] Returns correct review status\n- [ ] Handles PRs without review requirements\n- [ ] Handles multiple reviewers","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-25T14:32:34.466183-05:00","updated_at":"2026-01-10T00:36:02.190368-05:00","closed_at":"2025-12-31T12:41:18.296812-05:00","close_reason":"Already implemented: getPRReviewStatus function exists at src/github/pr.ts:224-243 with determineReviewDecision helper at lines 72-83. Unit tests cover all review decision mappings (pr.test.ts:104-128). Integration tests verify: 'none' for PRs without review requirements, 'review_required' when branch protection requires reviews. Tests for 'approved' and 'changes_requested' are skipped (GitHub prevents self-review) but the logic is tested via unit tests.","dependencies":[{"issue_id":"spry-xnf","depends_on_id":"spry-7qh","type":"parent-child","created_at":"2025-12-25T14:32:38.0954-05:00","created_by":"daemon"}]}
{"id":"spry-xnl","title":"Branch creation and push","description":"## Goal\nPush commits to remote branches for each PRUnit.\n\n## Background\nEach PRUnit needs a branch on GitHub. The branch points to the HEAD commit of that PRUnit:\n- For singles: the single commit\n- For groups: the last commit in the group\n\n## Implementation\n\n```typescript\n// src/github/branches.ts\n\nasync function pushBranch(\n  commitHash: string, \n  branchName: string,\n  force: boolean = false\n): Promise\u003cvoid\u003e {\n  const forceFlag = force ? '--force' : '';\n  await $\\`git push ${forceFlag} origin ${commitHash}:refs/heads/${branchName}\\`;\n}\n\nasync function pushPRUnitBranch(unit: PRUnit, config: BranchNameConfig): Promise\u003cstring\u003e {\n  const branchName = getBranchName(unit.id, config);\n  const commitHash = unit.commits[unit.commits.length - 1]; // Last commit in unit\n  \n  await pushBranch(commitHash, branchName);\n  \n  return branchName;\n}\n```\n\n### Remote Branch Management\n```bash\n# Push specific commit to branch\ngit push origin abc123:refs/heads/taspr/msims/a1b2c3d4\n\n# Force push (needed after rebase)\ngit push --force origin abc123:refs/heads/taspr/msims/a1b2c3d4\n\n# Delete branch\ngit push origin --delete taspr/msims/a1b2c3d4\n```\n\n### Stack Ordering\nPush branches bottom-to-top so parent branches exist before creating child PRs:\n\n```typescript\nasync function pushAllBranches(units: PRUnit[]): Promise\u003cMap\u003cstring, string\u003e\u003e {\n  const config = await getBranchNameConfig();\n  const branches = new Map\u003cstring, string\u003e(); // prId -\u003e branchName\n  \n  // Push in order (oldest first = bottom of stack)\n  for (const unit of units) {\n    const branch = await pushPRUnitBranch(unit, config);\n    branches.set(unit.id, branch);\n  }\n  \n  return branches;\n}\n```\n\n## Edge Cases\n1. **Branch already exists**: Push still works (updates branch)\n2. **Permission denied**: Clear error about repo access\n3. **No remote**: Error about missing origin\n\n## Testing\n- Push creates branch on remote\n- Push updates existing branch\n- Force push works after rebase\n\n## Files to Modify\n- src/github/branches.ts\n\n## Acceptance Criteria\n- [ ] Pushes commits to correctly named branches\n- [ ] Updates existing branches\n- [ ] Force push supported for rebased commits\n- [ ] Clear errors on push failures","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-25T14:27:19.196006-05:00","updated_at":"2026-01-10T00:36:02.167253-05:00","closed_at":"2025-12-26T23:29:21.518681-05:00","close_reason":"Implemented and tested","dependencies":[{"issue_id":"spry-xnl","depends_on_id":"spry-ce1","type":"parent-child","created_at":"2025-12-25T14:27:22.733887-05:00","created_by":"daemon"},{"issue_id":"spry-xnl","depends_on_id":"spry-4b6","type":"depends-on","created_at":"2025-12-25T14:27:23.014297-05:00","created_by":"daemon"},{"issue_id":"spry-xnl","depends_on_id":"spry-4b6","type":"blocks","created_at":"2025-12-25T14:27:23.014297-05:00","created_by":"daemon"}]}
{"id":"spry-xo6","title":"CI: Manually triggered tests failing despite passing locally","description":"Manual test runs in CI are failing while the same tests pass in local environment. Some failures are related to missing authentication, but there may be other failure modes as well.\n\nInvestigation needed:\n- Identify all test failures in CI vs local\n- Determine which failures are auth-related\n- Identify any other failure causes\n- Fix environment/configuration differences between CI and local\n\nCI likely missing environment variables or secrets that are available locally.","status":"open","priority":1,"issue_type":"bug","created_at":"2026-01-12T00:21:46.476902-05:00","created_by":"dondenton","updated_at":"2026-01-12T00:21:46.476902-05:00"}
{"id":"spry-xt0q","title":"Recovery: Add sp group --recover command","description":"Add command to recover flattened merge commits by reconstructing them from `Spry-Merge-Parents` trailers.\n\n## Context\n\nUsers may perform rebases outside of spry (e.g., `git rebase`) that flatten merge commits into linear history. Since `Spry-Merge-Parents` trailers persist in commit messages, we can detect and recover these flattened merges.\n\n## Use Case\n\n```bash\n# User has merge commits in spry\nsp group  # Shows indented structure\n\n# User does external rebase\ngit rebase -i origin/main  # Flattens merge commits\n\n# Merge commits are now single-parent, but trailers remain\n# Recovery command rebuilds them\nsp group --recover\n```\n\n## Detection Logic\n\nA flattened merge commit has:\n1. `Spry-Merge-Parents` trailer (array with multiple values)\n2. Only one actual parent (`parents.length === 1`)\n\nThis indicates the merge was flattened and needs recovery.\n\n## Changes Required\n\n### 1. Add --recover flag to group command (src/cli/commands/group.ts)\n\n```typescript\nexport async function groupCommand(args: {\n  recover?: boolean;\n  // ... existing flags\n}) {\n  if (args.recover) {\n    return await recoverCommand();\n  }\n  // ... existing group logic\n}\n\nasync function recoverCommand() {\n  const commits = await getStackCommitsWithTrailers();\n  const flattenedMerges = detectFlattenedMerges(commits);\n\n  if (flattenedMerges.length === 0) {\n    console.log(\"No flattened merge commits detected.\");\n    return;\n  }\n\n  console.log(`Found ${flattenedMerges.length} flattened merge commit(s):`);\n  for (const merge of flattenedMerges) {\n    console.log(`  - ${merge.subject} (${merge.hash.slice(0, 8)})`);\n  }\n\n  // Confirm with user\n  const confirmed = await confirm(\"Recover these merge commits?\");\n  if (!confirmed) return;\n\n  // Perform recovery\n  await recoverMergeCommits(flattenedMerges);\n  \n  console.log(\"✓ Merge commits recovered successfully.\");\n}\n```\n\n### 2. Create merge recovery module (src/git/merge-recovery.ts - NEW)\n\n```typescript\nexport interface FlattenedMerge {\n  hash: string;\n  subject: string;\n  body: string;\n  trailers: CommitTrailers;\n  mergeParentIds: string[];  // From Spry-Merge-Parents\n  actualParents: string[];  // Current parent count\n}\n\n/**\n * Detect merge commits that have been flattened (single parent but has Spry-Merge-Parents).\n */\nexport function detectFlattenedMerges(\n  commits: CommitWithTrailers[]\n): FlattenedMerge[] {\n  const flattened: FlattenedMerge[] = [];\n\n  for (const commit of commits) {\n    const mergeParents = commit.trailers[\"Spry-Merge-Parents\"];\n    \n    // Check if has trailer but is not actually a merge\n    if (Array.isArray(mergeParents) \u0026\u0026 mergeParents.length \u003e 0) {\n      if (commit.parents.length \u003c 2) {\n        flattened.push({\n          hash: commit.hash,\n          subject: commit.subject,\n          body: commit.body,\n          trailers: commit.trailers,\n          mergeParentIds: mergeParents,\n          actualParents: commit.parents,\n        });\n      }\n    }\n  }\n\n  return flattened;\n}\n\n/**\n * Recover flattened merge commits by reconstructing them with multiple parents.\n */\nexport async function recoverMergeCommits(\n  flattenedMerges: FlattenedMerge[],\n  options: GitOptions = {}\n): Promise\u003cvoid\u003e {\n  await assertNotDetachedHead(options);\n\n  const commits = await getStackCommitsWithTrailers(options);\n  const idToHash = new Map\u003cstring, string\u003e();\n  \n  for (const commit of commits) {\n    const id = commit.trailers[\"Spry-Commit-Id\"];\n    if (id) idToHash.set(id, commit.hash);\n  }\n\n  // Build list of all commits to rewrite\n  const allHashes = commits.map(c =\u003e c.hash);\n  const rewrites = new Map\u003cstring, string\u003e();  // hash -\u003e new message (unchanged)\n  const mergeReconstructions = new Map\u003cstring, string[]\u003e();  // hash -\u003e parent hashes\n\n  for (const flattened of flattenedMerges) {\n    // Resolve parent IDs to hashes\n    const parentHashes: string[] = [];\n    \n    for (const parentId of flattened.mergeParentIds) {\n      const parentHash = idToHash.get(parentId);\n      if (!parentHash) {\n        throw new Error(`Cannot recover merge ${flattened.hash.slice(0, 8)}: parent ID ${parentId} not found in stack`);\n      }\n      parentHashes.push(parentHash);\n    }\n\n    if (parentHashes.length \u003c 2) {\n      throw new Error(`Merge ${flattened.hash.slice(0, 8)} must have at least 2 parents`);\n    }\n\n    // Store parent hashes for reconstruction\n    mergeReconstructions.set(flattened.hash, parentHashes);\n    \n    // Message stays the same (already has trailers)\n    const originalMessage = await getCommitMessage(flattened.hash, options);\n    rewrites.set(flattened.hash, originalMessage);\n  }\n\n  // Rewrite commit chain, reconstructing merges with multiple parents\n  const branch = await getCurrentBranch(options);\n  const oldTip = allHashes[allHashes.length - 1];\n\n  const result = await rewriteCommitChainWithMerges(\n    allHashes,\n    rewrites,\n    mergeReconstructions,\n    options\n  );\n\n  await finalizeRewrite(branch, oldTip, result.newTip, options);\n}\n\n/**\n * Extended rewriteCommitChain that reconstructs merge commits.\n */\nasync function rewriteCommitChainWithMerges(\n  commits: string[],\n  rewrites: Map\u003cstring, string\u003e,\n  mergeReconstructions: Map\u003cstring, string[]\u003e,\n  options: GitOptions = {},\n): Promise\u003cChainRewriteResult\u003e {\n  const mapping = new Map\u003cstring, string\u003e();\n\n  for (const originalHash of commits) {\n    const tree = await getTree(originalHash, options);\n    const env = await getAuthorAndCommitterEnv(originalHash, options);\n    const message = rewrites.get(originalHash) ?? await getCommitMessage(originalHash, options);\n\n    // Check if this is a merge to reconstruct\n    const reconstructParents = mergeReconstructions.get(originalHash);\n    \n    let newParents: string[];\n    if (reconstructParents) {\n      // Reconstruct merge: map original parents to new hashes\n      newParents = reconstructParents.map(p =\u003e mapping.get(p) ?? p);\n    } else {\n      // Regular commit: use existing parent mapping logic\n      const originalParents = await getParents(originalHash, options);\n      newParents = originalParents.map(p =\u003e mapping.get(p) ?? p);\n    }\n\n    const newHash = await createCommit(tree, newParents, message, env, options);\n    mapping.set(originalHash, newHash);\n  }\n\n  const lastCommit = commits[commits.length - 1];\n  const newTip = mapping.get(lastCommit)!;\n\n  return { newTip, mapping };\n}\n```\n\n## Validation\n\nRecovery validates:\n1. All merge parent IDs exist in stack (reachable)\n2. At least 2 parents per merge\n3. Tree consistency preserved\n4. No conflicts introduced\n\n## Verification\n\n1. Unit tests for `detectFlattenedMerges()`\n2. Integration test: Create merge, flatten with git, recover\n3. Test recovery with multiple flattened merges\n4. Test error handling: unreachable parent ID\n5. Manual test: External rebase, then `sp group --recover`\n\n## Files to Modify\n\n- src/cli/commands/group.ts (add --recover flag)\n- src/git/merge-recovery.ts (NEW recovery module)\n\n## Dependencies\n\nRequires Phase 1-5 complete (merge commits exist and have trailers).","status":"open","priority":2,"issue_type":"task","owner":"don.denton@trillianthealth.com","created_at":"2026-01-13T11:40:13.112858-05:00","created_by":"Don Denton","updated_at":"2026-01-13T11:40:13.112858-05:00","dependencies":[{"issue_id":"spry-xt0q","depends_on_id":"spry-sfux","type":"blocks","created_at":"2026-01-13T11:40:21.448721-05:00","created_by":"Don Denton"}]}
{"id":"spry-xvbw","title":"Data model: Add parent tracking and multi-value trailers","description":"Extend the data model to track commit parents and support multi-value trailers for merge commit metadata.\n\n## Context\n\nTo support merge commits, we need to track which commits have multiple parents and store merge parent relationships in trailers. Currently, `CommitInfo` has no parent information, and trailer parsing only keeps the last value for duplicate keys.\n\n## Changes Required\n\n### 1. Extend CommitInfo type (src/types.ts)\n\nAdd `parents: string[]` field:\n\n```typescript\nexport interface CommitInfo {\n  hash: string;\n  subject: string;\n  body: string;\n  trailers: Record\u003cstring, string | string[]\u003e;  // Allow array values\n  parents: string[];  // NEW\n}\n```\n\n### 2. Update getStackCommits (src/git/commands.ts:43-76)\n\nAdd `%P` to git log format to fetch parent hashes:\n\n```typescript\n// Current format: %H%x00%s%x00%B%x01\n// New format: %H%x00%P%x00%s%x00%B%x01\n// %P = space-separated parent hashes\n\nconst result = await `git log --reverse --format=%H%x00%P%x00%s%x00%B%x01 ${mergeBase}..HEAD`.text();\n\n// Parse parents (empty string for root commits):\nconst parents = parentsRaw.trim() ? parentsRaw.trim().split(/\\s+/) : [];\n```\n\n### 3. Extend parseTrailers for multi-value support (src/git/trailers.ts)\n\nSupport array values for `Spry-Merge-Parents`:\n\n```typescript\nexport interface CommitTrailers {\n  \"Spry-Commit-Id\"?: string;\n  \"Spry-Group\"?: string;\n  \"Spry-Merge-Parents\"?: string[];  // NEW - array of commit IDs\n  [key: string]: string | string[] | undefined;\n}\n\n// In parseTrailers():\nconst multiValueKeys = new Set([\"Spry-Merge-Parents\"]);\n\n// Accumulate values in array for multi-value keys\nif (multiValueKeys.has(key)) {\n  const existing = trailers[key];\n  if (Array.isArray(existing)) {\n    existing.push(value);\n  } else {\n    trailers[key] = [value];\n  }\n}\n```\n\n### 4. Update addTrailers to handle array values (src/git/trailers.ts)\n\n```typescript\nexport async function addTrailers(\n  message: string,\n  trailers: Record\u003cstring, string | string[]\u003e,\n): Promise\u003cstring\u003e {\n  const trailerArgs: string[] = [];\n  for (const [key, value] of Object.entries(trailers)) {\n    if (Array.isArray(value)) {\n      // Add multiple trailers with same key\n      for (const v of value) {\n        trailerArgs.push(\"--trailer\", `${key}: ${v}`);\n      }\n    } else {\n      trailerArgs.push(\"--trailer\", `${key}: ${value}`);\n    }\n  }\n  // ... rest of function\n}\n```\n\n## Trailer Format\n\n```\nSpry-Merge-Parents: parent-commit-id-1\nSpry-Merge-Parents: parent-commit-id-2\n```\n\n- Multiple trailers with same key (git convention)\n- References commit IDs, not hashes (stable across rebases)\n- Only tracks parents within the stack (not external branches)\n\n## Verification\n\n1. Unit tests for parent parsing from git log\n2. Unit tests for multi-value trailer parsing\n3. Unit tests for adding array-valued trailers\n4. Test with merge commits: verify parents array populated\n5. Test trailer roundtrip: add → parse → verify array preserved\n\n## Files to Modify\n\n- src/types.ts\n- src/git/commands.ts\n- src/git/trailers.ts","status":"open","priority":2,"issue_type":"task","owner":"don.denton@trillianthealth.com","created_at":"2026-01-13T11:39:18.55598-05:00","created_by":"Don Denton","updated_at":"2026-01-13T11:39:18.55598-05:00"}
{"id":"spry-y2tt","title":"UI: Add indent/outdent in group editor move mode","description":"Add visual indent/outdent functionality to the group editor's move mode using ←→ arrows. Initially, merge commits are placeholders filtered before git operations.\n\n## Context\n\nThe group editor has move mode (activated by Space) that uses ↑↓ for reordering. The ←→ arrows are unused in move mode. We'll use them for indenting/outdenting commits to create visual branch-and-merge structures.\n\n**Current move mode behavior:**\n- Space toggles move mode\n- ↑↓ swap adjacent commits\n- ←→ disabled (used for group assignment in normal mode)\n\n## Visual Design\n\nIndented commits are disconnected from parent (showing branch point). Merge commit at same level as parent (showing rejoin).\n\n```\n  A commit 1\n    A commit 2         (indented, disconnected)\n    A commit 3         (indented)\n  A [merge] Merge      (NOT indented, rejoins)\n  A commit 4\n```\n\n## Changes Required\n\n### 1. Extend TUIState (src/tui/state.ts)\n\n```typescript\nexport interface TUIState {\n  // ... existing fields ...\n  indentLevels: Map\u003cnumber, number\u003e;  // commit index -\u003e 0 or 1\n  mergeCommits: Map\u003cnumber, MergeCommitInfo\u003e;  // index -\u003e merge info\n}\n\nexport interface MergeCommitInfo {\n  placeholderId: string;  // For internal tracking\n  subject: string;\n  isPlaceholder: true;\n  firstIndentedIndex: number;\n}\n\nexport interface CommitDisplay {\n  // ... existing fields ...\n  isMergeCommit?: boolean;\n  mergeInfo?: MergeCommitInfo;\n}\n```\n\n### 2. Implement indentCommit() (src/tui/state.ts)\n\n```typescript\nexport function indentCommit(state: TUIState): TUIState {\n  if (state.moveMode === null) return state;\n  \n  const currentIdx = state.moveMode;\n  const currentLevel = state.indentLevels.get(currentIdx) ?? 0;\n\n  // Validation: already indented or at top\n  if (currentLevel === 1 || currentIdx === 0) return state;\n\n  // Check if previous commit is also indented (contiguous block)\n  const prevIdx = currentIdx - 1;\n  const prevLevel = state.indentLevels.get(prevIdx) ?? 0;\n\n  const newIndentLevels = new Map(state.indentLevels);\n  newIndentLevels.set(currentIdx, 1);\n\n  const newGroups = new Map(state.groups);\n  const newMergeCommits = new Map(state.mergeCommits);\n  const newCommits = [...state.commits];\n\n  // Auto-assign group if not grouped\n  let currentGroup = newGroups.get(currentIdx);\n  if (\\!currentGroup) {\n    currentGroup = findNextAvailableGroup(new Set(Array.from(newGroups.values()).filter(g =\u003e g \\!== null)));\n    newGroups.set(currentIdx, currentGroup);\n  }\n\n  // If previous is NOT indented, create merge commit placeholder\n  if (prevLevel === 0) {\n    const prevCommit = newCommits[prevIdx];\n    if (\\!prevCommit?.isMergeCommit) {\n      const mergeInfo: MergeCommitInfo = {\n        placeholderId: `merge-${Date.now()}-${Math.random()}`,\n        subject: `Merge group ${currentGroup}`,\n        isPlaceholder: true,\n        firstIndentedIndex: currentIdx,\n      };\n\n      const mergeCommit: CommitDisplay = {\n        hash: mergeInfo.placeholderId,\n        shortHash: mergeInfo.placeholderId.slice(0, 8),\n        subject: mergeInfo.subject,\n        isMergeCommit: true,\n        mergeInfo,\n      };\n\n      // Insert merge commit at current position\n      newCommits.splice(currentIdx, 0, mergeCommit);\n      \n      // Update all maps for insertion (shift indices)\n      // ... (detailed implementation in code)\n    }\n  }\n\n  return { ...state, indentLevels: newIndentLevels, groups: newGroups, mergeCommits: newMergeCommits, commits: newCommits, dirty: true };\n}\n```\n\n### 3. Implement outdentCommit() (src/tui/state.ts)\n\n```typescript\nexport function outdentCommit(state: TUIState): TUIState {\n  if (state.moveMode === null) return state;\n  \n  const currentIdx = state.moveMode;\n  const currentLevel = state.indentLevels.get(currentIdx) ?? 0;\n\n  if (currentLevel === 0) return state;  // Not indented\n\n  const newIndentLevels = new Map(state.indentLevels);\n  newIndentLevels.set(currentIdx, 0);\n\n  // Check if merge commit should be removed\n  // Look backwards for merge commit, check if other indented commits remain\n  // If no other indented commits, remove merge commit and shift indices\n\n  return { ...state, indentLevels: newIndentLevels, dirty: true };\n}\n```\n\n### 4. Wire up keybindings (src/tui/group-editor.ts)\n\n```typescript\ncase \"left\":\n  if (state.moveMode \\!== null) {\n    // In move mode: outdent\n    state = outdentCommit(state);\n    redraw();\n  } else if (\\!key.shift) {\n    // Normal mode: cycle group\n    state = cycleGroup(state, \"left\");\n    redraw();\n  }\n  break;\n\ncase \"right\":\n  if (state.moveMode \\!== null) {\n    // In move mode: indent\n    state = indentCommit(state);\n    redraw();\n  } else if (\\!key.shift) {\n    // Normal mode: cycle group\n    state = cycleGroup(state, \"right\");\n    redraw();\n  }\n  break;\n```\n\n### 5. Update rendering (src/tui/render.ts)\n\n```typescript\nfunction renderCommitLine(state: TUIState, index: number, validation): string {\n  const commit = state.commits[index];\n  const indentLevel = state.indentLevels.get(index) ?? 0;\n  const isMerge = commit.isMergeCommit ?? false;\n\n  const parts: string[] = [];\n\n  // Cursor indicator\n  if (index === state.moveMode) {\n    parts.push(colors.yellow(\"»\"));\n  } else if (index === state.cursor) {\n    parts.push(colors.cyan(\"→\"));\n  } else {\n    parts.push(\" \");\n  }\n\n  // Indentation (extra spaces for indented commits)\n  if (indentLevel === 1) {\n    parts.push(\"  \");  // Two spaces\n  }\n\n  // Merge commit indicator\n  if (isMerge) {\n    parts.push(` ${colors.blue(\"⎇\")}`);  // Git merge symbol, dimmed\n  } else if (group) {\n    parts.push(` ${colors.magenta(group)}`);\n  } else {\n    parts.push(\" ─\");\n  }\n\n  // Hash and subject (dim for merge commits)\n  if (isMerge) {\n    parts.push(` ${colors.dim(\"(merge)\")}`);\n    parts.push(`  ${colors.dim(commit.subject)}`);\n  } else {\n    parts.push(` ${colors.dim(hashDisplay)}`);\n    parts.push(`  ${subject}`);\n  }\n\n  return parts.join(\"\");\n}\n```\n\n### 6. Update help line\n\n```typescript\nfunction renderHelpLine(state: TUIState, validation): string {\n  if (state.moveMode \\!== null) {\n    return colors.dim(\"↑↓ swap position │ Space exit move mode │ ←→ indent/outdent\");\n  }\n  // ... normal mode help\n}\n```\n\n### 7. Filter merge placeholders before git operations\n\n```typescript\n// In runGroupEditor(), before applying changes:\nconst realCommits = finalState.commits.filter(c =\u003e \\!c.isMergeCommit);\nconst newOrder = realCommits.map(c =\u003e c.hash);\n// ... proceed with applyGroupSpec\n```\n\n## Validation\n\nAdd validation for indent structure:\n\n```typescript\nexport function validateIndentStructure(state: TUIState): IndentValidationResult {\n  // Rule: Merge commits must be followed by indented commits\n  // Rule: Indented commits must follow a merge\n  // Return { valid: boolean, error?: string }\n}\n```\n\n## Move Mode Interaction\n\nUpdate `swapCommit()` to prevent swapping with merge commits:\n\n```typescript\n// Don't allow swapping with merge commits\nif (currentCommit?.isMergeCommit || targetCommit?.isMergeCommit) {\n  return state;\n}\n```\n\n## Verification\n\n1. Manual TUI testing: indent/outdent commits\n2. Verify merge placeholder creation/removal\n3. Verify placeholders are filtered before git operations\n4. Test moving commits into/out of indented sections\n5. Verify group auto-assignment on indent\n6. Test help line updates in move mode\n\n## Files to Modify\n\n- src/tui/state.ts\n- src/tui/group-editor.ts\n- src/tui/render.ts\n\n## Important Note\n\nAt this phase, merge commits are **placeholder-only**. They exist in the TUI state but are filtered out before any git operations. Phase 6 will make them real.","status":"open","priority":2,"issue_type":"task","owner":"don.denton@trillianthealth.com","created_at":"2026-01-13T11:39:24.088729-05:00","created_by":"Don Denton","updated_at":"2026-01-13T11:39:24.088729-05:00","dependencies":[{"issue_id":"spry-y2tt","depends_on_id":"spry-xvbw","type":"blocks","created_at":"2026-01-13T11:40:21.103142-05:00","created_by":"Don Denton"}]}
{"id":"spry-y8s","title":"Implement squash-resilient group markers","description":"## Summary\n\nReplace `Taspr-Group-Start`/`Taspr-Group-End` markers with redundant markers on ALL commits in a group for squash resilience.\n\n## Solution\n\nEvery commit in a group gets **both**:\n- `Taspr-Group: \u003cgroupId\u003e`\n- `Taspr-Group-Title: \u003ctitle\u003e`\n\nNo Start/End markers needed. Group ends when we encounter a commit without the same group marker.\n\n**Why this works:**\n- Squashing any commits leaves remaining commits with their group trailers\n- Title on every commit means no fallback logic needed\n- Detection is simpler: contiguous commits with same `Taspr-Group` = one group\n\n## Files to Modify\n\n1. **src/git/trailers.ts** - Add `Taspr-Group`, remove `Taspr-Group-Start`/`End`\n2. **src/types.ts** - Add `split-group` and `inconsistent-group-title` errors, remove old errors\n3. **src/core/stack.ts** - Rewrite detection: group = contiguous commits with same `Taspr-Group`\n4. **src/git/group-rebase.ts** - Add both trailers to ALL commits, remove old helpers\n5. **src/cli/commands/group.ts** - Update `--fix` for new error types\n6. **src/tui/group-editor.ts** - Detect groups by `Taspr-Group` trailer\n7. **src/cli/output.ts** - Error messages for new types\n8. **Tests** - Update all group-related tests\n9. **README.md** - Update docs, remove FIXUP_GROUP_DOCS marker\n\n## Implementation Order\n\n1. trailers.ts - Add/remove trailer types\n2. types.ts - Add new error types\n3. stack.ts - Update detection\n4. group-rebase.ts - Update group creation\n5. group.ts + group-editor.ts - Update CLI/TUI\n6. output.ts - Update error messages\n7. Tests\n8. README.md\n\n## Acceptance Criteria\n\n- [ ] Squashing fixup! commits doesn't break group integrity\n- [ ] Clear error for split groups (non-contiguous commits with same ID)\n- [ ] Clear error for inconsistent group titles\n- [ ] `taspr group --fix` can repair split groups and inconsistent titles\n- [ ] Documentation updated (remove FIXUP_GROUP_DOCS marker)\n\nFull plan: ~/.claude/plans/binary-mapping-haven.md","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-03T21:24:54.549773-05:00","updated_at":"2026-01-10T00:36:02.176722-05:00","closed_at":"2026-01-03T21:53:33.115258-05:00","close_reason":"Implemented squash-resilient group markers. Replaced Taspr-Group-Start/End with Taspr-Group+Taspr-Group-Title on ALL commits in a group. Updated all related code, tests, and scenarios.","dependencies":[{"issue_id":"spry-y8s","depends_on_id":"spry-ei6","type":"discovered-from","created_at":"2026-01-03T21:25:01.758401-05:00","created_by":"dondenton"}]}
{"id":"spry-ycg","title":"Create Story API and logger","description":"Read the parent epic spry-ww0 for full context.\n\n## Task\nCreate the Story API in tests/helpers/story.ts that allows tests to log narratives and command outputs.\n\n## Interface\n\n```\ninterface Story {\n  begin(testName: string): void;\n  narrate(text: string): void;\n  log(result: CommandResult): void;\n  end(): void;\n  flush(): Promise\u003cvoid\u003e;\n}\n```\n\n## Implementation\n\nStoryLogger class that:\n- Checks TASPR_STORY_TEST_LOGGING=1 env var to enable/disable\n- Buffers entries as interleaved narrate/command entries\n- On flush(), writes both .md (ANSI stripped) and .ansi (colors preserved) to test-logs/\n- Uses stripAnsi regex: /\\x1b\\[[0-9;]*m/g\n\n## Test ID Sanitization\n\nThe test fixtures create repos with random IDs (e.g., `humble-panda-zl3`) that appear throughout output. These must be stripped from story logs to create stable, readable documentation.\n\n**What to strip:**\n- Branch names: `feature-humble-panda-zl3` → `feature-{test-id}`\n- Commit messages: `First commit [humble-panda-zl3]` → `First commit`\n- Anywhere else the test ID appears in stdout/stderr\n\n**Implementation approach:**\n- `createStory()` accepts an optional `testId` parameter\n- When set, the Story replaces all occurrences of the test ID with a placeholder or removes it entirely\n- This happens during `log()` before buffering, so both .md and .ansi outputs are clean\n\n**Example transformation:**\n```\nStack: feature-humble-panda-zl3 (3 commits, PRs: 0/2 opened)\n  ○ First grouped commit [humble-panda-zl3] [group-abc]\n```\nbecomes:\n```\nStack: feature-{id} (3 commits, PRs: 0/2 opened)\n  ○ First grouped commit [group-abc]\n```\n\n## Output Format\n\nEach story section in the markdown:\n```\n---\n\n## {testName}\n\n{narrative text}\n\n### `{command}`\n\n```\n{stdout}\n```\n\n---\n```\n\n## Files\n- tests/helpers/story.ts (new file)\n\n## Acceptance\n- Story API works when env var is set\n- No-ops silently when env var is not set\n- Generates readable markdown output\n- Test IDs are sanitized from output when testId is provided","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-05T00:33:10.602497-05:00","updated_at":"2026-01-09T10:36:55.852173-05:00","closed_at":"2026-01-09T10:36:55.852173-05:00","close_reason":"Implemented Story API with test ID sanitization","dependencies":[{"issue_id":"spry-ycg","depends_on_id":"spry-vpx","type":"blocks","created_at":"2026-01-05T00:33:48.112626-05:00","created_by":"dondenton"}]}
